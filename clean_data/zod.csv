repo,commit,commit_msg,file,left_diff,right_diff,merged_diff
colinhacks_zod,7e86228eecbe3d7857da0305108fcca541fd3aaf,Merge pull request #1617 from Howdju/features/recursive-custom-formatted-error-type  Propagate custom error type to ZodFormattedError subfields,deno/lib/ZodError.ts,"+  received: unknown;
+  exact?: boolean;
+  exact?: boolean;","-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }","+  received: unknown;
+  exact?: boolean;
+  exact?: boolean;
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }"
colinhacks_zod,7e86228eecbe3d7857da0305108fcca541fd3aaf,Merge pull request #1617 from Howdju/features/recursive-custom-formatted-error-type  Propagate custom error type to ZodFormattedError subfields,src/ZodError.ts,"+  received: unknown;
+  exact?: boolean;
+  exact?: boolean;","-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }","+  received: unknown;
+  exact?: boolean;
+  exact?: boolean;
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }
-  ? { [k: number]: ZodFormattedError<NonNullable<T>[number]> }
+  ? { [k: number]: ZodFormattedError<NonNullable<T>[number], U> }
-  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]> }
+  ? { [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K], U> }"
colinhacks_zod,d1982eaf0db82bcd510a3fabe617368a8dd393a0,Merge branch 'master' of https://github.com/colinhacks/zod,src/types.ts,"+        received: ctx.data,","-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();","-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();
+        received: ctx.data,"
colinhacks_zod,84795b099e70b9862783df981a9246d241e4abfa,Merge pull request #1702 from p10ns11y/patch-1  change the chaining order of nullish method,src/types.ts,"-    return ZodOptional.create(this) as any;
+    return ZodOptional.create(this, this._def) as any;
-    return ZodNullable.create(this) as any;
+    return ZodNullable.create(this, this._def) as any;
-    return ZodArray.create(this);
+    return ZodArray.create(this, this._def);
-    return ZodPromise.create(this);
+    return ZodPromise.create(this, this._def);
-    return ZodUnion.create([this, option]) as any;
+    return ZodUnion.create([this, option], this._def) as any;
-    return ZodIntersection.create(this, incoming);
+    return ZodIntersection.create(this, incoming, this._def);
+      ...processCreateParams(this._def),
+      ...processCreateParams(this._def),
-      ...processCreateParams(undefined),
-    });
-  }
-  catch(def: Input): ZodCatch<this>;
-  catch(def: () => Input): ZodCatch<this>;
+      ...processCreateParams(this._def),
+    });
+  }
+
+  catch(def: Output): ZodCatch<this>;
+  catch(def: () => Output): ZodCatch<this>;
-    const defaultValueFunc = typeof def === ""function"" ? def : () => def;
+    const catchValueFunc = typeof def === ""function"" ? def : () => def;
+      ...processCreateParams(this._def),
-      defaultValue: defaultValueFunc,
+      catchValue: catchValueFunc,
-  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+  /^(([^<>()[\].,;:\s@""]+(\.[^<>()[\].,;:\s@""]+)*)|("".+""))@((?!-)([^<>()[\].,;:\s@""]+\.)+[^<>()[\].,;:\s@""]{1,})[^-<>()[\].,;:\s@""]$/i;
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:?\\d{2})|Z)$`
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:?\\d{2})|Z)$`
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:?\\d{2})|Z)$`
-    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+    return !!this._def.checks.find(
+      (ch) =>
+        ch.kind === ""int"" ||
+        (ch.kind === ""multipleOf"" && util.isInteger(ch.value))
+    );
+  }
+
+  get isFinite() {
+    let max: number | null = null,
+      min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (
+        ch.kind === ""finite"" ||
+        ch.kind === ""int"" ||
+        ch.kind === ""multipleOf""
+      ) {
+        return true;
+      } else if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      } else if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return Number.isFinite(min) && Number.isFinite(max);
-        (ctx.data as any[]).map((item, i) => {
+        ([...ctx.data] as any[]).map((item, i) => {
-    const result = (ctx.data as any[]).map((item, i) => {
+    const result = ([...ctx.data] as any[]).map((item, i) => {
-    const items = (ctx.data as any[])
+    const items = ([...ctx.data] as any[])
-export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodCatchDef<
+  T extends ZodTypeAny = ZodTypeAny,
+  C extends T[""_input""] = T[""_input""]
+> extends ZodTypeDef {
-  defaultValue: () => T[""_input""];
+  catchValue: () => C;
-  util.noUndefined<T[""_output""]>,
+  T[""_output""],
-  T[""_input""] | undefined
+  T[""_input""]
-            result.status === ""valid"" ? result.value : this._def.defaultValue(),
+            result.status === ""valid"" ? result.value : this._def.catchValue(),
-          result.status === ""valid"" ? result.value : this._def.defaultValue(),
+          result.status === ""valid"" ? result.value : this._def.catchValue(),
-  removeDefault() {
+  removeCatch() {
-      default: T[""_input""] | (() => T[""_input""]);
+      catch: T[""_output""] | (() => T[""_output""]);
-      defaultValue:
-        typeof params.default === ""function""
-          ? params.default
-          : () => params.default,
+      catchValue:
+        typeof params.catch === ""function"" ? params.catch : () => params.catch,","-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();","-    return ZodOptional.create(this) as any;
+    return ZodOptional.create(this, this._def) as any;
-    return ZodNullable.create(this) as any;
-  }
-  nullish(): ZodNullable<ZodOptional<this>> {
-    return this.optional().nullable();
+    return ZodNullable.create(this, this._def) as any;
+  }
+  nullish(): ZodOptional<ZodNullable<this>> {
+    return this.nullable().optional();
-    return ZodArray.create(this);
+    return ZodArray.create(this, this._def);
-    return ZodPromise.create(this);
+    return ZodPromise.create(this, this._def);
-    return ZodUnion.create([this, option]) as any;
+    return ZodUnion.create([this, option], this._def) as any;
-    return ZodIntersection.create(this, incoming);
+    return ZodIntersection.create(this, incoming, this._def);
+      ...processCreateParams(this._def),
+      ...processCreateParams(this._def),
-      ...processCreateParams(undefined),
-    });
-  }
-  catch(def: Input): ZodCatch<this>;
-  catch(def: () => Input): ZodCatch<this>;
+      ...processCreateParams(this._def),
+    });
+  }
+
+  catch(def: Output): ZodCatch<this>;
+  catch(def: () => Output): ZodCatch<this>;
-    const defaultValueFunc = typeof def === ""function"" ? def : () => def;
+    const catchValueFunc = typeof def === ""function"" ? def : () => def;
+      ...processCreateParams(this._def),
-      defaultValue: defaultValueFunc,
+      catchValue: catchValueFunc,
-  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+  /^(([^<>()[\].,;:\s@""]+(\.[^<>()[\].,;:\s@""]+)*)|("".+""))@((?!-)([^<>()[\].,;:\s@""]+\.)+[^<>()[\].,;:\s@""]{1,})[^-<>()[\].,;:\s@""]$/i;
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:?\\d{2})|Z)$`
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:?\\d{2})|Z)$`
-        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`
+        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:?\\d{2})|Z)$`
-    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+    return !!this._def.checks.find(
+      (ch) =>
+        ch.kind === ""int"" ||
+        (ch.kind === ""multipleOf"" && util.isInteger(ch.value))
+    );
+  }
+
+  get isFinite() {
+    let max: number | null = null,
+      min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (
+        ch.kind === ""finite"" ||
+        ch.kind === ""int"" ||
+        ch.kind === ""multipleOf""
+      ) {
+        return true;
+      } else if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      } else if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return Number.isFinite(min) && Number.isFinite(max);
-        (ctx.data as any[]).map((item, i) => {
+        ([...ctx.data] as any[]).map((item, i) => {
-    const result = (ctx.data as any[]).map((item, i) => {
+    const result = ([...ctx.data] as any[]).map((item, i) => {
-    const items = (ctx.data as any[])
+    const items = ([...ctx.data] as any[])
-export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodCatchDef<
+  T extends ZodTypeAny = ZodTypeAny,
+  C extends T[""_input""] = T[""_input""]
+> extends ZodTypeDef {
-  defaultValue: () => T[""_input""];
+  catchValue: () => C;
-  util.noUndefined<T[""_output""]>,
+  T[""_output""],
-  T[""_input""] | undefined
+  T[""_input""]
-            result.status === ""valid"" ? result.value : this._def.defaultValue(),
+            result.status === ""valid"" ? result.value : this._def.catchValue(),
-          result.status === ""valid"" ? result.value : this._def.defaultValue(),
+          result.status === ""valid"" ? result.value : this._def.catchValue(),
-  removeDefault() {
+  removeCatch() {
-      default: T[""_input""] | (() => T[""_input""]);
+      catch: T[""_output""] | (() => T[""_output""]);
-      defaultValue:
-        typeof params.default === ""function""
-          ? params.default
-          : () => params.default,
+      catchValue:
+        typeof params.catch === ""function"" ? params.catch : () => params.catch,"
colinhacks_zod,157f8c560a551b65148aed0b419513993badfb82,Merge pull request #1057 from tmcw/faster-extra-keys  Faster extra keys detection,deno/lib/types.ts,"-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,","-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }","-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }"
colinhacks_zod,157f8c560a551b65148aed0b419513993badfb82,Merge pull request #1057 from tmcw/faster-extra-keys  Faster extra keys detection,src/types.ts,"-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,","-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }","-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-        typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-    const dataKeys = util.objectKeys(ctx.data);
-    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
+    const extraKeys: string[] = [];
+    for (const key in ctx.data) {
+      if (!shapeKeys.includes(key)) {
+        extraKeys.push(key);
+      }
+    }"
colinhacks_zod,acba037863914eb1e83521ea626715fb0f0c7a79,Merge pull request #1023 from tmcw/remove-typecache  Remove typeCache,deno/lib/types.ts,"+  | ZodDiscriminatedUnion<any, any, any>","-        parsedType: getParsedType(input.data, input.parent.typeCache),
+        parsedType: getParsedType(input.data),
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,","-        parsedType: getParsedType(input.data, input.parent.typeCache),
+        parsedType: getParsedType(input.data),
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
+  | ZodDiscriminatedUnion<any, any, any>"
colinhacks_zod,acba037863914eb1e83521ea626715fb0f0c7a79,Merge pull request #1023 from tmcw/remove-typecache  Remove typeCache,src/types.ts,"+  | ZodDiscriminatedUnion<any, any, any>","-        parsedType: getParsedType(input.data, input.parent.typeCache),
+        parsedType: getParsedType(input.data),
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,","-        parsedType: getParsedType(input.data, input.parent.typeCache),
+        parsedType: getParsedType(input.data),
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
+  | ZodDiscriminatedUnion<any, any, any>"
colinhacks_zod,66cbfe092fc06f5efed85ddbac2fa9bf2541ccc1,Merge pull request #752 from Meraki-Solutions/partial-records  Records should be partial so we're not required to use all keys,src/types.ts,"+import { Primitive } from ""./helpers/typeAliases"";
-export type { TypeOf as infer };
+
+type allKeys<T> = T extends any ? keyof T : never;
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in allKeys<TypeOf<T>>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-    this.transform = this.transform.bind(this) as any;
+    this.parse = this.parse.bind(this);
+    this.safeParse = this.safeParse.bind(this);
+    this.parseAsync = this.parseAsync.bind(this);
+    this.safeParseAsync = this.safeParseAsync.bind(this);
+    this.spa = this.spa.bind(this);
+    this.refine = this.refine.bind(this);
+    this.refinement = this.refinement.bind(this);
+    this.superRefine = this.superRefine.bind(this);
+    this.optional = this.optional.bind(this);
+    this.nullable = this.nullable.bind(this);
+    this.nullish = this.nullish.bind(this);
+    this.array = this.array.bind(this);
+    this.promise = this.promise.bind(this);
+    this.or = this.or.bind(this);
+    this.and = this.and.bind(this);
+    this.transform = this.transform.bind(this);
+    this.describe = this.describe.bind(this);
+    this.isOptional = this.isOptional.bind(this);
+    this.isNullable = this.isNullable.bind(this);
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-      ...processCreateParams(params),
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  // type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  type requiredKeys<T extends object> = {
+    [k in keyof T]: undefined extends T[k] ? never : k;
+  }[keyof T];
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
-    const extraKeys = dataKeys.filter((k) => !(k in shape));
+    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
-    const mergedShape = objectUtil.mergeShapes(
-      this._def.shape(),
-      merging._def.shape()
-    );
+    // const mergedShape = objectUtil.mergeShapes(
+    //   this._def.shape(),
+    //   merging._def.shape()
+    // );
-      shape: () => mergedShape,
+      shape: () =>
+        objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,
+  nanType as nan,","-  Record<Key[""_output""], Value[""_output""]>,
+  Partial<Record<Key[""_output""], Value[""_output""]>>,
-  Record<Key[""_input""], Value[""_input""]>
+  Partial<Record<Key[""_input""], Value[""_input""]>>","+import { Primitive } from ""./helpers/typeAliases"";
-export type { TypeOf as infer };
+
+type allKeys<T> = T extends any ? keyof T : never;
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in allKeys<TypeOf<T>>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-    this.transform = this.transform.bind(this) as any;
+    this.parse = this.parse.bind(this);
+    this.safeParse = this.safeParse.bind(this);
+    this.parseAsync = this.parseAsync.bind(this);
+    this.safeParseAsync = this.safeParseAsync.bind(this);
+    this.spa = this.spa.bind(this);
+    this.refine = this.refine.bind(this);
+    this.refinement = this.refinement.bind(this);
+    this.superRefine = this.superRefine.bind(this);
+    this.optional = this.optional.bind(this);
+    this.nullable = this.nullable.bind(this);
+    this.nullish = this.nullish.bind(this);
+    this.array = this.array.bind(this);
+    this.promise = this.promise.bind(this);
+    this.or = this.or.bind(this);
+    this.and = this.and.bind(this);
+    this.transform = this.transform.bind(this);
+    this.describe = this.describe.bind(this);
+    this.isOptional = this.isOptional.bind(this);
+    this.isNullable = this.isNullable.bind(this);
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-      ...processCreateParams(params),
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  // type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  type requiredKeys<T extends object> = {
+    [k in keyof T]: undefined extends T[k] ? never : k;
+  }[keyof T];
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
-    const extraKeys = dataKeys.filter((k) => !(k in shape));
+    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));
-    const mergedShape = objectUtil.mergeShapes(
-      this._def.shape(),
-      merging._def.shape()
-    );
+    // const mergedShape = objectUtil.mergeShapes(
+    //   this._def.shape(),
+    //   merging._def.shape()
+    // );
-      shape: () => mergedShape,
+      shape: () =>
+        objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
-  Record<Key[""_output""], Value[""_output""]>,
+  Partial<Record<Key[""_output""], Value[""_output""]>>,
-  Record<Key[""_input""], Value[""_input""]>
+  Partial<Record<Key[""_input""], Value[""_input""]>>
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,
+  nanType as nan,"
colinhacks_zod,beec3bf2fd5317767a75eaec7f1e1bf64cf2c11b,Merge branch 'master' into nan-type,deno/lib/types.ts,"+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+  nanType as nan,","+import { Primitive } from ""./helpers/typeAliases.ts"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","+import { Primitive } from ""./helpers/typeAliases.ts"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,
+  nanType as nan,"
colinhacks_zod,beec3bf2fd5317767a75eaec7f1e1bf64cf2c11b,Merge branch 'master' into nan-type,src/types.ts,"+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+  nanType as nan,","+import { Primitive } from ""./helpers/typeAliases"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","+import { Primitive } from ""./helpers/typeAliases"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+export type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+/////////////////////////////////////////
+/////////////////////////////////////////
+//////////                     //////////
+//////////      ZodNaN         //////////
+//////////                     //////////
+/////////////////////////////////////////
+/////////////////////////////////////////
+
+export interface ZodNaNDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNaN;
+}
+
+export class ZodNaN extends ZodType<number, ZodNaNDef> {
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.nan) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.nan,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    return { status: status.value, value: ctx.data };
+  }
+
+  static create = (params?: RawCreateParams): ZodNaN => {
+    return new ZodNaN({
+      typeName: ZodFirstPartyTypeKind.ZodNaN,
+      ...processCreateParams(params),
+    });
+  };
+}
+
+  ZodNaN = ""ZodNaN"",
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+  | ZodNaN
+const nanType = ZodNaN.create;
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,
+  nanType as nan,"
colinhacks_zod,a8241deb69a4a18d46ccec3eee9f4f22548cebdc,Merge pull request #906 from shroudedcode/add-exports-types  Add `types` field to `exports` in `package.json`,package.json,"-  ""version"": ""3.11.6"",
+  ""version"": ""3.12.0"",","-      ""import"": ""./lib/index.mjs""
+      ""import"": ""./lib/index.mjs"",
+      ""types"": ""./lib/index.d.ts""","-  ""version"": ""3.11.6"",
+  ""version"": ""3.12.0"",
-      ""import"": ""./lib/index.mjs""
+      ""import"": ""./lib/index.mjs"",
+      ""types"": ""./lib/index.d.ts"""
colinhacks_zod,c63a5988613f0accb2099d88f05db4201618ad6e,Merge pull request #766 from equt/remove-duplicated-raw-params-process  Remove duplicated `processCreateParams` in `ZodNumber`,deno/lib/types.ts,"+import { Primitive } from ""./helpers/typeAliases.ts"";
-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","-      ...processCreateParams(params),","+import { Primitive } from ""./helpers/typeAliases.ts"";
-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,"
colinhacks_zod,c63a5988613f0accb2099d88f05db4201618ad6e,Merge pull request #766 from equt/remove-duplicated-raw-params-process  Remove duplicated `processCreateParams` in `ZodNumber`,src/types.ts,"+import { Primitive } from ""./helpers/typeAliases"";
-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","-      ...processCreateParams(params),","+import { Primitive } from ""./helpers/typeAliases"";
-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-      ...processCreateParams(params),
-
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+}
+
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,"
colinhacks_zod,abbf3254f51fc3faa309e025476bc3f0912d4e74,Merge pull request #899 from alexxander/discriminated-union,deno/lib/types.ts,"-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;","+import { Primitive } from ""./helpers/typeAliases.ts"";
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","+import { Primitive } from ""./helpers/typeAliases.ts"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,"
colinhacks_zod,abbf3254f51fc3faa309e025476bc3f0912d4e74,Merge pull request #899 from alexxander/discriminated-union,src/types.ts,"-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;","+import { Primitive } from ""./helpers/typeAliases"";
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,","+import { Primitive } from ""./helpers/typeAliases"";
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+//////////                                 //////////
+//////////      ZodDiscriminatedUnion      //////////
+//////////                                 //////////
+/////////////////////////////////////////////////////
+/////////////////////////////////////////////////////
+
+type ZodDiscriminatedUnionOption<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive
+> = ZodObject<
+  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
+  any,
+  any
+>;
+
+export interface ZodDiscriminatedUnionDef<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodTypeDef {
+  discriminator: Discriminator;
+  options: Map<DiscriminatorValue, Option>;
+  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
+}
+
+export class ZodDiscriminatedUnion<
+  Discriminator extends string,
+  DiscriminatorValue extends Primitive,
+  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
+> extends ZodType<
+  Option[""_output""],
+  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
+  Option[""_input""]
+> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
+      return INVALID;
+    }
+
+    const discriminator = this.discriminator;
+    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
+    const option = this.options.get(discriminatorValue);
+
+    if (!option) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union_discriminator,
+        options: this.validDiscriminatorValues,
+        path: [discriminator],
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return option._parseAsync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    } else {
+      return option._parseSync({
+        data: ctx.data,
+        path: ctx.path,
+        parent: ctx,
+      });
+    }
+  }
+
+  get discriminator() {
+    return this._def.discriminator;
+  }
+
+  get validDiscriminatorValues() {
+    return Array.from(this.options.keys());
+  }
+
+  get options() {
+    return this._def.options;
+  }
+
+  /**
+   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
+   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
+   * have a different value for each object in the union.
+   * @param discriminator the name of the discriminator property
+   * @param types an array of object schemas
+   * @param params
+   */
+  static create<
+    Discriminator extends string,
+    DiscriminatorValue extends Primitive,
+    Types extends [
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
+      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
+    ]
+  >(
+    discriminator: Discriminator,
+    types: Types,
+    params?: RawCreateParams
+  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
+    // Get all the valid discriminator values
+    const options: Map<DiscriminatorValue, Types[number]> = new Map();
+
+    try {
+      types.forEach((type) => {
+        const discriminatorValue = type.shape[discriminator].value;
+        options.set(discriminatorValue, type);
+      });
+    } catch (e) {
+      throw new Error(
+        ""The discriminator value could not be extracted from all the provided schemas""
+      );
+    }
+
+    // Assert that all the discriminator values are unique
+    if (options.size !== types.length) {
+      throw new Error(""Some of the discriminator values are not unique"");
+    }
+
+    return new ZodDiscriminatedUnion<
+      Discriminator,
+      DiscriminatorValue,
+      Types[number]
+    >({
+      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
+      discriminator,
+      options,
+      ...processCreateParams(params),
+    });
+  }
+}
+
+  ZodDiscriminatedUnion = ""ZodDiscriminatedUnion"",
+const discriminatedUnionType = ZodDiscriminatedUnion.create;
+  discriminatedUnionType as discriminatedUnion,"
colinhacks_zod,d95d34af4ad44970b692b7e0a4cfcebc4a465066,Merge branch 'colinhacks:master' into master,deno/lib/types.ts,"-  _processInputParams(
-    input: ParseInput
-  ): {
+  _processInputParams(input: ParseInput): {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex =
+  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-const emailRegex = /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+const emailRegex =
+  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
-  } &
-    V;
+  } & V;
-  } &
-    { [k in requiredKeys<T>]: T[k] };
+  } & { [k in requiredKeys<T>]: T[k] };
-  export type noNever<T extends ZodRawShape> = identity<
-    {
-      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
+  export type noNever<T extends ZodRawShape> = identity<{
+    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+  }>;
-} &
-  { [k in keyof B]: B[k] };
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
-  Def[""unknownKeys""],
-  Def[""catchall""]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
+} & { [k in keyof B]: B[k] };
+
+const AugmentFactory =
+  <Def extends ZodObjectDef>(def: Def) =>
+  <Augmentation extends ZodRawShape>(
+    augmentation: Augmentation
+  ): ZodObject<
+    extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+    Def[""unknownKeys""],
+    Def[""catchall""]
+  > => {
+    return new ZodObject({
+      ...def,
+      shape: () => ({
+        ...def.shape(),
+        ...augmentation,
+      }),
+    }) as any;
+  };
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
+export type baseObjectOutputType<Shape extends ZodRawShape> =
+  objectUtil.flatten<
+    objectUtil.addQuestionMarks<{
-    }
-  >
->;
+    }>
+  >;
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k][""_input""];
-    }
-  >
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k][""_input""];
+  }>
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
-      }
-    >,
+    objectUtil.noNever<{
+      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+    }>,
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-  }
->;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+}>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-  }
->;
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+}>;
-        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        if (!schema) return null as any as SyncParseReturnType<any>;
-        const parsedReturns = await (this._def
-          .returns as ZodPromise<ZodTypeAny>)._def.type
+        const parsedReturns = await (
+          this._def.returns as ZodPromise<ZodTypeAny>
+        )._def.type","-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};","-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  _processInputParams(
-    input: ParseInput
-  ): {
+  _processInputParams(input: ParseInput): {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex =
+  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-const emailRegex = /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+const emailRegex =
+  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
-  } &
-    V;
+  } & V;
-  } &
-    { [k in requiredKeys<T>]: T[k] };
+  } & { [k in requiredKeys<T>]: T[k] };
-  export type noNever<T extends ZodRawShape> = identity<
-    {
-      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
+  export type noNever<T extends ZodRawShape> = identity<{
+    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+  }>;
-} &
-  { [k in keyof B]: B[k] };
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
-  Def[""unknownKeys""],
-  Def[""catchall""]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
+} & { [k in keyof B]: B[k] };
+
+const AugmentFactory =
+  <Def extends ZodObjectDef>(def: Def) =>
+  <Augmentation extends ZodRawShape>(
+    augmentation: Augmentation
+  ): ZodObject<
+    extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+    Def[""unknownKeys""],
+    Def[""catchall""]
+  > => {
+    return new ZodObject({
+      ...def,
+      shape: () => ({
+        ...def.shape(),
+        ...augmentation,
+      }),
+    }) as any;
+  };
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
+export type baseObjectOutputType<Shape extends ZodRawShape> =
+  objectUtil.flatten<
+    objectUtil.addQuestionMarks<{
-    }
-  >
->;
+    }>
+  >;
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k][""_input""];
-    }
-  >
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k][""_input""];
+  }>
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
-      }
-    >,
+    objectUtil.noNever<{
+      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+    }>,
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-  }
->;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+}>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-  }
->;
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+}>;
-        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        if (!schema) return null as any as SyncParseReturnType<any>;
-        const parsedReturns = await (this._def
-          .returns as ZodPromise<ZodTypeAny>)._def.type
+        const parsedReturns = await (
+          this._def.returns as ZodPromise<ZodTypeAny>
+        )._def.type"
colinhacks_zod,d95d34af4ad44970b692b7e0a4cfcebc4a465066,Merge branch 'colinhacks:master' into master,src/types.ts,"-  _processInputParams(
-    input: ParseInput
-  ): {
+  _processInputParams(input: ParseInput): {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex =
+  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-const emailRegex = /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+const emailRegex =
+  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
-  } &
-    V;
+  } & V;
-  } &
-    { [k in requiredKeys<T>]: T[k] };
+  } & { [k in requiredKeys<T>]: T[k] };
-  export type noNever<T extends ZodRawShape> = identity<
-    {
-      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
+  export type noNever<T extends ZodRawShape> = identity<{
+    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+  }>;
-} &
-  { [k in keyof B]: B[k] };
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
-  Def[""unknownKeys""],
-  Def[""catchall""]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
+} & { [k in keyof B]: B[k] };
+
+const AugmentFactory =
+  <Def extends ZodObjectDef>(def: Def) =>
+  <Augmentation extends ZodRawShape>(
+    augmentation: Augmentation
+  ): ZodObject<
+    extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+    Def[""unknownKeys""],
+    Def[""catchall""]
+  > => {
+    return new ZodObject({
+      ...def,
+      shape: () => ({
+        ...def.shape(),
+        ...augmentation,
+      }),
+    }) as any;
+  };
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
+export type baseObjectOutputType<Shape extends ZodRawShape> =
+  objectUtil.flatten<
+    objectUtil.addQuestionMarks<{
-    }
-  >
->;
+    }>
+  >;
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k][""_input""];
-    }
-  >
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k][""_input""];
+  }>
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
-      }
-    >,
+    objectUtil.noNever<{
+      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+    }>,
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-  }
->;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+}>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-  }
->;
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+}>;
-        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        if (!schema) return null as any as SyncParseReturnType<any>;
-        const parsedReturns = await (this._def
-          .returns as ZodPromise<ZodTypeAny>)._def.type
+        const parsedReturns = await (
+          this._def.returns as ZodPromise<ZodTypeAny>
+        )._def.type","-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};","-export type { TypeOf as infer };
+export type TypeOfFlattenedError<
+  T extends ZodType<any, any, any>,
+  U = string
+> = {
+  formErrors: U[];
+  fieldErrors: {
+    [P in keyof TypeOf<T>]?: U[];
+  };
+};
+export type TypeOfFormErrors<
+  T extends ZodType<any, any, any>
+> = TypeOfFlattenedError<T>;
+export type {
+  TypeOf as infer,
+  TypeOfFlattenedError as inferFlattenedErrors,
+  TypeOfFormErrors as inferFormErrors,
+};
-  _processInputParams(
-    input: ParseInput
-  ): {
+  _processInputParams(input: ParseInput): {
-const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
+const uuidRegex =
+  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-const emailRegex = /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
+const emailRegex =
+  /^(([^<>()[\]\.,;:\s@\""]+(\.[^<>()[\]\.,;:\s@\""]+)*)|(\"".+\""))@(([^<>()[\]\.,;:\s@\""]+\.)+[^<>()[\]\.,;:\s@\""]{2,})$/i;
-  } &
-    V;
+  } & V;
-  } &
-    { [k in requiredKeys<T>]: T[k] };
+  } & { [k in requiredKeys<T>]: T[k] };
-  export type noNever<T extends ZodRawShape> = identity<
-    {
-      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    }
-  >;
+  export type noNever<T extends ZodRawShape> = identity<{
+    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
+  }>;
-} &
-  { [k in keyof B]: B[k] };
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
-  Augmentation extends ZodRawShape
->(
-  augmentation: Augmentation
-): ZodObject<
-  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
-  Def[""unknownKeys""],
-  Def[""catchall""]
-> => {
-  return new ZodObject({
-    ...def,
-    shape: () => ({
-      ...def.shape(),
-      ...augmentation,
-    }),
-  }) as any;
-};
+} & { [k in keyof B]: B[k] };
+
+const AugmentFactory =
+  <Def extends ZodObjectDef>(def: Def) =>
+  <Augmentation extends ZodRawShape>(
+    augmentation: Augmentation
+  ): ZodObject<
+    extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+    Def[""unknownKeys""],
+    Def[""catchall""]
+  > => {
+    return new ZodObject({
+      ...def,
+      shape: () => ({
+        ...def.shape(),
+        ...augmentation,
+      }),
+    }) as any;
+  };
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
-  objectUtil.addQuestionMarks<
-    {
+export type baseObjectOutputType<Shape extends ZodRawShape> =
+  objectUtil.flatten<
+    objectUtil.addQuestionMarks<{
-    }
-  >
->;
+    }>
+  >;
-  objectUtil.addQuestionMarks<
-    {
-      [k in keyof Shape]: Shape[k][""_input""];
-    }
-  >
+  objectUtil.addQuestionMarks<{
+    [k in keyof Shape]: Shape[k][""_input""];
+  }>
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
-      }
-    >,
+    objectUtil.noNever<{
+      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+    }>,
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-  }
->;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+}>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
-  {
-    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-  }
->;
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
+  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+}>;
-        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        if (!schema) return null as any as SyncParseReturnType<any>;
-        const parsedReturns = await (this._def
-          .returns as ZodPromise<ZodTypeAny>)._def.type
+        const parsedReturns = await (
+          this._def.returns as ZodPromise<ZodTypeAny>
+        )._def.type"
colinhacks_zod,5c0d9598fb168f7cb5bc935270b94149b2161133,Merge pull request #773 from dirgapeter/fix/intersection-with-date  fix: intersection with date fields,deno/lib/types.ts,"-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };","+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };"
colinhacks_zod,5c0d9598fb168f7cb5bc935270b94149b2161133,Merge pull request #773 from dirgapeter/fix/intersection-with-date  fix: intersection with date fields,src/types.ts,"-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };","+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };"
colinhacks_zod,9c6e487fa1e5fb22d7c6bbdf0cca8be77e43a9fd,Merge pull request #767 from equt/wait-so-description-is-really-missed  fix: Add `description` to `ProcessedCreateParams`,deno/lib/types.ts,"-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,9c6e487fa1e5fb22d7c6bbdf0cca8be77e43a9fd,Merge pull request #767 from equt/wait-so-description-is-really-missed  fix: Add `description` to `ProcessedCreateParams`,src/types.ts,"-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };","-  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+  const { errorMap, invalid_type_error, required_error, description } = params;
+  if (errorMap && (invalid_type_error || required_error)) {
-  if (params.errorMap) return { errorMap: params.errorMap };
+  if (errorMap) return { errorMap: errorMap, description };
-    if (typeof ctx.data === ""undefined"" && params.required_error)
-      return { message: params.required_error };
+    if (typeof ctx.data === ""undefined"" && required_error)
+      return { message: required_error };
-  return { errorMap: customMap };
+  return { errorMap: customMap, description };
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,78480fc71ca542f889d921fe29e71c15ae760528,Merge branch 'master' into fix/intersection-with-date,deno/lib/types.ts,"+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,78480fc71ca542f889d921fe29e71c15ae760528,Merge branch 'master' into fix/intersection-with-date,src/types.ts,"+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  } else if (
+    aType === ZodParsedType.date &&
+    bType === ZodParsedType.date &&
+    +a === +b
+  ) {
+    return { valid: true, data: a };
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,69ff844b869d7f0c396c7083f3c09ab9765be19e,Merge branch 'error-msgs',deno/lib/ZodError.ts,"-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;","-        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
-          issue.minimum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
-          issue.minimum
-        } characters`;
+        message = `String must contain ${
+          issue.inclusive ? `at least ${issue.minimum}` : `over`
+        } ${issue.minimum} character(s)`;
-        message = `Value should be greater than ${
+        message = `Number must be greater than ${
-        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
-          issue.maximum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
-          issue.maximum
-        } characters long`;
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
-        message = `Value should be less than ${
+        message = `Number must be less than ${
-      message = `Should be multiple of ${issue.multipleOf}`;
+      message = `Number must be a multiple of ${issue.multipleOf}`;","-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;
-        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
-          issue.minimum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
-          issue.minimum
-        } characters`;
+        message = `String must contain ${
+          issue.inclusive ? `at least ${issue.minimum}` : `over`
+        } ${issue.minimum} character(s)`;
-        message = `Value should be greater than ${
+        message = `Number must be greater than ${
-        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
-          issue.maximum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
-          issue.maximum
-        } characters long`;
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
-        message = `Value should be less than ${
+        message = `Number must be less than ${
-      message = `Should be multiple of ${issue.multipleOf}`;
+      message = `Number must be a multiple of ${issue.multipleOf}`;"
colinhacks_zod,69ff844b869d7f0c396c7083f3c09ab9765be19e,Merge branch 'error-msgs',src/ZodError.ts,"-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;","-        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
-          issue.minimum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
-          issue.minimum
-        } characters`;
+        message = `String must contain ${
+          issue.inclusive ? `at least ${issue.minimum}` : `over`
+        } ${issue.minimum} character(s)`;
-        message = `Value should be greater than ${
+        message = `Number must be greater than ${
-        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
-          issue.maximum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
-          issue.maximum
-        } characters long`;
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
-        message = `Value should be less than ${
+        message = `Number must be less than ${
-      message = `Should be multiple of ${issue.multipleOf}`;
+      message = `Number must be a multiple of ${issue.multipleOf}`;","-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;
-        message = `Should have ${issue.inclusive ? `at least` : `more than`} ${
-          issue.minimum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at least` : `more than`
+        } ${issue.minimum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at least` : `over`} ${
-          issue.minimum
-        } characters`;
+        message = `String must contain ${
+          issue.inclusive ? `at least ${issue.minimum}` : `over`
+        } ${issue.minimum} character(s)`;
-        message = `Value should be greater than ${
+        message = `Number must be greater than ${
-        message = `Should have ${issue.inclusive ? `at most` : `less than`} ${
-          issue.maximum
-        } items`;
+        message = `Array must contain ${
+          issue.inclusive ? `at most` : `less than`
+        } ${issue.maximum} item(s)`;
-        message = `Should be ${issue.inclusive ? `at most` : `under`} ${
-          issue.maximum
-        } characters long`;
+        message = `String must contain ${
+          issue.inclusive ? `at most` : `under`
+        } ${issue.maximum} character(s)`;
-        message = `Value should be less than ${
+        message = `Number must be less than ${
-      message = `Should be multiple of ${issue.multipleOf}`;
+      message = `Number must be a multiple of ${issue.multipleOf}`;"
colinhacks_zod,a118887534920865e48768ea391cb5778b21b3bf,Merge pull request #777 from pasieronen/no-enum-value-in-error  Don't include received value in enum/literal error messages (fixes #461),deno/lib/ZodError.ts,"-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";","-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;","-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;"
colinhacks_zod,a118887534920865e48768ea391cb5778b21b3bf,Merge pull request #777 from pasieronen/no-enum-value-in-error  Don't include received value in enum/literal error messages (fixes #461),deno/lib/types.ts,"-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,a118887534920865e48768ea391cb5778b21b3bf,Merge pull request #777 from pasieronen/no-enum-value-in-error  Don't include received value in enum/literal error messages (fixes #461),src/ZodError.ts,"-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";","-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;","-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-  type: ""array"" | ""string"" | ""number"";
+  type: ""array"" | ""string"" | ""number"" | ""set"";
-        .join("" | "")}, received ${
-        typeof _ctx.data === ""string"" ? `'${_ctx.data}'` : _ctx.data
-      }`;
+        .join("" | "")}`;"
colinhacks_zod,a118887534920865e48768ea391cb5778b21b3bf,Merge pull request #777 from pasieronen/no-enum-value-in-error  Don't include received value in enum/literal error messages (fixes #461),src/types.ts,"-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,
-        expected: this._def.value as any,
-        received: ctx.data,
+        expected: getParsedType(this._def.value),
+        received: ctx.parsedType,"
colinhacks_zod,9ef076d0cbf0b2b2991de63e5a696937e841c7f9,Merge changes,deno/lib/types.ts,"+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(","-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,"
colinhacks_zod,9ef076d0cbf0b2b2991de63e5a696937e841c7f9,Merge changes,src/types.ts,"+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-  T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(","-  T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","+// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
+function floatSafeRemainder(val: number, step: number) {
+  const valDecCount = (val.toString().split(""."")[1] || """").length;
+  const stepDecCount = (step.toString().split(""."")[1] || """").length;
+  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
+  const valInt = parseInt(val.toFixed(decCount).replace(""."", """"));
+  const stepInt = parseInt(step.toFixed(decCount).replace(""."", """"));
+  return (valInt % stepInt) / Math.pow(10, decCount);
+}
+
-        if (ctx.data % check.value !== 0) {
+        if (floatSafeRemainder(ctx.data, check.value) !== 0) {
-  T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,"
colinhacks_zod,21c7b1f4e27390034282cabe2e835f41af289b41,Merge branch 'master' into master,deno/lib/types.ts,"+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,"
colinhacks_zod,21c7b1f4e27390034282cabe2e835f41af289b41,Merge branch 'master' into master,src/types.ts,"+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<
+    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  >
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <
+    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
+  >(
+  minSize: { value: number; message?: string } | null;
+  maxSize: { value: number; message?: string } | null;
+    const def = this._def;
+
+    if (def.minSize !== null) {
+      if (ctx.data.size < def.minSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.minSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+    if (def.maxSize !== null) {
+      if (ctx.data.size > def.maxSize.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxSize.value,
+          type: ""set"",
+          inclusive: true,
+          message: def.maxSize.message,
+        });
+        status.dirty();
+      }
+    }
+
+  min(minSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      minSize: { value: minSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  max(maxSize: number, message?: errorUtil.ErrMessage): this {
+    return new ZodSet({
+      ...this._def,
+      maxSize: { value: maxSize, message: errorUtil.toString(message) },
+    }) as any;
+  }
+
+  size(size: number, message?: errorUtil.ErrMessage): this {
+    return this.min(size, message).max(size, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
+    return this.min(1, message) as any;
+  }
+
+      minSize: null,
+      maxSize: null,"
colinhacks_zod,625c28e25a59301bba965678c307ca27254fc897,Merge pull request #832 from cefn/readonly-union-options  Add Readonly to ZodUnionOptions,src/types.ts,"-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {","-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(","-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      typeCache: new Map(),
+      typeCache: typeof Map !== ""undefined"" ? new Map() : undefined,
-      if (result instanceof Promise) {
+      if (typeof Promise !== ""undefined"" && result instanceof Promise) {
-type ZodUnionOptions = [ZodTypeAny, ...ZodTypeAny[]];
+type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
-  T extends ZodUnionOptions = [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
+  T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
-  static create = <T extends [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(
+  static create = <T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>("
colinhacks_zod,fdd708493e4422dba6453908af55ef0d58767c03,Merge pull request #727 from DenisFrezzato/improve-refinement-type  Improve refine with type guards,deno/lib/types.ts,"+  description?: string;
+      description?: string;
-type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
+export type SafeParseSuccess<Output> = { success: true; data: Output };
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> };
+
+export type SafeParseReturnType<Input, Output> =
+  | SafeParseSuccess<Output>
+  | SafeParseError<Input>;
+
+
+  get description() {
+    return this._def.description;
+  }
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {
+  }
+
+  describe(description: string): this {
+    const This = (this as any).constructor;
+    return new This({
+      ...this._def,
+      description,
+    });","-  refine<Func extends (arg: Output) => any>(
-    check: Func,
+  refine<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
+  refine(
+    check: (arg: Output) => unknown | Promise<unknown>,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, Output, Input>;
+  refine(
+    check: (arg: Output) => unknown,
+  refinement<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
-    check: (arg: Output) => any,
+    check: (arg: Output) => boolean,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, Output, Input>;
+  refinement(
+    check: (arg: Output) => unknown,
-    }) as any;
+    });","+  description?: string;
+      description?: string;
-type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
+export type SafeParseSuccess<Output> = { success: true; data: Output };
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> };
+
+export type SafeParseReturnType<Input, Output> =
+  | SafeParseSuccess<Output>
+  | SafeParseError<Input>;
+
+
+  get description() {
+    return this._def.description;
+  }
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {
-  refine<Func extends (arg: Output) => any>(
-    check: Func,
+  refine<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
+  refine(
+    check: (arg: Output) => unknown | Promise<unknown>,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, Output, Input>;
+  refine(
+    check: (arg: Output) => unknown,
+  refinement<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
-    check: (arg: Output) => any,
+    check: (arg: Output) => boolean,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, Output, Input>;
+  refinement(
+    check: (arg: Output) => unknown,
-    }) as any;
+    });
+  }
+
+  describe(description: string): this {
+    const This = (this as any).constructor;
+    return new This({
+      ...this._def,
+      description,
+    });"
colinhacks_zod,fdd708493e4422dba6453908af55ef0d58767c03,Merge pull request #727 from DenisFrezzato/improve-refinement-type  Improve refine with type guards,src/types.ts,"+  description?: string;
+      description?: string;
-type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
+export type SafeParseSuccess<Output> = { success: true; data: Output };
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> };
+
+export type SafeParseReturnType<Input, Output> =
+  | SafeParseSuccess<Output>
+  | SafeParseError<Input>;
+
+
+  get description() {
+    return this._def.description;
+  }
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {
+  }
+
+  describe(description: string): this {
+    const This = (this as any).constructor;
+    return new This({
+      ...this._def,
+      description,
+    });","-  refine<Func extends (arg: Output) => any>(
-    check: Func,
+  refine<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
+  refine(
+    check: (arg: Output) => unknown | Promise<unknown>,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, Output, Input>;
+  refine(
+    check: (arg: Output) => unknown,
+  refinement<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
-    check: (arg: Output) => any,
+    check: (arg: Output) => boolean,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, Output, Input>;
+  refinement(
+    check: (arg: Output) => unknown,
-    }) as any;
+    });","+  description?: string;
+      description?: string;
-type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
+export type SafeParseSuccess<Output> = { success: true; data: Output };
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> };
+
+export type SafeParseReturnType<Input, Output> =
+  | SafeParseSuccess<Output>
+  | SafeParseError<Input>;
+
+
+  get description() {
+    return this._def.description;
+  }
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {
-  refine<Func extends (arg: Output) => any>(
-    check: Func,
+  refine<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
+  refine(
+    check: (arg: Output) => unknown | Promise<unknown>,
+    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
+  ): ZodEffects<this, Output, Input>;
+  refine(
+    check: (arg: Output) => unknown,
+  refinement<RefinedOutput extends Output>(
+    check: (arg: Output) => arg is RefinedOutput,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
-    check: (arg: Output) => any,
+    check: (arg: Output) => boolean,
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this, Output, Input>;
+  refinement(
+    check: (arg: Output) => unknown,
-    }) as any;
+    });
+  }
+
+  describe(description: string): this {
+    const This = (this as any).constructor;
+    return new This({
+      ...this._def,
+      description,
+    });"
colinhacks_zod,5264ab6e8a53ee8c2c7598750fe544bc4245d845,FMC,src/types.ts,"-    { success: true; data: Output } | { success: false; error: ZodError }
+    { success: true; data: Output } | { success: false; error: ZodError<Input> }","+export type SafeParseSuccess<Output> = { success: true; data: Output }
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> } 
+
+export type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output>
+| SafeParseError<Input>
+
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {","+export type SafeParseSuccess<Output> = { success: true; data: Output };
+export type SafeParseError<Input> = { success: false; error: ZodError<Input> };
+
+export type SafeParseReturnType<Input, Output> =
+  | SafeParseSuccess<Output>
+  | SafeParseError<Input>;
+
-  ):
-    | { success: true; data: Output }
-    | { success: false; error: ZodError<Input> } {
+  ): SafeParseReturnType<Input, Output> {
-  ): Promise<
-    { success: true; data: Output } | { success: false; error: ZodError }
-  > {
+  ): Promise<SafeParseReturnType<Input, Output>> {"
colinhacks_zod,67c8ad07273dc11c2cb71a179dab32fb354212ed,Remove console.logs,deno/lib/types.ts,"+
+
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };","+
+    console.log(pairs);
+          console.log(`syncparis`);
+          console.log(JSON.stringify(syncPairs, null, 2));
+          console.log(`syncparis`);
+          console.log(JSON.stringify(syncPairs, null, 2));
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+        console.log(`BASE`);
+        console.log(inner);
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };
+      console.log(`settings default value: ${data}`);","+
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };"
colinhacks_zod,67c8ad07273dc11c2cb71a179dab32fb354212ed,Remove console.logs,src/types.ts,"+
+
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };","+
+    console.log(pairs);
+          console.log(`syncparis`);
+          console.log(JSON.stringify(syncPairs, null, 2));
+          console.log(`syncparis`);
+          console.log(JSON.stringify(syncPairs, null, 2));
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+        console.log(`BASE`);
+        console.log(inner);
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };
+      console.log(`settings default value: ${data}`);","+
-        const base = this._def.schema._parseSync({
+        const inner = this._def.schema._parseSync({
-        if (base.status === ""aborted"") return INVALID;
-        if (base.status === ""dirty"") status.dirty();
+        if (inner.status === ""aborted"") return INVALID;
+        if (inner.status === ""dirty"") status.dirty();
-        executeRefinement(base.value);
-        return { status: status.value, value: ctx.data };
+        executeRefinement(inner.value);
+        return { status: status.value, value: inner.value };
-          .then((result) => {
-            if (result.status === ""aborted"") return INVALID;
-            if (result.status === ""dirty"") status.dirty();
-
-            return executeRefinement(result.value).then(() => {
-              return { status: status.value, value: ctx.data };
+          .then((inner) => {
+            if (inner.status === ""aborted"") return INVALID;
+            if (inner.status === ""dirty"") status.dirty();
+
+            return executeRefinement(inner.value).then(() => {
+              return { status: status.value, value: inner.value };"
colinhacks_zod,fe5bbf61a14187a9149ba58f2965f4a52952e196,Merge branch 'ej/strictError' of git://github.com/ejose19/zod into ejose19-ej/strictError,deno/lib/__tests__/error.test.ts,"+test(""custom path"", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: ""qwer"",
+    confirm: ""asdf"",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);","+});
+
+test(""strict error message"", () => {
+  const errorMsg = ""Invalid object"";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: ""a"", y: ""b"" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }","+test(""custom path"", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: ""qwer"",
+    confirm: ""asdf"",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);
+});
+
+test(""strict error message"", () => {
+  const errorMsg = ""Invalid object"";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: ""a"", y: ""b"" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }"
colinhacks_zod,fe5bbf61a14187a9149ba58f2965f4a52952e196,Merge branch 'ej/strictError' of git://github.com/ejose19/zod into ejose19-ej/strictError,deno/lib/types.ts,"+import { FATAL_CODES } from ""./index.ts"";
+  addIssueToContext,
+  isAborted,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
+  defaultErrorMap,
+  overrideErrorMap,
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === ""string"") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
+    if (!ctx.issues.length) {
+      throw new Error(""Validation failed but no issues detected."");
+    }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
-
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
-  }
-
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
+
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
+  }
+
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
-    let invalid = false;
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""email"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""uuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""cuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-          new URL(data);
+          new URL(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""url"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        // clear regex state
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""regex"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: ""integer"",
-              received: ""float"",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+          status.dirty();
-        // const MIN = check.value;
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
-
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
-    const data: any[] = _data;
-
-    let invalid = false;
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
-    });
-
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
+
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
+    });
+
+    return ParseStatus.mergeArray(status, result);
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
+    return this.min(1, message) as any;
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-}
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
+}
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def[""shape""]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def[""shape""]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== ""undefined"" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: ""valid"", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: ""valid"", value: key },
+            value: { status: ""valid"", value: ctx.data[key] },
+          });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: ""valid"", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-      // effects: [], // wipe all refinements
-      // const newShape: any = {};
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number][""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== ""invalid_type"";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
-      }
-      return INVALID;
-    };
-
-    if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
-      return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
-    } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      console.log(JSON.stringify(results, null, 2));
+      for (const result of results) {
+        console.log(`######\nresult`);
+        console.log(result.result);
+        if (result.result.status === ""valid"") {
+          console.log(`found clean option`);
+          return result.result;
-      return noMatch(allIssues);
+      for (const result of results) {
+        if (result.result.status === ""dirty"") {
+          // add issues from dirty option
+          console.log(`found dirty option`);
+          // console.log(result.result);
+          console.log(result);
+          console.log(result.ctx.issues);
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
+      }
+
+      console.log(`no clean options`);
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return Promise.all(
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
+    } else {
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
+
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
+      });
+
+      return INVALID;
+    }
+
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
-
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
-    }
+      status.dirty();
+    }
+
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
-
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
+
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, ""key""],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, ""value""],
+            parent: ctx,
+          }),
+        };
-    };
-
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto(""key""),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto(""value""),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    );
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === ""aborted"" || value.status === ""aborted"") {
+            return INVALID;
+          }
+          if (key.status === ""dirty"" || value.status === ""dirty"") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === ""aborted"" || value.status === ""aborted"") {
+          return INVALID;
+        }
+        if (key.status === ""dirty"" || value.status === ""dirty"") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
-    const dataSet: Set<unknown> = data;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === ""aborted"") return INVALID;
+        if (element.status === ""dirty"") status.dirty();
+        parsedSet.add(element.value);
-    };
-
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      return { status: status.value, value: parsedSet };
+    }
+
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
-      });
+      }) as any;
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
-    return OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
-    return OK(data);
-  }
+    return OK(ctx.data);
+  }
+
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T[""_output""]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result).then(() => acc);
+        }
-          if (isSync) {
-            throw new Error(
-              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (base.status === ""aborted"") return INVALID;
+
+        // return value is ignored
+        executeRefinement(base.value, effect);
+        return { status: status.value, value: ctx.data };
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (result.status === ""aborted"") return INVALID;
+
+            return executeRefinement(result.value, effect).then(() => {
+              return { status: status.value, value: ctx.data };
+            });
+          });
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === ""aborted"") return INVALID;
+        // if (base.status === ""dirty"") {
+        //   return { status: ""dirty"", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === ""aborted"") return INVALID;
+            // if (base.status === ""dirty"") {
+            //   return { status: ""dirty"", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>","-  strict(): ZodObject<T, ""strict"", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, ""strict"", Catchall> {
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, _ctx) => {
+              if (issue.code === ""unrecognized_keys"")
+                return { message: message.toString() };
+              return {
+                message:
+                  this._def.errorMap?.(issue, _ctx).message.toString() ??
+                  _ctx.defaultError,
+              };
+            },
+          }
+        : {}),","+import { FATAL_CODES } from ""./index.ts"";
+  addIssueToContext,
+  isAborted,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
+  defaultErrorMap,
+  overrideErrorMap,
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === ""string"") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
+    if (!ctx.issues.length) {
+      throw new Error(""Validation failed but no issues detected."");
+    }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
-
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
-  }
-
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
+
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
+  }
+
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
-    let invalid = false;
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""email"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""uuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""cuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-          new URL(data);
+          new URL(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""url"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        // clear regex state
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""regex"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: ""integer"",
-              received: ""float"",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+          status.dirty();
-        // const MIN = check.value;
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
-
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
-    const data: any[] = _data;
-
-    let invalid = false;
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
-    });
-
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
+
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
+    });
+
+    return ParseStatus.mergeArray(status, result);
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
+    return this.min(1, message) as any;
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-}
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
+}
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def[""shape""]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def[""shape""]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== ""undefined"" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: ""valid"", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: ""valid"", value: key },
+            value: { status: ""valid"", value: ctx.data[key] },
+          });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: ""valid"", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  strict(): ZodObject<T, ""strict"", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, ""strict"", Catchall> {
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, _ctx) => {
+              if (issue.code === ""unrecognized_keys"")
+                return { message: message.toString() };
+              return {
+                message:
+                  this._def.errorMap?.(issue, _ctx).message.toString() ??
+                  _ctx.defaultError,
+              };
+            },
+          }
+        : {}),
-      // effects: [], // wipe all refinements
-      // const newShape: any = {};
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number][""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== ""invalid_type"";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
-      }
-      return INVALID;
-    };
-
-    if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
-      return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
-    } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      console.log(JSON.stringify(results, null, 2));
+      for (const result of results) {
+        console.log(`######\nresult`);
+        console.log(result.result);
+        if (result.result.status === ""valid"") {
+          console.log(`found clean option`);
+          return result.result;
-      return noMatch(allIssues);
+      for (const result of results) {
+        if (result.result.status === ""dirty"") {
+          // add issues from dirty option
+          console.log(`found dirty option`);
+          // console.log(result.result);
+          console.log(result);
+          console.log(result.ctx.issues);
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
+      }
+
+      console.log(`no clean options`);
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return Promise.all(
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
+    } else {
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
+
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
+      });
+
+      return INVALID;
+    }
+
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
-
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
-    }
+      status.dirty();
+    }
+
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
-
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
+
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, ""key""],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, ""value""],
+            parent: ctx,
+          }),
+        };
-    };
-
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto(""key""),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto(""value""),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    );
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === ""aborted"" || value.status === ""aborted"") {
+            return INVALID;
+          }
+          if (key.status === ""dirty"" || value.status === ""dirty"") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === ""aborted"" || value.status === ""aborted"") {
+          return INVALID;
+        }
+        if (key.status === ""dirty"" || value.status === ""dirty"") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
-    const dataSet: Set<unknown> = data;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === ""aborted"") return INVALID;
+        if (element.status === ""dirty"") status.dirty();
+        parsedSet.add(element.value);
-    };
-
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      return { status: status.value, value: parsedSet };
+    }
+
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
-      });
+      }) as any;
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
-    return OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
-    return OK(data);
-  }
+    return OK(ctx.data);
+  }
+
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T[""_output""]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result).then(() => acc);
+        }
-          if (isSync) {
-            throw new Error(
-              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (base.status === ""aborted"") return INVALID;
+
+        // return value is ignored
+        executeRefinement(base.value, effect);
+        return { status: status.value, value: ctx.data };
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (result.status === ""aborted"") return INVALID;
+
+            return executeRefinement(result.value, effect).then(() => {
+              return { status: status.value, value: ctx.data };
+            });
+          });
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === ""aborted"") return INVALID;
+        // if (base.status === ""dirty"") {
+        //   return { status: ""dirty"", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === ""aborted"") return INVALID;
+            // if (base.status === ""dirty"") {
+            //   return { status: ""dirty"", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>"
colinhacks_zod,fe5bbf61a14187a9149ba58f2965f4a52952e196,Merge branch 'ej/strictError' of git://github.com/ejose19/zod into ejose19-ej/strictError,src/__tests__/error.test.ts,"+test(""custom path"", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: ""qwer"",
+    confirm: ""asdf"",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);","+});
+
+test(""strict error message"", () => {
+  const errorMsg = ""Invalid object"";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: ""a"", y: ""b"" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }","+test(""custom path"", () => {
+  const schema = z
+    .object({
+      password: z.string().min(6),
+      confirm: z.string().min(6),
+    })
+    .refine((val) => val.confirm === val.password);
+
+  const result = schema.safeParse({
+    password: ""qwer"",
+    confirm: ""asdf"",
+  });
+
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues.length).toEqual(3);
+  }
+});
+
-    expect(result1.error.issues.length).toEqual(1);
+    expect(result1.error.issues.length).toEqual(2);
+});
+
+test(""strict error message"", () => {
+  const errorMsg = ""Invalid object"";
+  const obj = z.object({ x: z.string() }).strict(errorMsg);
+  const result = obj.safeParse({ x: ""a"", y: ""b"" });
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(errorMsg);
+  }"
colinhacks_zod,fe5bbf61a14187a9149ba58f2965f4a52952e196,Merge branch 'ej/strictError' of git://github.com/ejose19/zod into ejose19-ej/strictError,src/types.ts,"+import { FATAL_CODES } from ""."";
+  addIssueToContext,
+  isAborted,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
+  defaultErrorMap,
+  overrideErrorMap,
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === ""string"") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
+    if (!ctx.issues.length) {
+      throw new Error(""Validation failed but no issues detected."");
+    }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
-
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
-  }
-
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
+
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
+  }
+
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
-    let invalid = false;
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""email"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""uuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""cuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-          new URL(data);
+          new URL(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""url"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        // clear regex state
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""regex"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: ""integer"",
-              received: ""float"",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+          status.dirty();
-        // const MIN = check.value;
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
-
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
-    const data: any[] = _data;
-
-    let invalid = false;
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
-    });
-
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
+
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
+    });
+
+    return ParseStatus.mergeArray(status, result);
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
+    return this.min(1, message) as any;
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-}
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
+}
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def[""shape""]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def[""shape""]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== ""undefined"" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: ""valid"", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: ""valid"", value: key },
+            value: { status: ""valid"", value: ctx.data[key] },
+          });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: ""valid"", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-      // effects: [], // wipe all refinements
-      // const newShape: any = {};
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number][""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== ""invalid_type"";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
-      }
-      return INVALID;
-    };
-
-    if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
-      return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
-    } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      console.log(JSON.stringify(results, null, 2));
+      for (const result of results) {
+        console.log(`######\nresult`);
+        console.log(result.result);
+        if (result.result.status === ""valid"") {
+          console.log(`found clean option`);
+          return result.result;
-      return noMatch(allIssues);
+      for (const result of results) {
+        if (result.result.status === ""dirty"") {
+          // add issues from dirty option
+          console.log(`found dirty option`);
+          // console.log(result.result);
+          console.log(result);
+          console.log(result.ctx.issues);
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
+      }
+
+      console.log(`no clean options`);
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return Promise.all(
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
+    } else {
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
+
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
+      });
+
+      return INVALID;
+    }
+
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
-
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
-    }
+      status.dirty();
+    }
+
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
-
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
+
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, ""key""],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, ""value""],
+            parent: ctx,
+          }),
+        };
-    };
-
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto(""key""),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto(""value""),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    );
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === ""aborted"" || value.status === ""aborted"") {
+            return INVALID;
+          }
+          if (key.status === ""dirty"" || value.status === ""dirty"") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === ""aborted"" || value.status === ""aborted"") {
+          return INVALID;
+        }
+        if (key.status === ""dirty"" || value.status === ""dirty"") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
-    const dataSet: Set<unknown> = data;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === ""aborted"") return INVALID;
+        if (element.status === ""dirty"") status.dirty();
+        parsedSet.add(element.value);
-    };
-
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      return { status: status.value, value: parsedSet };
+    }
+
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
-      });
+      }) as any;
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
-    return OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
-    return OK(data);
-  }
+    return OK(ctx.data);
+  }
+
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T[""_output""]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result).then(() => acc);
+        }
-          if (isSync) {
-            throw new Error(
-              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (base.status === ""aborted"") return INVALID;
+
+        // return value is ignored
+        executeRefinement(base.value, effect);
+        return { status: status.value, value: ctx.data };
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (result.status === ""aborted"") return INVALID;
+
+            return executeRefinement(result.value, effect).then(() => {
+              return { status: status.value, value: ctx.data };
+            });
+          });
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === ""aborted"") return INVALID;
+        // if (base.status === ""dirty"") {
+        //   return { status: ""dirty"", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === ""aborted"") return INVALID;
+            // if (base.status === ""dirty"") {
+            //   return { status: ""dirty"", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>","-  strict(): ZodObject<T, ""strict"", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, ""strict"", Catchall> {
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, _ctx) => {
+              if (issue.code === ""unrecognized_keys"")
+                return { message: message.toString() };
+              return {
+                message:
+                  this._def.errorMap?.(issue, _ctx).message.toString() ??
+                  _ctx.defaultError,
+              };
+            },
+          }
+        : {}),","+import { FATAL_CODES } from ""."";
+  addIssueToContext,
+  isAborted,
-  isInvalid,
-  isOk,
+  isDirty,
+  isValid,
-  ParseParamsNoData,
+  ParseInput,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
+  ParseStatus,
+  defaultErrorMap,
+  overrideErrorMap,
-// function customErrorMap(arg: string | ZodErrorMap | undefined) {
-//   if (typeof arg === ""string"") {
-//     const map: ZodErrorMap = (iss, ctx) => {
-//       if (iss.code === ZodIssueCode.invalid_type) {
-//         return { message: arg };
-//       }
-//       return { message: ctx.defaultError };
-//     };
-//   }
-// }
-
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
-  new ParseContext({
-    path: pathFromArray(params.path || []),
-    issues: [],
-    errorMap: params.errorMap,
-    async: params.async ?? false,
-  });
-
-  if (isOk(result) && !ctx.issues.length) {
+  if (isValid(result)) {
+    if (!ctx.issues.length) {
+      throw new Error(""Validation failed but no issues detected."");
+    }
-  // if (isOk(result)) {
-  //   return { success: true, data: result.value };
-  // } else {
-  //   const error = new ZodError(ctx.issues);
-  //   return { success: false, error };
-  // }
-  abstract _parse(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<Output>;
-
-  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx._addIssue(params.data, issueData, {
-      schemaErrorMap: this._def.errorMap,
-    });
-  }
-
-  _parseSync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): SyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
+  abstract _parse(input: ParseInput): ParseReturnType<Output>;
+
+  _processInputParams(
+    input: ParseInput
+  ): { status: ParseStatus; ctx: ParseContext } {
+    return {
+      status: new ParseStatus(),
+      ctx: {
+        ...input.parent,
+        data: input.data,
+        parsedType: getParsedType(input.data, input.parent.typeCache),
+        schemaErrorMap: this._def.errorMap,
+        path: input.path,
+        parent: input.parent,
+      },
+    };
+  }
+
+  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
+    const result = this._parse(input);
-  _parseAsync(
-    _ctx: ParseContext,
-    _data: any,
-    _parsedType: ZodParsedType
-  ): AsyncParseReturnType<Output> {
-    const result = this._parse(_ctx, _data, _parsedType);
-    // if (isAsync(result)) {
-    //   return result;
-    // }
+  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
+    const result = this._parse(input);
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: false });
-    const result = this._parseSync(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: params?.async ?? false,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
+
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    const ctx = createRootContext({ ...params, async: true });
-    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const ctx: ParseContext = {
+      path: params?.path || [],
+      issues: [],
+      contextualErrorMap: params?.errorMap,
+      schemaErrorMap: this._def.errorMap,
+      async: true,
+      typeCache: new Map(),
+      parent: null,
+      data,
+      parsedType: getParsedType(data),
+    };
+
+    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-  _parse(
-    ctx: ParseContext,
-    data: string,
-    parsedType: ZodParsedType
-  ): ParseReturnType<string> {
-    if (parsedType !== ZodParsedType.string) {
-      this.addIssue(
+  _parse(input: ParseInput): ParseReturnType<string> {
+    const { status, ctx } = this._processInputParams(input);
+
+    if (ctx.parsedType !== ZodParsedType.string) {
+      addIssueToContext(
-          received: parsedType,
-        },
-        { data }
+          received: ctx.parsedType,
+        }
+        //
-    let invalid = false;
-        if (data.length < check.value) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data.length < check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (data.length > check.value) {
-          invalid = true;
-
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""string"",
-              inclusive: true,
-              message: check.message,
-              // ...errorUtil.errToObj(this._def.maxLength.message),
-            },
-            { data }
-          );
+        if (ctx.data.length > check.value) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+          status.dirty();
-        if (!emailRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""email"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!emailRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!uuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""uuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!uuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        if (!cuidRegex.test(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""cuid"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+        if (!cuidRegex.test(ctx.data)) {
+          addIssueToContext(ctx, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-          new URL(data);
+          new URL(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""url"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-        // clear regex state
-        const testResult = check.regex.test(data);
+        const testResult = check.regex.test(ctx.data);
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              validation: ""regex"",
-              code: ZodIssueCode.invalid_string,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: number,
-    parsedType: ZodParsedType
-  ): ParseReturnType<number> {
-    if (parsedType !== ZodParsedType.number) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.number,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<number> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.number) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.number,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-        if (!util.isInteger(data)) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.invalid_type,
-              expected: ""integer"",
-              received: ""float"",
-              message: check.message,
-            },
-            { data }
-          );
+        if (!util.isInteger(ctx.data)) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+          status.dirty();
-        // const MIN = check.value;
-          ? data < check.value
-          : data <= check.value;
+          ? ctx.data < check.value
+          : ctx.data <= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_small,
-              minimum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-          ? data > check.value
-          : data >= check.value;
+          ? ctx.data > check.value
+          : ctx.data >= check.value;
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.too_big,
-              maximum: check.value,
-              type: ""number"",
-              inclusive: check.inclusive,
-              message: check.message,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+          status.dirty();
-        if (data % check.value !== 0) {
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.not_multiple_of,
-              multipleOf: check.value,
-              message: check.message,
-            },
-            { data }
-          );
+        if (ctx.data % check.value !== 0) {
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+          status.dirty();
-    return invalid ? INVALID : OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: bigint,
-    parsedType: ZodParsedType
-  ): ParseReturnType<bigint> {
-    if (parsedType !== ZodParsedType.bigint) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.bigint,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<bigint> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.bigint) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.bigint,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: boolean,
-    parsedType: ZodParsedType
-  ): ParseReturnType<boolean> {
-    if (parsedType !== ZodParsedType.boolean) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.boolean,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<boolean> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.boolean) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.boolean,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: Date,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Date> {
-    if (parsedType !== ZodParsedType.date) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.date,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.date) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.date,
+        received: ctx.parsedType,
+      });
-    if (isNaN(data.getTime())) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_date,
-        },
-        { data }
-      );
-
+    if (isNaN(ctx.data.getTime())) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_date,
+      });
-    return OK(new Date((data as Date).getTime()));
+    return {
+      status: status.value,
+      value: new Date((ctx.data as Date).getTime()),
+    };
-  _parse(
-    ctx: ParseContext,
-    data: undefined,
-    parsedType: ZodParsedType
-  ): ParseReturnType<undefined> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.undefined,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.undefined,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: null,
-    parsedType: ZodParsedType
-  ): ParseReturnType<null> {
-    if (parsedType !== ZodParsedType.null) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.null,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.null) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.null,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    _ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<unknown> {
-    return OK(data);
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<never> {
-    this.addIssue(
-      ctx,
-      {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.never,
-        received: parsedType,
-      },
-      { data }
-    );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    addIssueToContext(ctx, {
+      code: ZodIssueCode.invalid_type,
+      expected: ZodParsedType.never,
+      received: ctx.parsedType,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<void> {
-    if (parsedType !== ZodParsedType.undefined) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.void,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.undefined) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.void,
+        received: ctx.parsedType,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    _data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
-    // return parseArray(ctx, data, parsedType, this._def) as any;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data: _data }
-      );
-
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
-    const data: any[] = _data;
-
-    let invalid = false;
-      if (data.length < def.minLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_small,
-            minimum: def.minLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.minLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length < def.minLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+        status.dirty();
-      if (data.length > def.maxLength.value) {
-        invalid = true;
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.too_big,
-            maximum: def.maxLength.value,
-            type: ""array"",
-            inclusive: true,
-            message: def.maxLength.message,
-          },
-          { data }
-        );
+      if (ctx.data.length > def.maxLength.value) {
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+        status.dirty();
-    const tasks: Promise<any>[] = [];
-    const result: any = new Array(data.length);
-    const type = def.type;
-    const handleParsed = (
-      index: number,
-      parsedItem: ParseReturnType<T>
-    ): void => {
-      if (isOk(parsedItem)) {
-        result[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    data.forEach((item, index) => {
-      handleParsed(
-        index,
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
-      );
-    });
-
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
-    } else {
-      return invalid ? INVALID : OK(result);
-    }
+      return Promise.all(
+        (ctx.data as any[]).map((item, i) => {
+          return def.type._parseAsync({
+            parent: ctx,
+            path: [...ctx.path, i],
+            data: item,
+          });
+        })
+      ).then((result) => {
+        return ParseStatus.mergeArray(status, result);
+      });
+    }
+
+    const result = (ctx.data as any[]).map((item, i) => {
+      return def.type._parseSync({
+        parent: ctx,
+        path: [...ctx.path, i],
+        data: item,
+      });
+    });
+
+    return ParseStatus.mergeArray(status, result);
-    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
+    return this.min(1, message) as any;
-
-  export const intersectShapes = <U extends ZodRawShape, T extends ZodRawShape>(
-    first: U,
-    second: T
-  ): T & U => {
-    const firstKeys = util.objectKeys(first);
-    const secondKeys = util.objectKeys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
-    return {
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
-    };
-  };
-}
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    // effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-    typeName: ZodFirstPartyTypeKind.ZodObject,
-  }) as any;
-  return merged;
-};
+}
-  // {
-  //   [k in Exclude<
-  //     keyof ReturnType<Def[""shape""]>,
-  //     keyof Augmentation
-  //   >]: ReturnType<Def[""shape""]>[k];
-  // } &
-  //   { [k in keyof Augmentation]: Augmentation[k] },
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-
-    let invalid = false;
-    const tasks: Promise<any>[] = [];
-    const resultObject: Record<string, any> = {};
-
-    const handleParsed = (
-      key: string,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedValue)) {
-        const value = parsedValue.value;
-        if (typeof value !== ""undefined"" || key in data) {
-          // key was valid but result was undefined: add it to the result object
-          // only if key was in the input data object - if it wasn't, then it's
-          // an optional key that should not be added
-          resultObject[key] = value;
-        }
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      }
-    };
-
+    const dataKeys = util.objectKeys(ctx.data);
+    const extraKeys = dataKeys.filter((k) => !(k in shape));
+
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+      alwaysSet?: boolean;
+    }[] = [];
-      const value = data[key];
-      handleParsed(
-        key,
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
-      );
+      const value = ctx.data[key];
+      pairs.push({
+        key: { status: ""valid"", value: key },
+        value: keyValidator._parse({
+          parent: ctx,
+          data: value,
+          path: [...ctx.path, key],
+        }),
+        alwaysSet: key in ctx.data,
+      });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          resultObject[key] = data[key];
+          pairs.push({
+            key: { status: ""valid"", value: key },
+            value: { status: ""valid"", value: ctx.data[key] },
+          });
-        const dataKeys = util.objectKeys(data);
-        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          invalid = true;
-          this.addIssue(
-            ctx,
-            {
-              code: ZodIssueCode.unrecognized_keys,
-              keys: extraKeys,
-            },
-            { data }
-          );
+          addIssueToContext(ctx, {
+            code: ZodIssueCode.unrecognized_keys,
+            keys: extraKeys,
+          });
+          status.dirty();
-      const dataKeys = util.objectKeys(data);
-      const extraKeys = dataKeys.filter((k) => !(k in shape));
+
-        const value = data[key];
-        handleParsed(
-          key,
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
-        );
+        const value = ctx.data[key];
+        pairs.push({
+          key: { status: ""valid"", value: key },
+          value: catchall._parse(
+            { parent: ctx, path: [...ctx.path, key], data: value } //, ctx.child(key), value, getParsedType(value)
+          ),
+          alwaysSet: key in ctx.data,
+        });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(resultObject as Output)
-      );
+      return Promise.resolve()
+        .then(async () => {
+          const syncPairs: any[] = [];
+          for (const pair of pairs) {
+            const key = await pair.key;
+            syncPairs.push({
+              key,
+              value: await pair.value,
+              alwaysSet: pair.alwaysSet,
+            });
+          }
+          return syncPairs;
+        })
+        .then((syncPairs) => {
+          return ParseStatus.mergeObjectSync(status, syncPairs);
+        });
-      return invalid ? INVALID : OK(resultObject as Output);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  strict(): ZodObject<T, ""strict"", Catchall> {
+  strict(message?: errorUtil.ErrMessage): ZodObject<T, ""strict"", Catchall> {
+      ...(message !== undefined
+        ? {
+            errorMap: (issue, _ctx) => {
+              if (issue.code === ""unrecognized_keys"")
+                return { message: message.toString() };
+              return {
+                message:
+                  this._def.errorMap?.(issue, _ctx).message.toString() ??
+                  _ctx.defaultError,
+              };
+            },
+          }
+        : {}),
-      // effects: [], // wipe all refinements
-      // const newShape: any = {};
-// export type toOpts<T> = T extends ZodUnionOptions ? T : never;
-// export type ZodUnionType<
-//   A extends ZodTypeAny,
-//   B extends ZodTypeAny
-// > = A extends ZodUnion<infer AOpts>
-//   ? B extends ZodUnion<infer BOpts>
-//     ? ZodUnion<toOpts<[...AOpts, ...BOpts]>>
-//     : ZodUnion<toOpts<[...AOpts, B]>>
-//   : B extends ZodUnion<infer BOpts>
-//   ? ZodUnion<toOpts<[A, ...BOpts]>>
-//   : ZodUnion<toOpts<[A, B]>>;
-
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[number][""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    const noMatch = (allIssues: ZodIssue[][]) => {
-      const unionErrors = allIssues.map((issues) => new ZodError(issues));
-      const nonTypeErrors = unionErrors.filter((err) => {
-        return err.issues[0].code !== ""invalid_type"";
-      });
-      if (nonTypeErrors.length === 1) {
-        // TODO encapsulate
-        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
-      } else {
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_union,
-            unionErrors,
-          },
-          { data }
-        );
-      }
-      return INVALID;
-    };
-
-    if (ctx.async) {
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
-      return Promise.all(
-        options.map((option, index) =>
-          option._parse(contexts[index], data, parsedType)
-        )
-      ).then((parsedOptions) => {
-        for (const parsedOption of parsedOptions) {
-          if (isOk(parsedOption)) {
-            return parsedOption;
-          }
-        }
-        return noMatch(contexts.map((ctx) => ctx.issues));
-      });
-    } else {
-      const allIssues: ZodIssue[][] = [];
-      for (const option of options) {
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
-        if (isInvalid(parsedOption)) {
-          allIssues.push(optionCtx.issues);
-        } else {
-          return parsedOption;
+
+    function handleResults(
+      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
+    ) {
+      // return first issue-free validation if it exists
+      console.log(JSON.stringify(results, null, 2));
+      for (const result of results) {
+        console.log(`######\nresult`);
+        console.log(result.result);
+        if (result.result.status === ""valid"") {
+          console.log(`found clean option`);
+          return result.result;
-      return noMatch(allIssues);
+      for (const result of results) {
+        if (result.result.status === ""dirty"") {
+          // add issues from dirty option
+          console.log(`found dirty option`);
+          // console.log(result.result);
+          console.log(result);
+          console.log(result.ctx.issues);
+          ctx.issues.push(...result.ctx.issues);
+          return result.result;
+        }
+      }
+
+      console.log(`no clean options`);
+      // return invalid
+      const unionErrors = results.map(
+        (result) => new ZodError(result.ctx.issues)
+      );
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_union,
+        unionErrors,
+      });
+      return INVALID;
+    }
+
+    if (ctx.async) {
+      return Promise.all(
+        options.map(async (option) => {
+          const childCtx: ParseContext = {
+            ...ctx,
+            issues: [],
+            parent: null,
+          };
+          return {
+            result: await option._parseAsync({
+              data: ctx.data,
+              path: ctx.path,
+              parent: childCtx,
+            }),
+            ctx: childCtx,
+          };
+        })
+      ).then(handleResults);
+    } else {
+      const optionResults = options.map((option) => {
+        const childCtx: ParseContext = {
+          ...ctx,
+          issues: [],
+          parent: null,
+        };
+        return {
+          result: option._parseSync({
+            data: ctx.data,
+            path: ctx.path,
+            parent: childCtx,
+          }),
+          ctx: childCtx,
+        };
+      });
+
+      return handleResults(optionResults);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
-      parsedLeft: SyncParseReturnType<T>,
-      parsedRight: SyncParseReturnType<U>
+      parsedLeft: SyncParseReturnType,
+      parsedRight: SyncParseReturnType
-      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
+
-        this.addIssue(
-          ctx,
-          {
-            code: ZodIssueCode.invalid_intersection_types,
-          },
-          { data }
-        );
+        addIssueToContext(ctx, {
+          code: ZodIssueCode.invalid_intersection_types,
+        });
-      return OK(merged.data);
+
+      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
+        status.dirty();
+      }
+
+      return { status: status.value, value: merged.data as any };
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseAsync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        }),
+        this._def.right._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        })
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.array) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.array,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.array) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: ctx.parsedType,
+      });
+    if (ctx.data.length < this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_small,
+        minimum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
+      });
+
+      return INVALID;
+    }
+
-    if (!rest && data.length > this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_big,
-          maximum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    if (data.length < this._def.items.length) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.too_small,
-          minimum: this._def.items.length,
-          inclusive: true,
-          type: ""array"",
-        },
-        { data }
-      );
-      return INVALID;
-    }
-
-    const tasks: Promise<unknown>[] = [];
-    const items = this._def.items as ZodType<any, any, any>[];
-
-    const parseResult: any[] = new Array(data.length);
-    let invalid = false;
-
-    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
-      if (isOk(parsedItem)) {
-        parseResult[index] = parsedItem.value;
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-      }
-    };
-
-    items.forEach((item, index) => {
-      handleParsed(
-        index,
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
-      );
-    });
-
-    if (rest) {
-      const restData: any[] = data.slice(items.length);
-      restData.forEach((dataItem, _index) => {
-        const index = _index + items.length;
-        handleParsed(
-          index,
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-        );
+    if (!rest && ctx.data.length > this._def.items.length) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.too_big,
+        maximum: this._def.items.length,
+        inclusive: true,
+        type: ""array"",
-    }
+      status.dirty();
+    }
+
+    const items = (ctx.data as any[])
+      .map((item, itemIndex) => {
+        const schema = this._def.items[itemIndex] || this._def.rest;
+        if (!schema) return (null as any) as SyncParseReturnType<any>;
+        return schema._parse({
+          data: item,
+          path: [...ctx.path, itemIndex],
+          parent: ctx,
+        });
+      })
+      .filter((x) => !!x); // filter nulls
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return Promise.all(items).then((results) => {
+        return ParseStatus.mergeArray(status, results);
+      });
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Record<any, any>> {
-    if (parsedType !== ZodParsedType.object) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.object,
-          received: parsedType,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.object) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.object,
+        received: ctx.parsedType,
+      });
-    const tasks: Promise<unknown>[] = [];
+    const pairs: {
+      key: ParseReturnType<any>;
+      value: ParseReturnType<any>;
+    }[] = [];
+
-    const parseResult: Record<string, ParseReturnType<any>> = {};
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isOk(parsedKey) && isOk(parsedValue)) {
-        parseResult[parsedKey.value] = parsedValue.value;
-      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else {
-        invalid = true;
-      }
-    };
-
-    for (const key in data) {
-      handleParsed(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
-      );
+
+    for (const key in ctx.data) {
+      pairs.push({
+        key: keyType._parse({
+          data: key,
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+        value: valueType._parse({
+          data: ctx.data[key],
+          path: [...ctx.path, key],
+          parent: ctx,
+        }),
+      });
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      return ParseStatus.mergeObjectAsync(status, pairs);
-      return invalid ? INVALID : OK(parseResult);
+      return ParseStatus.mergeObjectSync(status, pairs as any);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Map<any, any>> {
-    if (parsedType !== ZodParsedType.map) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.map,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.map) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.map,
+        received: ctx.parsedType,
+      });
-    const dataMap: Map<unknown, unknown> = data;
-    const parseResult = new Map();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-    const handleParsed = (
-      parsedKey: ParseReturnType<any>,
-      parsedValue: ParseReturnType<any>
-    ): void => {
-      if (isAsync(parsedKey) || isAsync(parsedValue)) {
-        tasks.push(
-          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-            handleParsed(k, v)
-          )
-        );
-      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
-        invalid = true;
-      } else {
-        parseResult.set(parsedKey.value, parsedValue.value);
+
+    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
+      ([key, value], index) => {
+        return {
+          key: keyType._parse({
+            data: key,
+            path: [...ctx.path, index, ""key""],
+            parent: ctx,
+          }),
+          value: valueType._parse({
+            data: value,
+            path: [...ctx.path, index, ""value""],
+            parent: ctx,
+          }),
+        };
-    };
-
-    [...dataMap.entries()].forEach(([key, value], index) => {
-      const entryCtx = ctx.stepInto(index);
-      const parsedKey = keyType._parse(
-        entryCtx.stepInto(""key""),
-        key,
-        getParsedType(key)
-      );
-      const parsedValue = valueType._parse(
-        entryCtx.stepInto(""value""),
-        value,
-        getParsedType(value)
-      );
-      handleParsed(parsedKey, parsedValue);
-    });
+    );
-      return Promise.all(tasks).then(() =>
-        invalid ? INVALID : OK(parseResult)
-      );
+      const finalMap = new Map();
+      return Promise.resolve().then(async () => {
+        for (const pair of pairs) {
+          const key = await pair.key;
+          const value = await pair.value;
+          if (key.status === ""aborted"" || value.status === ""aborted"") {
+            return INVALID;
+          }
+          if (key.status === ""dirty"" || value.status === ""dirty"") {
+            status.dirty();
+          }
+
+          finalMap.set(key.value, value.value);
+        }
+        return { status: status.value, value: finalMap };
+      });
-      return invalid ? INVALID : OK(parseResult);
+      const finalMap = new Map();
+      for (const pair of pairs) {
+        const key = pair.key as SyncParseReturnType;
+        const value = pair.value as SyncParseReturnType;
+        if (key.status === ""aborted"" || value.status === ""aborted"") {
+          return INVALID;
+        }
+        if (key.status === ""dirty"" || value.status === ""dirty"") {
+          status.dirty();
+        }
+
+        finalMap.set(key.value, value.value);
+      }
+      return { status: status.value, value: finalMap };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Set<any>> {
-    if (parsedType !== ZodParsedType.set) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.set,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.set) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.set,
+        received: ctx.parsedType,
+      });
-    const dataSet: Set<unknown> = data;
-    const parsedSet = new Set();
-    const tasks: Promise<unknown>[] = [];
-    let invalid = false;
-
-    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
-      if (isOk(parsedItem)) {
-        parsedSet.add(parsedItem.value);
-      } else if (isInvalid(parsedItem)) {
-        invalid = true;
-      } else {
-        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
+
+    function finalizeSet(elements: SyncParseReturnType<any>[]) {
+      const parsedSet = new Set();
+      for (const element of elements) {
+        if (element.status === ""aborted"") return INVALID;
+        if (element.status === ""dirty"") status.dirty();
+        parsedSet.add(element.value);
-    };
-
-    [...dataSet.values()].forEach((item, i) =>
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      return { status: status.value, value: parsedSet };
+    }
+
+    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
+      valueType._parse({ data: item, path: [...ctx.path, i], parent: ctx })
-      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
+      return Promise.all(elements).then((elements) => finalizeSet(elements));
-      return invalid ? INVALID : OK(parsedSet);
+      return finalizeSet(elements as SyncParseReturnType[]);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<any> {
-    if (parsedType !== ZodParsedType.function) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.function,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<any> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.function) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.function,
+        received: ctx.parsedType,
+      });
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-        path: pathToArray(ctx.path),
-        errorMaps: [ctx.errorMap],
+        path: ctx.path,
+        errorMaps: [
+          ctx.contextualErrorMap,
+          ctx.schemaErrorMap,
+          overrideErrorMap,
+          defaultErrorMap,
+        ].filter((x) => !!x) as ZodErrorMap[],
-    const params = { errorMap: ctx.errorMap };
-    const fn = data;
+    const params = { errorMap: ctx.contextualErrorMap };
+    const fn = ctx.data;
-        const parsedReturns = await this._def.returns
+        const parsedReturns = await (this._def
+          .returns as ZodPromise<ZodTypeAny>)._def.type
-      });
+      }) as any;
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<output<T>> {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T> {
-    if (data !== this._def.value) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: this._def.value as any,
-          received: data,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+    if (ctx.data !== this._def.value) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: this._def.value as any,
+        received: ctx.data,
+      });
-    return OK(data);
+    return { status: status.value, value: ctx.data };
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[number]> {
-    if (this._def.values.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: this._def.values,
-        },
-        { data }
-      );
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (this._def.values.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: this._def.values,
+      });
-    return OK(data);
+    return OK(ctx.data);
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    _parsedType: ZodParsedType
-  ): ParseReturnType<T[keyof T]> {
+  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
+    const { ctx } = this._processInputParams(input);
-    if (nativeEnumValues.indexOf(data) === -1) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_enum_value,
-          options: util.objectValues(nativeEnumValues),
-        },
-        { data }
-      );
+    if (nativeEnumValues.indexOf(ctx.data) === -1) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_enum_value,
+        options: util.objectValues(nativeEnumValues),
+      });
-    return OK(data);
-  }
+    return OK(ctx.data);
+  }
+
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<Promise<T[""_output""]>> {
-    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-      this.addIssue(
-        ctx,
-        {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.promise,
-          received: parsedType,
-        },
-        { data }
-      );
-
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
+      addIssueToContext(ctx, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.promise,
+        received: ctx.parsedType,
+      });
-      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+      ctx.parsedType === ZodParsedType.promise
+        ? ctx.data
+        : Promise.resolve(ctx.data);
-          path: pathToArray(ctx.path),
-          errorMap: ctx.errorMap,
+          path: ctx.path,
+          errorMap: ctx.contextualErrorMap,
-  _parse(
-    ctx: ParseContext,
-    initialData: any,
-    initialParsedType: ZodParsedType
-  ): ParseReturnType<Output> {
-    const isSync = ctx.async === false;
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { status, ctx } = this._processInputParams(input);
+
-    const data = initialData;
-    const parsedType: ZodParsedType = initialParsedType;
-      const processed = effect.transform(initialData);
+      const processed = effect.transform(ctx.data);
-        return Promise.resolve(processed).then((val) =>
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
-        );
+        return Promise.resolve(processed).then((processed) => {
+          return this._def.schema._parseAsync({
+            data: processed,
+            path: ctx.path,
+            parent: ctx,
+          });
+        });
-        const result = this._def.schema._parseSync(
-          ctx,
-          processed,
-          getParsedType(processed)
-        );
-        if (result instanceof Promise)
-          throw new Error(
-            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
-          );
-        return result;
+        return this._def.schema._parseSync({
+          data: processed,
+          path: ctx.path,
+          parent: ctx,
+        });
-      let invalid = false;
+      const checkCtx: RefinementCtx = {
+        addIssue: (arg: IssueData) => {
+          addIssueToContext(ctx, arg);
+          if (FATAL_CODES.includes(arg.code)) {
+            status.abort();
+          } else {
+            status.dirty();
+          }
+        },
+        get path() {
+          return ctx.path;
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+        if (ctx.async) {
+          return Promise.resolve(result).then(() => acc);
+        }
-          if (isSync) {
-            throw new Error(
-              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-            );
-          }
-          return result.then(() => acc);
+          throw new Error(
+            ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
-      const _addIssue = (arg: IssueData) => {
-        // don't abort early on refinement issues
-        invalid = true;
-        this.addIssue(ctx, arg, { data });
-      };
-      const checkCtx: RefinementCtx = {
-        addIssue: _addIssue,
-        get path() {
-          return pathToArray(ctx.path);
-        },
-      };
-
-      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = executeRefinement(base.value, effect);
-        return invalid ? INVALID : OK(result);
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        if (base.status === ""aborted"") return INVALID;
+
+        // return value is ignored
+        executeRefinement(base.value, effect);
+        return { status: status.value, value: ctx.data };
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(result)) return INVALID;
-            return executeRefinement(result.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (result.status === ""aborted"") return INVALID;
+
+            return executeRefinement(result.value, effect).then(() => {
+              return { status: status.value, value: ctx.data };
+            });
+          });
-      const invalid = false;
-      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
-        const transformed = effect.transform(acc);
-        if (transformed instanceof Promise && isSync) {
+      if (ctx.async === false) {
+        const base = this._def.schema._parseSync({
+          data: ctx.data,
+          path: ctx.path,
+          parent: ctx,
+        });
+        // if (base.status === ""aborted"") return INVALID;
+        // if (base.status === ""dirty"") {
+        //   return { status: ""dirty"", value: base.value };
+        // }
+        if (!isValid(base)) return base;
+
+        const result = effect.transform(base.value);
+        if (result instanceof Promise) {
-        return transformed;
-      };
-      if (isSync) {
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
-        if (isInvalid(base)) return INVALID;
-        const result = applyTransform(base.value, effect);
-        return invalid ? INVALID : OK(result);
+        return OK(result);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
-            if (isInvalid(base)) return INVALID;
-            return applyTransform(base.value, effect);
-          })
-          .then((val) => (invalid ? INVALID : OK(val)));
+            if (!isValid(base)) return base;
+            // if (base.status === ""aborted"") return INVALID;
+            // if (base.status === ""dirty"") {
+            //   return { status: ""dirty"", value: base.value };
+            // }
+            return Promise.resolve(effect.transform(base.value)).then(OK);
+          });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | undefined> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<T[""_output""] | null> {
-    if (parsedType === ZodParsedType.null) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    if (ctx.parsedType === ZodParsedType.null) {
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse({
+      data: ctx.data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  _parse(
-    ctx: ParseContext,
-    data: any,
-    parsedType: ZodParsedType
-  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
-    if (parsedType === ZodParsedType.undefined) {
+  _parse(input: ParseInput): ParseReturnType<this[""_output""]> {
+    const { ctx } = this._processInputParams(input);
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse({
+      data,
+      path: ctx.path,
+      parent: ctx,
+    });
-  | ZodArray<any>
-  | ZodObject<any>
+  | ZodArray<any, any>
+  | ZodObject<any, any, any, any, any>
-  | ZodTuple
-  | ZodRecord
-  | ZodMap
-  | ZodSet
+  | ZodTuple<any, any>
+  | ZodRecord<any, any>
+  | ZodMap<any>
+  | ZodSet<any>
-  | ZodEffects<any>
+  | ZodEffects<any, any, any>"
colinhacks_zod,4785fe6f5c167a21c67790cccf13023dca70d98e,Merge branch 'master' into parent-tracking-context,deno/lib/helpers/parseUtil.ts,"-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: (ZodErrorMap | undefined)[];
+  issueData: IssueData;
+}): ZodIssue => {
-  // data: any;
-export type ParseParamsNoData = Omit<ParseParams, ""data"">;
-
-
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
+  readonly parent: ParseContext | null;
+  _invalid: boolean;
+  _aborted: boolean;
-  public readonly def: ParseContextDef;
+  protected readonly def: ParseContextDef;
+
+  get invalid() {
+    return this.def._invalid;
+  }
+  get aborted() {
+    return this.def._aborted;
+  }
+
+  markInvalid() {
+    if (!this.def._invalid) {
+      this.def._invalid = true;
+      if (this.def.parent) this.def.parent.markInvalid();
+    }
+  }
+
+  abort() {
+    if (!this.def._aborted) {
+      this.def._aborted = true;
+      if (this.def.parent) this.def.parent.abort();
+    }
+  }
-  stepInto(component: ParsePathComponent): ParseContext {
+  child(component?: ParsePathComponent) {
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
+      path: component ? [...this.path, component] : this.path,
+      parent: this,
+      _invalid: false,
+      _aborted: false,
+    });
+  }
+
+  clone() {
+    return new ParseContext({
+      ...this.def,
+    });
+  }
+
+  clearIssues() {
+    return new ParseContext({
+      ...this.def,
+      issues: [],
-      path: pathToArray(this.path),
+      path: this.path,
-      // errorMaps: [this.errorMap],
-      // issueData,
+    this.markInvalid();","-  addIssue(
+  _addIssue(","-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: (ZodErrorMap | undefined)[];
+  issueData: IssueData;
+}): ZodIssue => {
-  // data: any;
-export type ParseParamsNoData = Omit<ParseParams, ""data"">;
-
-
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
+  readonly parent: ParseContext | null;
+  _invalid: boolean;
+  _aborted: boolean;
-  public readonly def: ParseContextDef;
+  protected readonly def: ParseContextDef;
+
+  get invalid() {
+    return this.def._invalid;
+  }
+  get aborted() {
+    return this.def._aborted;
+  }
+
+  markInvalid() {
+    if (!this.def._invalid) {
+      this.def._invalid = true;
+      if (this.def.parent) this.def.parent.markInvalid();
+    }
+  }
+
+  abort() {
+    if (!this.def._aborted) {
+      this.def._aborted = true;
+      if (this.def.parent) this.def.parent.abort();
+    }
+  }
-  stepInto(component: ParsePathComponent): ParseContext {
+  child(component?: ParsePathComponent) {
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
-    });
-  }
-
-  addIssue(
+      path: component ? [...this.path, component] : this.path,
+      parent: this,
+      _invalid: false,
+      _aborted: false,
+    });
+  }
+
+  clone() {
+    return new ParseContext({
+      ...this.def,
+    });
+  }
+
+  clearIssues() {
+    return new ParseContext({
+      ...this.def,
+      issues: [],
+    });
+  }
+
+  _addIssue(
-      path: pathToArray(this.path),
+      path: this.path,
-      // errorMaps: [this.errorMap],
-      // issueData,
+    this.markInvalid();"
colinhacks_zod,4785fe6f5c167a21c67790cccf13023dca70d98e,Merge branch 'master' into parent-tracking-context,deno/lib/types.ts,"-  ParseParamsNoData,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+const createRootContext = (params: Partial<ParseParams>): ParseContext =>
-    path: pathFromArray(params.path || []),
+    path: params.path || [],
+    parent: null,
+    _invalid: false,
+    _aborted: false,
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
+        type._parse(ctx.child(index), item, getParsedType(item))
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+        keyValidator._parse(ctx.child(key), value, getParsedType(value))
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+          catchall._parse(ctx.child(key), value, getParsedType(value))
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
+      const contexts = options.map(() => ctx.clone().clearIssues());
-          option._parse(contexts[index], data, parsedType)
+          option._parse(contexts[index].child(), data, parsedType)
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        const optionCtx = ctx.clone().clearIssues(); // new ParseContext({ ...ctx.def, issues: [] });
+        const parsedOption = option._parseSync(
+          optionCtx.child(),
+          data,
+          parsedType
+        );
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parse(ctx.child(), data, parsedType),
+        this._def.right._parse(ctx.child(), data, parsedType),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync(ctx.child(), data, parsedType),
+        this._def.right._parseSync(ctx.child(), data, parsedType)
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
+        item._parse(ctx.child(index), data[index], getParsedType(data[index]))
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+          rest._parse(ctx.child(index), dataItem, getParsedType(dataItem))
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+        keyType._parse(ctx.child(key), key, getParsedType(key)),
+        valueType._parse(ctx.child(key), data[key], getParsedType(data[key]))
-      const entryCtx = ctx.stepInto(index);
+      const entryCtx = ctx.child(index);
-        entryCtx.stepInto(""key""),
+        entryCtx.child(""key""),
-        entryCtx.stepInto(""value""),
+        entryCtx.child(""value""),
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      handleParsed(valueType._parse(ctx.child(i), item, getParsedType(item)))
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse(ctx.child(), data, parsedType);
-          path: pathToArray(ctx.path),
+          path: ctx.path,
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+          this._def.schema._parseAsync(ctx.child(), val, getParsedType(val))
-          ctx,
+          ctx.child(),
-          return pathToArray(ctx.path);
+          return ctx.path;
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse(ctx.child(), data, getParsedType(data));","-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-
-          this._addIssue(
+          invalid = true;
+
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        if (!check.regex.test(data)) {
-          // invalid = true;
-          this._addIssue(
+        // clear regex state
+        check.regex.lastIndex = 0;
+        const testResult = check.regex.test(data);
+        if (!testResult) {
+          invalid = true;
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        this._addIssue(
+        this.addIssue(
+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });","-  ParseParamsNoData,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+const createRootContext = (params: Partial<ParseParams>): ParseContext =>
-    path: pathFromArray(params.path || []),
+    path: params.path || [],
+    parent: null,
+    _invalid: false,
+    _aborted: false,
-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-
-          this._addIssue(
+          invalid = true;
+
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        if (!check.regex.test(data)) {
-          // invalid = true;
-          this._addIssue(
+        // clear regex state
+        check.regex.lastIndex = 0;
+        const testResult = check.regex.test(data);
+        if (!testResult) {
+          invalid = true;
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
+        type._parse(ctx.child(index), item, getParsedType(item))
-      this._addIssue(
+      this.addIssue(
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+        keyValidator._parse(ctx.child(key), value, getParsedType(value))
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+          catchall._parse(ctx.child(key), value, getParsedType(value))
-        this._addIssue(
+        this.addIssue(
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
+      const contexts = options.map(() => ctx.clone().clearIssues());
-          option._parse(contexts[index], data, parsedType)
+          option._parse(contexts[index].child(), data, parsedType)
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        const optionCtx = ctx.clone().clearIssues(); // new ParseContext({ ...ctx.def, issues: [] });
+        const parsedOption = option._parseSync(
+          optionCtx.child(),
+          data,
+          parsedType
+        );
+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };
-        this._addIssue(
+        this.addIssue(
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parse(ctx.child(), data, parsedType),
+        this._def.right._parse(ctx.child(), data, parsedType),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync(ctx.child(), data, parsedType),
+        this._def.right._parseSync(ctx.child(), data, parsedType)
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
+        item._parse(ctx.child(index), data[index], getParsedType(data[index]))
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+          rest._parse(ctx.child(index), dataItem, getParsedType(dataItem))
-      this._addIssue(
+      this.addIssue(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+        keyType._parse(ctx.child(key), key, getParsedType(key)),
+        valueType._parse(ctx.child(key), data[key], getParsedType(data[key]))
-      this._addIssue(
+      this.addIssue(
-      const entryCtx = ctx.stepInto(index);
+      const entryCtx = ctx.child(index);
-        entryCtx.stepInto(""key""),
+        entryCtx.child(""key""),
-        entryCtx.stepInto(""value""),
+        entryCtx.child(""value""),
-      this._addIssue(
+      this.addIssue(
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      handleParsed(valueType._parse(ctx.child(i), item, getParsedType(item)))
-      this._addIssue(
+      this.addIssue(
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse(ctx.child(), data, parsedType);
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          path: pathToArray(ctx.path),
+          path: ctx.path,
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+          this._def.schema._parseAsync(ctx.child(), val, getParsedType(val))
-          ctx,
+          ctx.child(),
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });
-          return pathToArray(ctx.path);
+          return ctx.path;
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse(ctx.child(), data, getParsedType(data));"
colinhacks_zod,4785fe6f5c167a21c67790cccf13023dca70d98e,Merge branch 'master' into parent-tracking-context,src/helpers/parseUtil.ts,"-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: (ZodErrorMap | undefined)[];
+  issueData: IssueData;
+}): ZodIssue => {
-  // data: any;
-export type ParseParamsNoData = Omit<ParseParams, ""data"">;
-
-
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
+  readonly parent: ParseContext | null;
+  _invalid: boolean;
+  _aborted: boolean;
-  public readonly def: ParseContextDef;
+  protected readonly def: ParseContextDef;
+
+  get invalid() {
+    return this.def._invalid;
+  }
+  get aborted() {
+    return this.def._aborted;
+  }
+
+  markInvalid() {
+    if (!this.def._invalid) {
+      this.def._invalid = true;
+      if (this.def.parent) this.def.parent.markInvalid();
+    }
+  }
+
+  abort() {
+    if (!this.def._aborted) {
+      this.def._aborted = true;
+      if (this.def.parent) this.def.parent.abort();
+    }
+  }
-  stepInto(component: ParsePathComponent): ParseContext {
+  child(component?: ParsePathComponent) {
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
+      path: component ? [...this.path, component] : this.path,
+      parent: this,
+      _invalid: false,
+      _aborted: false,
+    });
+  }
+
+  clone() {
+    return new ParseContext({
+      ...this.def,
+    });
+  }
+
+  clearIssues() {
+    return new ParseContext({
+      ...this.def,
+      issues: [],
-      path: pathToArray(this.path),
+      path: this.path,
-      // errorMaps: [this.errorMap],
-      // issueData,
+    this.markInvalid();","-  addIssue(
+  _addIssue(","-export const makeIssue = (
-  params: {
-    data: any;
-    path: (string | number)[];
-    errorMaps: (ZodErrorMap | undefined)[];
-    issueData: IssueData;
-  }
-  // data: any,
-  // path: (string | number)[],
-  // errorMap: ZodErrorMap,
-  // issueData: IssueData
-): ZodIssue => {
+export const makeIssue = (params: {
+  data: any;
+  path: (string | number)[];
+  errorMaps: (ZodErrorMap | undefined)[];
+  issueData: IssueData;
+}): ZodIssue => {
-  // data: any;
-export type ParseParamsNoData = Omit<ParseParams, ""data"">;
-
-
-export type ParsePath = null | {
-  readonly component: ParsePathComponent;
-  readonly parent: ParsePath;
-  readonly count: number;
-};
-
-export const EMPTY_PATH: ParsePath = null;
-
-export const pathToArray = (path: ParsePath): ParsePathComponent[] => {
-  if (path === null) return [];
-  const arr: ParsePathComponent[] = new Array(path.count);
-  while (path !== null) {
-    arr[path.count - 1] = path.component;
-    path = path.parent;
-  }
-  return arr;
-};
-
-export const pathFromArray = (arr: ParsePathComponent[]): ParsePath => {
-  let path: ParsePath = null;
-  for (let i = 0; i < arr.length; i++) {
-    path = { parent: path, component: arr[i], count: i + 1 };
-  }
-  return path;
-};
-
-export type ParseContextParameters = {
-  errorMap: ZodErrorMap;
-  async: boolean;
-};
+export type ParsePath = ParsePathComponent[];
+export const EMPTY_PATH: ParsePath = [];
+  readonly parent: ParseContext | null;
+  _invalid: boolean;
+  _aborted: boolean;
-  public readonly def: ParseContextDef;
+  protected readonly def: ParseContextDef;
+
+  get invalid() {
+    return this.def._invalid;
+  }
+  get aborted() {
+    return this.def._aborted;
+  }
+
+  markInvalid() {
+    if (!this.def._invalid) {
+      this.def._invalid = true;
+      if (this.def.parent) this.def.parent.markInvalid();
+    }
+  }
+
+  abort() {
+    if (!this.def._aborted) {
+      this.def._aborted = true;
+      if (this.def.parent) this.def.parent.abort();
+    }
+  }
-  stepInto(component: ParsePathComponent): ParseContext {
+  child(component?: ParsePathComponent) {
-      path:
-        this.path === null
-          ? { parent: null, count: 1, component }
-          : { parent: this.path, count: this.path.count + 1, component },
-    });
-  }
-
-  addIssue(
+      path: component ? [...this.path, component] : this.path,
+      parent: this,
+      _invalid: false,
+      _aborted: false,
+    });
+  }
+
+  clone() {
+    return new ParseContext({
+      ...this.def,
+    });
+  }
+
+  clearIssues() {
+    return new ParseContext({
+      ...this.def,
+      issues: [],
+    });
+  }
+
+  _addIssue(
-      path: pathToArray(this.path),
+      path: this.path,
-      // errorMaps: [this.errorMap],
-      // issueData,
+    this.markInvalid();"
colinhacks_zod,4785fe6f5c167a21c67790cccf13023dca70d98e,Merge branch 'master' into parent-tracking-context,src/types.ts,"-  ParseParamsNoData,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+const createRootContext = (params: Partial<ParseParams>): ParseContext =>
-    path: pathFromArray(params.path || []),
+    path: params.path || [],
+    parent: null,
+    _invalid: false,
+    _aborted: false,
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
+        type._parse(ctx.child(index), item, getParsedType(item))
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+        keyValidator._parse(ctx.child(key), value, getParsedType(value))
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+          catchall._parse(ctx.child(key), value, getParsedType(value))
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
+      const contexts = options.map(() => ctx.clone().clearIssues());
-          option._parse(contexts[index], data, parsedType)
+          option._parse(contexts[index].child(), data, parsedType)
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        const optionCtx = ctx.clone().clearIssues(); // new ParseContext({ ...ctx.def, issues: [] });
+        const parsedOption = option._parseSync(
+          optionCtx.child(),
+          data,
+          parsedType
+        );
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parse(ctx.child(), data, parsedType),
+        this._def.right._parse(ctx.child(), data, parsedType),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync(ctx.child(), data, parsedType),
+        this._def.right._parseSync(ctx.child(), data, parsedType)
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
+        item._parse(ctx.child(index), data[index], getParsedType(data[index]))
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+          rest._parse(ctx.child(index), dataItem, getParsedType(dataItem))
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+        keyType._parse(ctx.child(key), key, getParsedType(key)),
+        valueType._parse(ctx.child(key), data[key], getParsedType(data[key]))
-      const entryCtx = ctx.stepInto(index);
+      const entryCtx = ctx.child(index);
-        entryCtx.stepInto(""key""),
+        entryCtx.child(""key""),
-        entryCtx.stepInto(""value""),
+        entryCtx.child(""value""),
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      handleParsed(valueType._parse(ctx.child(i), item, getParsedType(item)))
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse(ctx.child(), data, parsedType);
-          path: pathToArray(ctx.path),
+          path: ctx.path,
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+          this._def.schema._parseAsync(ctx.child(), val, getParsedType(val))
-          ctx,
+          ctx.child(),
-          return pathToArray(ctx.path);
+          return ctx.path;
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse(ctx.child(), data, getParsedType(data));","-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-
-          this._addIssue(
+          invalid = true;
+
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        if (!check.regex.test(data)) {
-          // invalid = true;
-          this._addIssue(
+        // clear regex state
+        check.regex.lastIndex = 0;
+        const testResult = check.regex.test(data);
+        if (!testResult) {
+          invalid = true;
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        this._addIssue(
+        this.addIssue(
+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });","-  ParseParamsNoData,
+  ParseParams,
-  pathFromArray,
-  pathToArray,
-const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+const createRootContext = (params: Partial<ParseParams>): ParseContext =>
-    path: pathFromArray(params.path || []),
+    path: params.path || [],
+    parent: null,
+    _invalid: false,
+    _aborted: false,
-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
+  parse(data: unknown, params?: Partial<ParseParams>): Output {
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    params?: Partial<ParseParamsNoData>
+    params?: Partial<ParseParams>
-    // if (this instanceof ZodOptional) {
-    //   return new ZodOptional({
-    //     ...this._def,
-    //     defaultValue: defaultValueFunc,
-    //   }) as any;
-    // }
+
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-
-          this._addIssue(
+          invalid = true;
+
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-        if (!check.regex.test(data)) {
-          // invalid = true;
-          this._addIssue(
+        // clear regex state
+        check.regex.lastIndex = 0;
+        const testResult = check.regex.test(data);
+        if (!testResult) {
+          invalid = true;
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-    const invalid = false;
+    let invalid = false;
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        // invalid = true;
-        this._addIssue(
+        invalid = true;
+        this.addIssue(
-        type._parse(ctx.stepInto(index), item, getParsedType(item))
+        type._parse(ctx.child(index), item, getParsedType(item))
-      this._addIssue(
+      this.addIssue(
-        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+        keyValidator._parse(ctx.child(key), value, getParsedType(value))
-          // invalid = true;
-          this._addIssue(
+          invalid = true;
+          this.addIssue(
-          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+          catchall._parse(ctx.child(key), value, getParsedType(value))
-        this._addIssue(
+        this.addIssue(
-      const contexts = options.map(
-        () => new ParseContext({ ...ctx.def, issues: [] })
-      );
+      const contexts = options.map(() => ctx.clone().clearIssues());
-          option._parse(contexts[index], data, parsedType)
+          option._parse(contexts[index].child(), data, parsedType)
-        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        const optionCtx = ctx.clone().clearIssues(); // new ParseContext({ ...ctx.def, issues: [] });
+        const parsedOption = option._parseSync(
+          optionCtx.child(),
+          data,
+          parsedType
+        );
+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };
-        this._addIssue(
+        this.addIssue(
-        this._def.left._parse(ctx, data, parsedType),
-        this._def.right._parse(ctx, data, parsedType),
+        this._def.left._parse(ctx.child(), data, parsedType),
+        this._def.right._parse(ctx.child(), data, parsedType),
-        this._def.left._parseSync(ctx, data, parsedType),
-        this._def.right._parseSync(ctx, data, parsedType)
+        this._def.left._parseSync(ctx.child(), data, parsedType),
+        this._def.right._parseSync(ctx.child(), data, parsedType)
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-        item._parse(
-          ctx.stepInto(index),
-          data[index],
-          getParsedType(data[index])
-        )
+        item._parse(ctx.child(index), data[index], getParsedType(data[index]))
-          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+          rest._parse(ctx.child(index), dataItem, getParsedType(dataItem))
-      this._addIssue(
+      this.addIssue(
-        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+        keyType._parse(ctx.child(key), key, getParsedType(key)),
+        valueType._parse(ctx.child(key), data[key], getParsedType(data[key]))
-      this._addIssue(
+      this.addIssue(
-      const entryCtx = ctx.stepInto(index);
+      const entryCtx = ctx.child(index);
-        entryCtx.stepInto(""key""),
+        entryCtx.child(""key""),
-        entryCtx.stepInto(""value""),
+        entryCtx.child(""value""),
-      this._addIssue(
+      this.addIssue(
-      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+      handleParsed(valueType._parse(ctx.child(i), item, getParsedType(item)))
-      this._addIssue(
+      this.addIssue(
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-        path: pathToArray(ctx.path),
+        path: ctx.path,
-    return lazySchema._parse(ctx, data, parsedType);
+    return lazySchema._parse(ctx.child(), data, parsedType);
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          path: pathToArray(ctx.path),
+          path: ctx.path,
-          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+          this._def.schema._parseAsync(ctx.child(), val, getParsedType(val))
-          ctx,
+          ctx.child(),
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });
-          return pathToArray(ctx.path);
+          return ctx.path;
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        const base = this._def.schema._parseSync(ctx.child(), data, parsedType);
-          ._parseAsync(ctx, data, parsedType)
+          ._parseAsync(ctx.child(), data, parsedType)
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, parsedType);
+    return this._def.innerType._parse(ctx.child(), data, parsedType);
-    return this._def.innerType._parse(ctx, data, getParsedType(data));
+    return this._def.innerType._parse(ctx.child(), data, getParsedType(data));"
colinhacks_zod,a937388c28f1f17dfde3f7e3d9d5d796b80a403a,Merge branch 'deep-intersection-arrays' of git://github.com/retailnext/zod into retailnext-deep-intersection-arrays,src/types.ts,"-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        this._addIssue(
+        this.addIssue(
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-        this._addIssue(
+        this.addIssue(
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });","+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };","-  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
-    ctx.addIssue(params.data, issueData, {
+  addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx._addIssue(params.data, issueData, {
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
+  }
+  get isCUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""cuid"");
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-          this._addIssue(
+          this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-    this._addIssue(
+    this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      ctx.addIssue(_data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this.addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data: _data }
+      );
-        this._addIssue(
+        this.addIssue(
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-          this._addIssue(
+          this.addIssue(
-        this._addIssue(
+        this.addIssue(
+  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
+    if (a.length !== b.length) {
+      return { valid: false };
+    }
+
+    const newArray = [];
+    for (let index = 0; index < a.length; index++) {
+      const itemA = a[index];
+      const itemB = b[index];
+      const sharedValue = mergeValues(itemA, itemB);
+
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+
+      newArray.push(sharedValue.data);
+    }
+
+    return { valid: true, data: newArray };
-        this._addIssue(
+        this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      this._addIssue(
+      this.addIssue(
-      const invalid = false;
+      let invalid = false;
-        // invalid = true;
-        this._addIssue(ctx, arg, { data });
+        invalid = true;
+        this.addIssue(ctx, arg, { data });"
colinhacks_zod,f4437e6ab66bbd8e65f171f1b7c81435d10bf7d8,Merge branch 'wojpawlik-ts4.4' into v3.9,deno/lib/types.ts,"-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
-  };
-
-  safeParse: (
+  }
+
+  safeParse(
-  ) =>
+  ):
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
-    return handleResult(ctx, result, params?.parentError);
-  };
-
-  parseAsync: (
-    x: unknown,
+    return handleResult(ctx, result);
+  }
+
+  async parseAsync(
+    data: unknown,
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
-  };
-
-  safeParseAsync: (
-    x: unknown,
+  }
+
+  async safeParseAsync(
+    data: unknown,
-  ) => Promise<
+  ): Promise<
-  > = async (data, params) => {
+  > {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine<Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
-  };
-
-  refinement: <This extends this = this>(
+  }
+
+  refinement(
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
-  };
-
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  }
+
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
-      checks: [
-        ...this._def.checks,
-        { kind: ""email"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""url"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""uuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""cuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""email"", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""url"", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""uuid"", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""cuid"", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""regex"",
+      regex: regex,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: minLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.not_multiple_of,
-            multipleOf: check.value,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, true, errorUtil.toString(message));
+  }
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, false, errorUtil.toString(message));
-
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, false, errorUtil.toString(message));
+  }
+
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, true, errorUtil.toString(message));
+  }
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, false, errorUtil.toString(message));
-
-  protected setLimit = (
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, false, errorUtil.toString(message));
+  }
+
+  protected setLimit(
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
-
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  }
+
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""int"",
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""multipleOf"",
-          value: value,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""int"",
+      message: errorUtil.toString(message),
+    });
+  }
+
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""multipleOf"",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
-
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
-    message?: any
-  ) => {
+  }
+
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, ""atleastone""> {
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  }
+
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  strict = (): ZodObject<T, ""strict"", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, ""strict"", Catchall> {
+    return new ZodObject({
-
-  strip = (): ZodObject<T, ""strip"", Catchall> =>
-    new ZodObject({
+  }
+
+  strip(): ZodObject<T, ""strip"", Catchall> {
+    return new ZodObject({
-
-  passthrough = (): ZodObject<T, ""passthrough"", Catchall> =>
-    new ZodObject({
+  }
+
+  passthrough(): ZodObject<T, ""passthrough"", Catchall> {
+    return new ZodObject({
+  }
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
-  };
+  }
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
-  ) => //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> {
-  };
-
-  catchall = <Index extends ZodTypeAny>(
+  }
+
+  catchall<Index extends ZodTypeAny>(
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  pick<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  omit<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  required = (): ZodObject<
+  }
+
+  required(): ZodObject<
-  > => {
+  > {
-  };
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  }
+
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  args = <Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
+    });
+  }
+
+  returns<NewReturnType extends ZodType<any, any>>(
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  }
+
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
-  };
-
-  strictImplement = (
+  }
+
+  strictImplement(
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
-  };
+  }
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
-  };
-
-  safeParse: (
+  }
+
+  safeParse(
-  ) =>
+  ):
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
-    return handleResult(ctx, result, params?.parentError);
-  };
-
-  parseAsync: (
-    x: unknown,
+    return handleResult(ctx, result);
+  }
+
+  async parseAsync(
+    data: unknown,
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
-  };
-
-  safeParseAsync: (
-    x: unknown,
+  }
+
+  async safeParseAsync(
+    data: unknown,
-  ) => Promise<
+  ): Promise<
-  > = async (data, params) => {
+  > {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
-  is: never;
+  is!: never;
-  check: never;
-
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  check!: never;
+
+  refine<Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
-  };
-
-  refinement: <This extends this = this>(
+  }
+
+  refinement(
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
-  };
-
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  }
+
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
-      checks: [
-        ...this._def.checks,
-        { kind: ""email"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""url"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""uuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""cuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""email"", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""url"", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""uuid"", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""cuid"", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""regex"",
+      regex: regex,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: minLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.not_multiple_of,
-            multipleOf: check.value,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, true, errorUtil.toString(message));
+  }
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, false, errorUtil.toString(message));
-
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, false, errorUtil.toString(message));
+  }
+
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, true, errorUtil.toString(message));
+  }
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, false, errorUtil.toString(message));
-
-  protected setLimit = (
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, false, errorUtil.toString(message));
+  }
+
+  protected setLimit(
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
-
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  }
+
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""int"",
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""multipleOf"",
-          value: value,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""int"",
+      message: errorUtil.toString(message),
+    });
+  }
+
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""multipleOf"",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
-
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
-    message?: any
-  ) => {
+  }
+
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, ""atleastone""> {
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  }
+
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  strict = (): ZodObject<T, ""strict"", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, ""strict"", Catchall> {
+    return new ZodObject({
-
-  strip = (): ZodObject<T, ""strip"", Catchall> =>
-    new ZodObject({
+  }
+
+  strip(): ZodObject<T, ""strip"", Catchall> {
+    return new ZodObject({
-
-  passthrough = (): ZodObject<T, ""passthrough"", Catchall> =>
-    new ZodObject({
+  }
+
+  passthrough(): ZodObject<T, ""passthrough"", Catchall> {
+    return new ZodObject({
+  }
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
-  };
+  }
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
-  ) => //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> {
-  };
-
-  catchall = <Index extends ZodTypeAny>(
+  }
+
+  catchall<Index extends ZodTypeAny>(
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  pick<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  omit<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  required = (): ZodObject<
+  }
+
+  required(): ZodObject<
-  > => {
+  > {
-  };
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  }
+
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  args = <Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
+    });
+  }
+
+  returns<NewReturnType extends ZodType<any, any>>(
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  }
+
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
-  };
-
-  strictImplement = (
+  }
+
+  strictImplement(
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
-  };
+  }
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),"
colinhacks_zod,f4437e6ab66bbd8e65f171f1b7c81435d10bf7d8,Merge branch 'wojpawlik-ts4.4' into v3.9,src/types.ts,"-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
-  };
-
-  safeParse: (
+  }
+
+  safeParse(
-  ) =>
+  ):
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
-    return handleResult(ctx, result, params?.parentError);
-  };
-
-  parseAsync: (
-    x: unknown,
+    return handleResult(ctx, result);
+  }
+
+  async parseAsync(
+    data: unknown,
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
-  };
-
-  safeParseAsync: (
-    x: unknown,
+  }
+
+  async safeParseAsync(
+    data: unknown,
-  ) => Promise<
+  ): Promise<
-  > = async (data, params) => {
+  > {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine<Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
-  };
-
-  refinement: <This extends this = this>(
+  }
+
+  refinement(
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
-  };
-
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  }
+
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
-      checks: [
-        ...this._def.checks,
-        { kind: ""email"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""url"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""uuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""cuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""email"", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""url"", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""uuid"", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""cuid"", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""regex"",
+      regex: regex,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: minLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.not_multiple_of,
-            multipleOf: check.value,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, true, errorUtil.toString(message));
+  }
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, false, errorUtil.toString(message));
-
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, false, errorUtil.toString(message));
+  }
+
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, true, errorUtil.toString(message));
+  }
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, false, errorUtil.toString(message));
-
-  protected setLimit = (
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, false, errorUtil.toString(message));
+  }
+
+  protected setLimit(
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
-
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  }
+
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""int"",
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""multipleOf"",
-          value: value,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""int"",
+      message: errorUtil.toString(message),
+    });
+  }
+
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""multipleOf"",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
-
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
-    message?: any
-  ) => {
+  }
+
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, ""atleastone""> {
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  }
+
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  strict = (): ZodObject<T, ""strict"", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, ""strict"", Catchall> {
+    return new ZodObject({
-
-  strip = (): ZodObject<T, ""strip"", Catchall> =>
-    new ZodObject({
+  }
+
+  strip(): ZodObject<T, ""strip"", Catchall> {
+    return new ZodObject({
-
-  passthrough = (): ZodObject<T, ""passthrough"", Catchall> =>
-    new ZodObject({
+  }
+
+  passthrough(): ZodObject<T, ""passthrough"", Catchall> {
+    return new ZodObject({
+  }
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
-  };
+  }
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
-  ) => //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> {
-  };
-
-  catchall = <Index extends ZodTypeAny>(
+  }
+
+  catchall<Index extends ZodTypeAny>(
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  pick<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  omit<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  required = (): ZodObject<
+  }
+
+  required(): ZodObject<
-  > => {
+  > {
-  };
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  }
+
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  args = <Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
+    });
+  }
+
+  returns<NewReturnType extends ZodType<any, any>>(
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  }
+
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
-  };
-
-  strictImplement = (
+  }
+
+  strictImplement(
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
-  };
+  }
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
-  parse: (data: unknown, params?: Partial<ParseParamsNoData>) => Output = (
-    data,
-    params
-  ) => {
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
+  parse(data: unknown, params?: Partial<ParseParamsNoData>): Output {
-  };
-
-  safeParse: (
+  }
+
+  safeParse(
-  ) =>
+  ):
-    | { success: false; error: ZodError<Input> } = (data, params) => {
+    | { success: false; error: ZodError<Input> } {
-    return handleResult(ctx, result, params?.parentError);
-  };
-
-  parseAsync: (
-    x: unknown,
+    return handleResult(ctx, result);
+  }
+
+  async parseAsync(
+    data: unknown,
-  ) => Promise<Output> = async (data, params) => {
+  ): Promise<Output> {
-  };
-
-  safeParseAsync: (
-    x: unknown,
+  }
+
+  async safeParseAsync(
+    data: unknown,
-  ) => Promise<
+  ): Promise<
-  > = async (data, params) => {
+  > {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
-  };
+    return handleResult(ctx, result);
+  }
-  is: never;
+  is!: never;
-  check: never;
-
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  check!: never;
+
+  refine<Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ): ZodEffects<this> {
-  };
-
-  refinement: <This extends this = this>(
+  }
+
+  refinement(
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ): ZodEffects<this> {
-  };
-
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  }
+
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
-
-  array: () => ZodArray<this> = () => ZodArray.create(this);
-
-  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+  optional(): ZodOptional<this> {
+    return ZodOptional.create(this) as any;
+  }
+  nullable(): ZodNullable<this> {
+    return ZodNullable.create(this) as any;
+  }
+  nullish(): ZodNullable<ZodOptional<this>> {
+    return this.optional().nullable();
+  }
+  array(): ZodArray<this> {
+    return ZodArray.create(this);
+  }
+  promise(): ZodPromise<this> {
+    return ZodPromise.create(this);
+  }
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-  isOptional: () => boolean = () => this.safeParse(undefined).success;
-  isNullable: () => boolean = () => this.safeParse(null).success;
+  isOptional(): boolean {
+    return this.safeParse(undefined).success;
+  }
+  isNullable(): boolean {
+    return this.safeParse(null).success;
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  email = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
+  _addCheck(check: ZodStringCheck) {
+    return new ZodString({
-      checks: [
-        ...this._def.checks,
-        { kind: ""email"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  url = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""url"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  uuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""uuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  cuid = (message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""cuid"", ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
-      ],
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodString({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  email(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""email"", ...errorUtil.errToObj(message) });
+  }
+  url(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""url"", ...errorUtil.errToObj(message) });
+  }
+  uuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""uuid"", ...errorUtil.errToObj(message) });
+  }
+  cuid(message?: errorUtil.ErrMessage) {
+    return this._addCheck({ kind: ""cuid"", ...errorUtil.errToObj(message) });
+  }
+  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""regex"",
+      regex: regex,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  min(minLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: minLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: maxLength,
+      ...errorUtil.errToObj(message),
+    });
+  }
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.not_multiple_of,
-            multipleOf: check.value,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
-  gte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  gte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, true, errorUtil.toString(message));
+  }
-  gt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""min"", value, false, errorUtil.toString(message));
-
-  lte = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  gt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""min"", value, false, errorUtil.toString(message));
+  }
+
+  lte(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, true, errorUtil.toString(message));
+  }
-  lt = (value: number, message?: errorUtil.ErrMessage) =>
-    this.setLimit(""max"", value, false, errorUtil.toString(message));
-
-  protected setLimit = (
+  lt(value: number, message?: errorUtil.ErrMessage) {
+    return this.setLimit(""max"", value, false, errorUtil.toString(message));
+  }
+
+  protected setLimit(
-  ) =>
-    new ZodNumber({
+  ) {
+    return new ZodNumber({
-
-  int = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
+  }
+
+  _addCheck(check: ZodNumberCheck) {
+    return new ZodNumber({
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""int"",
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  positive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  negative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: false,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonpositive = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""max"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  nonnegative = (message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""min"",
-          value: 0,
-          inclusive: true,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
-
-  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      checks: [
-        ...this._def.checks,
-        {
-          kind: ""multipleOf"",
-          value: value,
-          message: errorUtil.toString(message),
-        },
-      ],
-    });
+      checks: [...this._def.checks, check],
+    });
+  }
+
+  int(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""int"",
+      message: errorUtil.toString(message),
+    });
+  }
+
+  positive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  negative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: false,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonpositive(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""max"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  nonnegative(message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""min"",
+      value: 0,
+      inclusive: true,
+      message: errorUtil.toString(message),
+    });
+  }
+
+  multipleOf(value: number, message?: errorUtil.ErrMessage) {
+    return this._addCheck({
+      kind: ""multipleOf"",
+      value: value,
+      message: errorUtil.toString(message),
+    });
+  }
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  min = (minLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  min(minLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage): this =>
-    new ZodArray({
+  }
+
+  max(maxLength: number, message?: errorUtil.ErrMessage): this {
+    return new ZodArray({
-
-  length = (len: number, message?: errorUtil.ErrMessage): this =>
-    this.min(len, message).max(len, message) as any;
-
-  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
-    message?: any
-  ) => {
+  }
+
+  length(len: number, message?: errorUtil.ErrMessage): this {
+    return this.min(len, message).max(len, message) as any;
+  }
+
+  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, ""atleastone""> {
-  };
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  }
+
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  strict = (): ZodObject<T, ""strict"", Catchall> =>
-    new ZodObject({
+  strict(): ZodObject<T, ""strict"", Catchall> {
+    return new ZodObject({
-
-  strip = (): ZodObject<T, ""strip"", Catchall> =>
-    new ZodObject({
+  }
+
+  strip(): ZodObject<T, ""strip"", Catchall> {
+    return new ZodObject({
-
-  passthrough = (): ZodObject<T, ""passthrough"", Catchall> =>
-    new ZodObject({
+  }
+
+  passthrough(): ZodObject<T, ""passthrough"", Catchall> {
+    return new ZodObject({
+  }
-  setKey = <Key extends string, Schema extends ZodTypeAny>(
+  setKey<Key extends string, Schema extends ZodTypeAny>(
-  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> => {
+  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
-  };
+  }
-  merge: <Incoming extends AnyZodObject>(
+  merge<Incoming extends AnyZodObject>(
-  ) => //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
-  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    merging
-  ) => {
+  ): //ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> {
-  };
-
-  catchall = <Index extends ZodTypeAny>(
+  }
+
+  catchall<Index extends ZodTypeAny>(
-  ): ZodObject<T, UnknownKeys, Index> => {
+  ): ZodObject<T, UnknownKeys, Index> {
-  };
-
-  pick = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  pick<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  omit = <Mask extends { [k in keyof T]?: true }>(
+  }
+
+  omit<Mask extends { [k in keyof T]?: true }>(
-  > => {
+  > {
-  };
-
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  }
+
+  deepPartial(): partialUtil.DeepPartial<this> {
+    return deepPartialify(this) as any;
+  }
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
-
-  required = (): ZodObject<
+  }
+
+  required(): ZodObject<
-  > => {
+  > {
-  };
-
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  }
+
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  args = <Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
+  args<Items extends Parameters<typeof ZodTuple[""create""]>[0]>(
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
-      args: ZodTuple.create(items),
-    });
-  };
-
-  returns = <NewReturnType extends ZodType<any, any>>(
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
+    });
+  }
+
+  returns<NewReturnType extends ZodType<any, any>>(
-  ): ZodFunction<Args, NewReturnType> => {
+  ): ZodFunction<Args, NewReturnType> {
-  };
-
-  implement = <F extends InnerTypeOfFunction<Args, Returns>>(func: F): F => {
+  }
+
+  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
-  };
-
-  strictImplement = (
+  }
+
+  strictImplement(
-  ): InnerTypeOfFunction<Args, Returns> => {
+  ): InnerTypeOfFunction<Args, Returns> {
-  };
+  }
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),"
colinhacks_zod,1afab958a2691b6e837244b9f75c06d3441e9fa6,Merge branch 'ts4.4' of git://github.com/wojpawlik/zod into wojpawlik-ts4.4,deno/lib/types.ts,"+  get element() {
+    return this._def.valueType;
+  }
+","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;
+  get element() {
+    return this._def.valueType;
+  }
+"
colinhacks_zod,1afab958a2691b6e837244b9f75c06d3441e9fa6,Merge branch 'ts4.4' of git://github.com/wojpawlik/zod into wojpawlik-ts4.4,src/types.ts,"+  get element() {
+    return this._def.valueType;
+  }
+","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;","-  is: never;
+  is!: never;
-  check: never;
+  check!: never;
+  get element() {
+    return this._def.valueType;
+  }
+"
colinhacks_zod,cb151aa8f2a32bbbde4ae5965f02d35b0dad0527,Updated error map. Merged partial overload.,deno/lib/__tests__/record.test.ts,"+const recordWithEnumKeys = z.record(z.enum([""Tuna"", ""Salmon""]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal(""Tuna""), z.literal(""Salmon"")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f3;
+
+test(""key schema"", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result1).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result2).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+});","+
+test(""record element"", () => {
+  expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+});","+const recordWithEnumKeys = z.record(z.enum([""Tuna"", ""Salmon""]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal(""Tuna""), z.literal(""Salmon"")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f3;
+
+test(""key schema"", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result1).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result2).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+});
+
+// test(""record element"", () => {
+//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+// });"
colinhacks_zod,cb151aa8f2a32bbbde4ae5965f02d35b0dad0527,Updated error map. Merged partial overload.,deno/lib/types.ts,"-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> => {
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  }
+
+  get element() {
+    return this._def.valueType;
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  get element() {
+    return this._def.valueType;
+  }
+
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> => {
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),"
colinhacks_zod,cb151aa8f2a32bbbde4ae5965f02d35b0dad0527,Updated error map. Merged partial overload.,package.json,"-  ""version"": ""3.8.1"",
+  ""version"": ""3.8.2"",
-    ""typescript"": ""4.3.5""
+    ""typescript"": ""4.1""","-  ""version"": ""3.8.1"",
+  ""version"": ""3.8.2"",
-    ""typescript"": ""4.3.5""
+    ""typescript"": ""4.3""","-  ""version"": ""3.8.1"",
+  ""version"": ""3.8.2"",
-    ""typescript"": ""4.3.5""
+    ""typescript"": ""4.3"""
colinhacks_zod,cb151aa8f2a32bbbde4ae5965f02d35b0dad0527,Updated error map. Merged partial overload.,src/__tests__/record.test.ts,"+const recordWithEnumKeys = z.record(z.enum([""Tuna"", ""Salmon""]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal(""Tuna""), z.literal(""Salmon"")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f3;
+
+test(""key schema"", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result1).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result2).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+});","+
+test(""record element"", () => {
+  expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+});","+const recordWithEnumKeys = z.record(z.enum([""Tuna"", ""Salmon""]), z.string());
+type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;
+
+const recordWithLiteralKeys = z.record(
+  z.union([z.literal(""Tuna""), z.literal(""Salmon"")]),
+  z.string()
+);
+type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;
+
+
+  const f2: util.AssertEqual<
+    recordWithEnumKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f2;
+  const f3: util.AssertEqual<
+    recordWithLiteralKeys,
+    Record<""Tuna"" | ""Salmon"", string>
+  > = true;
+  f3;
+
+test(""key schema"", () => {
+  const result1 = recordWithEnumKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result1).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  const result2 = recordWithLiteralKeys.parse({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+  expect(result2).toEqual({
+    Tuna: ""asdf"",
+    Salmon: ""asdf"",
+  });
+
+  expect(() =>
+    recordWithEnumKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+
+  expect(() =>
+    recordWithLiteralKeys.parse({
+      Tuna: ""asdf"",
+      Salmon: ""asdf"",
+
+      Trout: ""asdf"",
+    })
+  ).toThrow();
+});
+
+// test(""record element"", () => {
+//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
+// });"
colinhacks_zod,cb151aa8f2a32bbbde4ae5965f02d35b0dad0527,Updated error map. Merged partial overload.,src/types.ts,"-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> => {
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
+  }
+
+  get element() {
+    return this._def.valueType;
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
-  overrideErrorMap,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+
+type RawCreateParams =
+  | {
+      errorMap?: ZodErrorMap;
+      invalid_type_error?: string;
+      required_error?: string;
+    }
+  | undefined;
+type ProcessedCreateParams = { errorMap?: ZodErrorMap };
+function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
+  if (!params) return {};
+  if (params.errorMap && (params.invalid_type_error || params.required_error)) {
+    throw new Error(
+      `Can't use ""invalid"" or ""required"" in conjunction with custom error map.`
+    );
+  }
+  if (params.errorMap) return { errorMap: params.errorMap };
+  const customMap: ZodErrorMap = (iss, ctx) => {
+    if (iss.code !== ""invalid_type"") return { message: ctx.defaultError };
+    if (typeof ctx.data === ""undefined"" && params.required_error)
+      return { message: params.required_error };
+    if (params.invalid_type_error)
+      return { message: params.invalid_type_error };
+    return { message: ctx.defaultError };
+  };
+  return { errorMap: customMap };
+}
+  _addIssue(ctx: ParseContext, issueData: IssueData, params: { data: any }) {
+    ctx.addIssue(params.data, issueData, {
+      schemaErrorMap: this._def.errorMap,
+    });
+  }
+
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    // if (isAsync(result)) {
+    //   return result;
+    // }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.string,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""string"",
-            inclusive: true,
-            message: check.message,
-            // ...errorUtil.errToObj(this._def.maxLength.message),
-          });
+
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""string"",
+              inclusive: true,
+              message: check.message,
+              // ...errorUtil.errToObj(this._def.maxLength.message),
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""email"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""email"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""uuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""uuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""cuid"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""cuid"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""url"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""url"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            validation: ""regex"",
-            code: ZodIssueCode.invalid_string,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              validation: ""regex"",
+              code: ZodIssueCode.invalid_string,
+              message: check.message,
+            },
+            { data }
+          );
-  static create = (): ZodString => {
+  static create = (params?: RawCreateParams): ZodString => {
+      ...processCreateParams(params),
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        },
+        { data }
+      );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ""integer"",
-            received: ""float"",
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.invalid_type,
+              expected: ""integer"",
+              received: ""float"",
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_small,
-            minimum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_small,
+              minimum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
-          ctx.addIssue(data, {
-            code: ZodIssueCode.too_big,
-            maximum: check.value,
-            type: ""number"",
-            inclusive: check.inclusive,
-            message: check.message,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.too_big,
+              maximum: check.value,
+              type: ""number"",
+              inclusive: check.inclusive,
+              message: check.message,
+            },
+            { data }
+          );
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.not_multiple_of,
+              multipleOf: check.value,
+              message: check.message,
+            },
+            { data }
+          );
+        }
+      } else {
+        util.assertNever(check);
-  static create = (): ZodNumber => {
+  static create = (params?: RawCreateParams): ZodNumber => {
+      ...processCreateParams(params),
+      ...processCreateParams(params),
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.bigint,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBigInt => {
-    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
+  static create = (params?: RawCreateParams): ZodBigInt => {
+    return new ZodBigInt({
+      typeName: ZodFirstPartyTypeKind.ZodBigInt,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.boolean,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodBoolean => {
-    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
+  static create = (params?: RawCreateParams): ZodBoolean => {
+    return new ZodBoolean({
+      typeName: ZodFirstPartyTypeKind.ZodBoolean,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.date,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_date,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_date,
+        },
+        { data }
+      );
-  static create = (): ZodDate => {
-    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
+  static create = (params?: RawCreateParams): ZodDate => {
+    return new ZodDate({
+      typeName: ZodFirstPartyTypeKind.ZodDate,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.undefined,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        },
+        { data }
+      );
-
-  static create = (): ZodUndefined => {
-    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
+  params?: RawCreateParams;
+
+  static create = (params?: RawCreateParams): ZodUndefined => {
+    return new ZodUndefined({
+      typeName: ZodFirstPartyTypeKind.ZodUndefined,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.null,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodNull => {
-    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
+  static create = (params?: RawCreateParams): ZodNull => {
+    return new ZodNull({
+      typeName: ZodFirstPartyTypeKind.ZodNull,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodAny => {
-    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
+  static create = (params?: RawCreateParams): ZodAny => {
+    return new ZodAny({
+      typeName: ZodFirstPartyTypeKind.ZodAny,
+      ...processCreateParams(params),
+    });
-  static create = (): ZodUnknown => {
-    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
+  static create = (params?: RawCreateParams): ZodUnknown => {
+    return new ZodUnknown({
+      typeName: ZodFirstPartyTypeKind.ZodUnknown,
+      ...processCreateParams(params),
+    });
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.never,
-      received: parsedType,
-    });
+    this._addIssue(
+      ctx,
+      {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      },
+      { data }
+    );
-  static create = (): ZodNever => {
-    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
+  static create = (params?: RawCreateParams): ZodNever => {
+    return new ZodNever({
+      typeName: ZodFirstPartyTypeKind.ZodNever,
+      ...processCreateParams(params),
+    });
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.void,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        },
+        { data }
+      );
-  static create = (): ZodVoid => {
-    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  static create = (params?: RawCreateParams): ZodVoid => {
+    return new ZodVoid({
+      typeName: ZodFirstPartyTypeKind.ZodVoid,
+      ...processCreateParams(params),
+    });
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_small,
+            minimum: def.minLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.minLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.too_big,
+            maximum: def.maxLength.value,
+            type: ""array"",
+            inclusive: true,
+            message: def.maxLength.message,
+          },
+          { data }
+        );
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-  static create = <T extends ZodTypeAny>(schema: T): ZodArray<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodArray<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-          ctx.addIssue(data, {
-            code: ZodIssueCode.unrecognized_keys,
-            keys: extraKeys,
-          });
+          this._addIssue(
+            ctx,
+            {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            },
+            { data }
+          );
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+  static create = <T extends ZodRawShape>(
+    shape: T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-    shape: T
+    shape: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends ZodRawShape>(
+    shape: () => T,
+    params?: RawCreateParams
+  ): ZodObject<T> => {
+      ...processCreateParams(params),
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_union,
-          unionErrors,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_union,
+            unionErrors,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    types: T
+    types: T,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-        ctx.addIssue(data, {
-          code: ZodIssueCode.invalid_intersection_types,
-        });
+        this._addIssue(
+          ctx,
+          {
+            code: ZodIssueCode.invalid_intersection_types,
+          },
+          { data }
+        );
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    right: U
+    right: U,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
-
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
-
-export interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems>
-  extends ZodTypeDef {
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
+export type OutputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...OutputTypeOfTuple<T>, ...Rest[""_output""][]]
+  : OutputTypeOfTuple<T>;
+
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+export type InputTypeOfTupleWithRest<
+  T extends ZodTupleItems | [],
+  Rest extends ZodTypeAny | null = null
+> = Rest extends ZodTypeAny
+  ? [...InputTypeOfTuple<T>, ...Rest[""_input""][]]
+  : InputTypeOfTuple<T>;
+
+export interface ZodTupleDef<
+  T extends ZodTupleItems | [] = ZodTupleItems,
+  Rest extends ZodTypeAny | null = null
+> extends ZodTypeDef {
+  rest: Rest;
-  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]]
-> extends ZodType<OutputTypeOfTuple<T>, ZodTupleDef<T>, InputTypeOfTuple<T>> {
+  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
+  Rest extends ZodTypeAny | null = null
+> extends ZodType<
+  OutputTypeOfTupleWithRest<T, Rest>,
+  ZodTupleDef<T, Rest>,
+  InputTypeOfTupleWithRest<T, Rest>
+> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.array,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        },
+        { data }
+      );
-    if (data.length > this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    const rest = this._def.rest;
+
+    if (!rest && data.length > this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_big,
+          maximum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    } else if (data.length < this._def.items.length) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: this._def.items.length,
-        inclusive: true,
-        type: ""array"",
-      });
+    }
+
+    if (data.length < this._def.items.length) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.too_small,
+          minimum: this._def.items.length,
+          inclusive: true,
+          type: ""array"",
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-    const parseResult: any[] = new Array(items.length);
+
+    const parseResult: any[] = new Array(data.length);
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (rest) {
+      const restData: any[] = data.slice(items.length);
+      restData.forEach((dataItem, _index) => {
+        const index = _index + items.length;
+        handleParsed(
+          index,
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
+        );
+      });
+    }
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
+  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
+    return new ZodTuple({
+      ...this._def,
+      rest,
+    });
+  }
+
-    schemas: T
-  ): ZodTuple<T> => {
+    schemas: T,
+    params?: RawCreateParams
+  ): ZodTuple<T, null> => {
+      rest: null,
+      ...processCreateParams(params),
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
-  Record<string, Value[""_output""]>,
-  ZodRecordDef<Value>,
-  Record<string, Value[""_input""]>
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Key extends KeySchema = ZodString,
+  Value extends ZodTypeAny = ZodTypeAny
+> extends ZodType<
+  Record<Key[""_output""], Value[""_output""]>,
+  ZodRecordDef<Key, Value>,
+  Record<Key[""_input""], Value[""_input""]>
+  get keySchema() {
+    return this._def.keyType;
+  }
+  get valueSchema() {
+    return this._def.valueType;
+  }
-  ): ParseReturnType<Record<string, any>> {
+  ): ParseReturnType<Record<any, any>> {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.object,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
+    const keyType = this._def.keyType;
-      key: string,
-      parsedKey: ParseReturnType<any>
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
-      if (isOk(parsedKey)) {
-        parseResult[key] = parsedKey.value;
-      } else if (isInvalid(parsedKey)) {
+      if (isOk(parsedKey) && isOk(parsedValue)) {
+        parseResult[parsedKey.value] = parsedValue.value;
+      } else if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else {
-      } else {
-        tasks?.push(
-          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
-        );
-        key,
+        keyType._parse(ctx.stepInto(key), key, getParsedType(key)),
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
-    valueType: Value
-  ): ZodRecord<Value> => {
+  get element() {
+    return this._def.valueType;
+  }
+
+  static create<Value extends ZodTypeAny>(
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<ZodString, Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
+    keySchema: Keys,
+    valueType: Value,
+    params?: RawCreateParams
+  ): ZodRecord<Keys, Value>;
+  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
+    if (second instanceof ZodType) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+        ...processCreateParams(third),
+      });
+    }
+
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-    });
-  };
+      ...processCreateParams(second),
+    });
+  }
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.map,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.set,
-        received: parsedType,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        },
+        { data }
+      );
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-    valueType: Value
+    valueType: Value,
+    params?: RawCreateParams
+      ...processCreateParams(params),
-  Args extends ZodTuple<any> = ZodTuple<any>,
+  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-  Args extends ZodTuple<any>,
+  Args extends ZodTuple<any, any>,
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.function,
-        received: parsedType,
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        },
+        { data }
+      );
+
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: args,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_arguments,
+          argumentsError: error,
+        },
-
-      return INVALID;
-    }
-
-    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_arguments,
-        argumentsError: error,
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue({
+        data: returns,
+        path: pathToArray(ctx.path),
+        errorMaps: [ctx.errorMap],
+        issueData: {
+          code: ZodIssueCode.invalid_return_type,
+          returnTypeError: error,
+        },
-    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
-        code: ZodIssueCode.invalid_return_type,
-        returnTypeError: error,
-      });
-    }
-
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-  ): ZodFunction<ZodTuple<Items>, Returns> => {
+  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> => {
-      args: ZodTuple.create(items),
+      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
-    T extends ZodTuple<any> = ZodTuple<[]>,
+    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
-    returns?: U
+    returns?: U,
+    params?: RawCreateParams
-      args: args || ZodTuple.create([]),
+      args: (args
+        ? args.rest(ZodUnknown.create())
+        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(getter: () => T): ZodLazy<T> => {
+  static create = <T extends ZodTypeAny>(
+    getter: () => T,
+    params?: RawCreateParams
+  ): ZodLazy<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: this._def.value as any,
-        received: data,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: this._def.value as any,
+          received: data,
+        },
+        { data }
+      );
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends Primitive>(
+    value: T,
+    params?: RawCreateParams
+  ): ZodLiteral<T> => {
+      ...processCreateParams(params),
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: this._def.values,
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: this._def.values,
+        },
+        { data }
+      );
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_enum_value,
-        options: util.objectValues(nativeEnumValues),
-      });
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        },
+        { data }
+      );
-  static create = <T extends EnumLike>(values: T): ZodNativeEnum<T> => {
+  static create = <T extends EnumLike>(
+    values: T,
+    params?: RawCreateParams
+  ): ZodNativeEnum<T> => {
+      ...processCreateParams(params),
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
-      ctx.addIssue(data, {
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.promise,
-        received: parsedType,
-      });
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
+      this._addIssue(
+        ctx,
+        {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        },
+        { data }
+      );
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-  static create = <T extends ZodTypeAny>(schema: T): ZodPromise<T> => {
+  static create = <T extends ZodTypeAny>(
+    schema: T,
+    params?: RawCreateParams
+  ): ZodPromise<T> => {
+      ...processCreateParams(params),
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const _addIssue = (arg: IssueData) => {
+        // don't abort early on refinement issues
+        // invalid = true;
+        this._addIssue(ctx, arg, { data });
+      };
+      const checkCtx: RefinementCtx = {
+        addIssue: _addIssue,
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-    });
-
-    return newTx;
+      effect,
+      ...processCreateParams(params),
+    });
-    schema: I
+    schema: I,
+    params?: RawCreateParams
-    const newTx = new ZodEffects({
+    return new ZodEffects({
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },
-    });
-
-    return newTx;
+      ...processCreateParams(params),
+    });
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodNullable<T> => {
+      ...processCreateParams(params),
-  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+  static create = <T extends ZodTypeAny>(
+    type: T,
+    params?: RawCreateParams
+  ): ZodOptional<T> => {
+      ...processCreateParams(params),"
colinhacks_zod,e107306b1c09ed9c0d3e619569b5c53ddedeb009,FMC,deno/lib/types.ts,"-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
+  }","+  get element() {
+    return this._def.valueType;
+  }
+
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");","-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
+  }
+  }
+
+  get element() {
+    return this._def.valueType;
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");"
colinhacks_zod,e107306b1c09ed9c0d3e619569b5c53ddedeb009,FMC,src/types.ts,"-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
+  }","+  get element() {
+    return this._def.valueType;
+  }
+
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");","-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
-
-  partialBy = <Mask extends { [k in keyof T]?: true }>(
-    mask: Mask
-  ): ZodObject<
-    objectUtil.noNever<
-      {
-        [k in keyof T]: k extends keyof Mask
-          ? ReturnType<T[k][""optional""]>
-          : T[k];
-      }
-    >,
-    UnknownKeys,
-    Catchall
-  > => {
-    const newShape: any = {};
-    util.objectKeys(this.shape).map((key) => {
-      if (util.objectKeys(mask).indexOf(key) === -1) {
-        newShape[key] = this.shape[key];
-      } else {
-        newShape[key] = this.shape[key].optional();
-      }
-    });
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
-  };
+  }
+  }
+
+  get element() {
+    return this._def.valueType;
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffects cannot be nested."");"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,deno/lib/ZodError.ts,"+  ""not_multiple_of"",
+}
+
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+  | ZodNotMultipleOfIssue
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${error.multipleOf}`;
+      break;","-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
+export type MakeErrorData = IssueData;","+  ""not_multiple_of"",
+}
+
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+  | ZodNotMultipleOfIssue
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
+export type MakeErrorData = IssueData;
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${error.multipleOf}`;
+      break;"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,deno/lib/helpers/parseUtil.ts,"-  overrideErrorMap,
-  ZodError,
-  parentError: ZodError;
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-","-import { PseudoPromise } from ""../PseudoPromise.ts"";
-import {
-  defaultErrorMap,
-  MakeErrorData,
-  overrideErrorMap,
-  ZodError,
-  ZodErrorMap,
-  ZodIssue,
-} from ""../ZodError.ts"";
+import { defaultErrorMap, IssueData, ZodErrorMap, ZodIssue } from ""../ZodError.ts"";
-  errorData: MakeErrorData
+  errorData: IssueData
-  data: any;
+  // data: any;
-  parentError: ZodError;
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap: ZodErrorMap;
+  readonly async: boolean;
+}
+
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
-  }
-
-  addIssue(data: any, errorData: MakeErrorData): void {
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
+  }
+
+  addIssue(data: any, errorData: IssueData): void {
-      this.params.errorMap,
+      this.errorMap,
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;","-import { PseudoPromise } from ""../PseudoPromise.ts"";
-import {
-  defaultErrorMap,
-  MakeErrorData,
-  overrideErrorMap,
-  ZodError,
-  ZodErrorMap,
-  ZodIssue,
-} from ""../ZodError.ts"";
+import { defaultErrorMap, IssueData, ZodErrorMap, ZodIssue } from ""../ZodError.ts"";
-  errorData: MakeErrorData
+  errorData: IssueData
-  data: any;
+  // data: any;
-  parentError: ZodError;
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap: ZodErrorMap;
+  readonly async: boolean;
+}
+
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
-  }
-
-  addIssue(data: any, errorData: MakeErrorData): void {
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
+  }
+
+  addIssue(data: any, errorData: IssueData): void {
-      this.params.errorMap,
+      this.errorMap,
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,deno/lib/types.ts,"-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-    parentError?.addIssues(ctx.issues);
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
+  IssueData,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
-
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap || overrideErrorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      return result;
+    }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
+
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+      } else {
+        invalid = true;
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(args, pathToArray(ctx.path), ctx.errorMap, {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.errorMap, {
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const checkCtx: RefinementCtx = {
+        addIssue: function (arg: IssueData) {
+          // don't abort early on refinement issues
+          // invalid = true;
+          ctx.addIssue(data, arg);
+        },
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>
+      effect,
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise.ts"";
-  MakeErrorData,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap || overrideErrorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      return result;
+    }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
+
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+      } else {
+        invalid = true;
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(args, pathToArray(ctx.path), ctx.errorMap, {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.errorMap, {
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const checkCtx: RefinementCtx = {
+        addIssue: function (arg: IssueData) {
+          // don't abort early on refinement issues
+          // invalid = true;
+          ctx.addIssue(data, arg);
+        },
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>
+      effect,
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,src/ZodError.ts,"+  ""not_multiple_of"",
+}
+
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+  | ZodNotMultipleOfIssue
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${error.multipleOf}`;
+      break;","-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
+export type MakeErrorData = IssueData;","+  ""not_multiple_of"",
+}
+
+export interface ZodNotMultipleOfIssue extends ZodIssueBase {
+  code: typeof ZodIssueCode.not_multiple_of;
+  multipleOf: number;
+  | ZodNotMultipleOfIssue
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
+export type IssueData = stripPath<ZodIssueOptionalMessage> & {
+export type MakeErrorData = IssueData;
+    case ZodIssueCode.not_multiple_of:
+      message = `Should be multiple of ${error.multipleOf}`;
+      break;"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,src/helpers/parseUtil.ts,"-  overrideErrorMap,
-  ZodError,
-  parentError: ZodError;
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-","-import { PseudoPromise } from ""../PseudoPromise"";
-import {
-  defaultErrorMap,
-  MakeErrorData,
-  overrideErrorMap,
-  ZodError,
-  ZodErrorMap,
-  ZodIssue,
-} from ""../ZodError"";
+import { defaultErrorMap, IssueData, ZodErrorMap, ZodIssue } from ""../ZodError"";
-  errorData: MakeErrorData
+  errorData: IssueData
-  data: any;
+  // data: any;
-  parentError: ZodError;
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap: ZodErrorMap;
+  readonly async: boolean;
+}
+
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
-  }
-
-  addIssue(data: any, errorData: MakeErrorData): void {
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
+  }
+
+  addIssue(data: any, errorData: IssueData): void {
-      this.params.errorMap,
+      this.errorMap,
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;","-import { PseudoPromise } from ""../PseudoPromise"";
-import {
-  defaultErrorMap,
-  MakeErrorData,
-  overrideErrorMap,
-  ZodError,
-  ZodErrorMap,
-  ZodIssue,
-} from ""../ZodError"";
+import { defaultErrorMap, IssueData, ZodErrorMap, ZodIssue } from ""../ZodError"";
-  errorData: MakeErrorData
+  errorData: IssueData
-  data: any;
+  // data: any;
-  parentError: ZodError;
+interface ParseContextDef {
+  readonly path: ParsePath;
+  readonly issues: ZodIssue[];
+  readonly errorMap: ZodErrorMap;
+  readonly async: boolean;
+}
+
-  constructor(
-    public readonly path: ParsePath,
-    public readonly issues: ZodIssue[],
-    public readonly params: ParseContextParameters
-  ) {}
+  // public readonly path: ParsePath;
+  // public readonly issues: ZodIssue[];
+  // public readonly errorMap: ZodErrorMap;
+  public readonly def: ParseContextDef;
+
+  constructor(def: ParseContextDef) {
+    this.def = def;
+  }
+  get path() {
+    return this.def.path;
+  }
+  get issues() {
+    return this.def.issues;
+  }
+  get errorMap() {
+    return this.def.errorMap;
+  }
+  get async() {
+    return this.def.async;
+  }
-    return new ParseContext(
-      this.path === null
-        ? { parent: null, count: 1, component }
-        : { parent: this.path, count: this.path.count + 1, component },
-      this.issues,
-      this.params
-    );
-  }
-
-  addIssue(data: any, errorData: MakeErrorData): void {
+    return new ParseContext({
+      ...this.def,
+      path:
+        this.path === null
+          ? { parent: null, count: 1, component }
+          : { parent: this.path, count: this.path.count + 1, component },
+    });
+  }
+
+  addIssue(data: any, errorData: IssueData): void {
-      this.params.errorMap,
+      this.errorMap,
-export const createRootContext = (
-  params: Partial<ParseParamsNoData>
-): ParseContext =>
-  new ParseContext(EMPTY_PATH, [], {
-    async: params.async ?? false,
-    errorMap: params.errorMap || overrideErrorMap,
-  });
-
-export type ASYNC<T> = PseudoPromise<T>;
-export const ASYNC = <T>(promise: Promise<T>): ASYNC<T> =>
-  new PseudoPromise<T>(promise);
-
+export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
-  | ASYNC<SyncParseReturnType<T>>;
+  | AsyncParseReturnType<T>;
-): x is ASYNC<SyncParseReturnType<T>> => x instanceof PseudoPromise;
+): x is AsyncParseReturnType<T> => x instanceof Promise;"
colinhacks_zod,1e3553bea0ccfac5fee6d2a4f627cabc6d45ea31,WIP,src/types.ts,"-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-    parentError?.addIssues(ctx.issues);
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
+  IssueData,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
-
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap || overrideErrorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      return result;
+    }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
+
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+      } else {
+        invalid = true;
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(args, pathToArray(ctx.path), ctx.errorMap, {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.errorMap, {
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const checkCtx: RefinementCtx = {
+        addIssue: function (arg: IssueData) {
+          // don't abort early on refinement issues
+          // invalid = true;
+          ctx.addIssue(data, arg);
+        },
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>
+      effect,
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },","-  ASYNC,
+  AsyncParseReturnType,
-import { PseudoPromise } from ""./PseudoPromise"";
-  MakeErrorData,
+  IssueData,
+  ZodErrorMap,
-  addIssue: (arg: MakeErrorData) => void;
+  addIssue: (arg: IssueData) => void;
-  issueFound: boolean;
-export interface ZodTypeDef {}
-
-type AsyncTasks = Promise<void>[] | null;
-const createTasks = (ctx: ParseContext): AsyncTasks =>
-  ctx.params.async ? [] : null;
+export interface ZodTypeDef {
+  errorMap?: ZodErrorMap;
+}
+
+// function customErrorMap(arg: string | ZodErrorMap | undefined) {
+//   if (typeof arg === ""string"") {
+//     const map: ZodErrorMap = (iss, ctx) => {
+//       if (iss.code === ZodIssueCode.invalid_type) {
+//         return { message: arg };
+//       }
+//       return { message: ctx.defaultError };
+//     };
+//   }
+// }
-  new ParseContext(pathFromArray(params.path || []), [], {
+  new ParseContext({
+    path: pathFromArray(params.path || []),
+    issues: [],
+    errorMap: params.errorMap || overrideErrorMap,
-    errorMap: params.errorMap || overrideErrorMap,
-  result: SyncParseReturnType<Output>,
-  parentError: ZodError | undefined
+  result: SyncParseReturnType<Output>
-  if (isOk(result)) {
+  if (isOk(result) && !ctx.issues.length) {
-    parentError?.addIssues(ctx.issues);
+  // if (isOk(result)) {
+  //   return { success: true, data: result.value };
+  // } else {
+  //   const error = new ZodError(ctx.issues);
+  //   return { success: false, error };
+  // }
+  _parseAsync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): AsyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      return result;
+    }
+
+    return Promise.resolve(result);
+  }
+
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-    return handleResult(ctx, result, params?.parentError);
+    return handleResult(ctx, result);
-  refine: <Func extends (arg: Output) => any, This extends this = this>(
+  refine: <Func extends (arg: Output) => any>(
-  ) => ZodEffectsType<This> = (check, message) => {
+  ) => ZodEffects<this> = (check, message) => {
-  refinement: <This extends this = this>(
+  refinement: (
-    refinementData:
-      | MakeErrorData
-      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)
-  ) => ZodEffectsType<This> = (check, refinementData) => {
+    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
+  ) => ZodEffects<this> = (check, refinementData) => {
-  _refinement<This extends this>(
-    refinement: InternalCheck<Output>[""refinement""]
-  ): ZodEffectsType<This> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""refinement"", refinement },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        typeName: ZodFirstPartyTypeKind.ZodEffects,
-        effects: [{ type: ""refinement"", refinement }],
-      }) as any;
-    }
-    return returnType;
+  _refinement(
+    refinement: RefinementEffect<Output>[""refinement""]
+  ): ZodEffects<this> {
+    // let returnType;
+    // if (this instanceof ZodEffects) {
+    //   returnType = new ZodEffects({
+    //     ...this._def,
+    //     effects: [
+    //       ...(this._def.effects || []),
+    //       { type: ""refinement"", refinement },
+    //     ],
+    //   }) as any;
+    // } else {
+    // returnType = new ZodEffects({
+    //   schema: this,
+    //   typeName: ZodFirstPartyTypeKind.ZodEffects,
+    //   effects: [{ type: ""refinement"", refinement }],
+    // }) as any;
+    // }
+    // return returnType;
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effect: { type: ""refinement"", refinement },
+    }) as any;
-  optional: <This extends this = this>() => ZodOptional<This> = () =>
-    ZodOptional.create(this) as any;
-  nullable: <This extends this = this>() => ZodNullable<This> = () =>
-    ZodNullable.create(this) as any;
-  nullish: <This extends this = this>() => ZodNullable<
-    ZodOptional<This>
-  > = () => this.optional().nullable();
+  optional: () => ZodOptional<this> = () => ZodOptional.create(this) as any;
+  nullable: () => ZodNullable<this> = () => ZodNullable.create(this) as any;
+  nullish: () => ZodNullable<ZodOptional<this>> = () =>
+    this.optional().nullable();
-      effects: [{ type: ""transform"", transform }],
+      effect: { type: ""transform"", transform },
-  default<This extends this = this>(
-    def: util.noUndefined<Input>
-  ): ZodDefault<This>;
-  default<This extends this = this>(
-    def: () => util.noUndefined<Input>
-  ): ZodDefault<This>;
+  default(def: util.noUndefined<Input>): ZodDefault<this>;
+  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
+
-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+
-const parseArray = <T>(
-  ctx: ParseContext,
-  data: any[],
-  parsedType: ZodParsedType,
-  def: ZodArrayDef<any>
-): ParseReturnType<T[]> => {
-  if (parsedType !== ZodParsedType.array) {
-    ctx.addIssue(data, {
-      code: ZodIssueCode.invalid_type,
-      expected: ZodParsedType.array,
-      received: parsedType,
-    });
-
-    return INVALID;
-  }
-
-  let invalid = false;
-  if (def.minLength !== null) {
-    if (data.length < def.minLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_small,
-        minimum: def.minLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.minLength.message,
-      });
-    }
-  }
-
-  if (def.maxLength !== null) {
-    if (data.length > def.maxLength.value) {
-      invalid = true;
-      ctx.addIssue(data, {
-        code: ZodIssueCode.too_big,
-        maximum: def.maxLength.value,
-        type: ""array"",
-        inclusive: true,
-        message: def.maxLength.message,
-      });
-    }
-  }
-
-  const tasks = createTasks(ctx);
-  const result: T[] = new Array(data.length);
-  const type = def.type;
-  const handleParsed = (
-    index: number,
-    parsedItem: ParseReturnType<T>
-  ): void => {
-    if (isOk(parsedItem)) {
-      result[index] = parsedItem.value;
-    } else if (isInvalid(parsedItem)) {
-      invalid = true;
-    } else {
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
-    }
-  };
-
-  data.forEach((item, index) => {
-    handleParsed(
-      index,
-      type._parse(ctx.stepInto(index), item, getParsedType(item))
-    );
-  });
-
-  if (tasks !== null && tasks.length > 0) {
-    return ASYNC(
-      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
-    );
-  } else {
-    return invalid ? INVALID : OK(result);
-  }
-};
-
-    data: any,
+    _data: any,
-    return parseArray(ctx, data, parsedType, this._def) as any;
+    // return parseArray(ctx, data, parsedType, this._def) as any;
+    const def = this._def;
+
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(_data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.array,
+        received: parsedType,
+      });
+
+      return INVALID;
+    }
+
+    const data: any[] = _data;
+
+    let invalid = false;
+    if (def.minLength !== null) {
+      if (data.length < def.minLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.minLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.minLength.message,
+        });
+      }
+    }
+
+    if (def.maxLength !== null) {
+      if (data.length > def.maxLength.value) {
+        invalid = true;
+        ctx.addIssue(data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.maxLength.value,
+          type: ""array"",
+          inclusive: true,
+          message: def.maxLength.message,
+        });
+      }
+    }
+
+    const tasks: Promise<any>[] = [];
+    const result: any = new Array(data.length);
+    const type = def.type;
+    const handleParsed = (
+      index: number,
+      parsedItem: ParseReturnType<T>
+    ): void => {
+      if (isOk(parsedItem)) {
+        result[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
+      }
+    };
+
+    data.forEach((item, index) => {
+      handleParsed(
+        index,
+        type._parse(ctx.stepInto(index), item, getParsedType(item))
+      );
+    });
+
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)));
+    } else {
+      return invalid ? INVALID : OK(result);
+    }
-    const tasks = createTasks(ctx);
+    const tasks: Promise<any>[] = [];
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() =>
-          invalid ? INVALID : OK(resultObject as Output)
-        )
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(resultObject as Output)
-  partial = (): ZodObject<
-    { [k in keyof T]: ReturnType<T[k][""optional""]> },
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+  };
+
+  partial(): ZodObject<
+    { [k in keyof T]: ZodOptional<T[k]> },
-  > => {
+  >;
+  partial<Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  >;
+  partial(mask?: any) {
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      newShape[key] = fieldSchema.isOptional()
-        ? fieldSchema
-        : fieldSchema.optional();
-    }
+    if (mask) {
+      // const newShape: any = {};
+      util.objectKeys(this.shape).map((key) => {
+        if (util.objectKeys(mask).indexOf(key) === -1) {
+          newShape[key] = this.shape[key];
+        } else {
+          newShape[key] = this.shape[key].optional();
+        }
+      });
+      return new ZodObject({
+        ...this._def,
+        shape: () => newShape,
+      }) as any;
+    } else {
+      for (const key in this.shape) {
+        const fieldSchema = this.shape[key];
+        newShape[key] = fieldSchema.optional();
+      }
+    }
+
-  };
-
-  deepPartial: () => partialUtil.DeepPartial<this> = () => {
-    return deepPartialify(this) as any;
-  };
+  }
-    if (ctx.params.async) {
+    if (ctx.async) {
-        () => new ParseContext(ctx.path, [], ctx.params)
+        () => new ParseContext({ ...ctx.def, issues: [] })
-      return PseudoPromise.all(
+      return Promise.all(
-        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const optionCtx = new ParseContext({ ...ctx.def, issues: [] });
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {
-    if (ctx.params.async) {
-      return PseudoPromise.all([
+    if (ctx.async) {
+      return Promise.all([
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-      } else if (isInvalid(parsedKey)) {
-        invalid = true;
-      } else if (isInvalid(parsedValue)) {
-        invalid = true;
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
+      } else {
+        invalid = true;
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+        tasks.push(
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+    if (ctx.async) {
+      return Promise.all(tasks).then(() =>
+        invalid ? INVALID : OK(parseResult)
-    const tasks = createTasks(ctx);
+    const tasks: Promise<unknown>[] = [];
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks.push(parsedItem.then((parsed) => handleParsed(parsed)));
-    if (tasks !== null && tasks.length > 0) {
-      return ASYNC(
-        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
-      );
+    if (ctx.async) {
+      return Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)));
-      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(args, pathToArray(ctx.path), ctx.errorMap, {
-      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.errorMap, {
-    const params = { errorMap: ctx.params.errorMap };
+    const params = { errorMap: ctx.errorMap };
-    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+    if (parsedType !== ZodParsedType.promise && ctx.async === false) {
-          errorMap: ctx.params.errorMap,
+          errorMap: ctx.errorMap,
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
-  ? T
-  : ZodEffects<T, T[""_output""]>;
-export type InternalCheck<T> = {
+
+export type RefinementEffect<T> = {
-export type Mod<T> = {
+export type TransformEffect<T> = {
-export type Effect<T> = InternalCheck<T> | Mod<T>;
+export type PreprocessEffect<T> = {
+  type: ""preprocess"";
+  transform: (arg: T) => any;
+};
+export type Effect<T> =
+  | RefinementEffect<T>
+  | TransformEffect<T>
+  | PreprocessEffect<T>;
-  preprocess?: Mod<any>;
-  effects?: Effect<any>[];
+  effect: Effect<any>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    const isSync = ctx.params.async === false;
-    const preprocess = this._def.preprocess;
-    const effects = this._def.effects || [];
-
-    let data = initialData;
-    let parsedType: ZodParsedType = initialParsedType;
-    if (preprocess) {
-      data = preprocess.transform(initialData);
-      parsedType = getParsedType(data);
-    }
-
-    const checkCtx: RefinementCtx = {
-      issueFound: false,
-      addIssue: function (arg: MakeErrorData) {
-        this.issueFound = true;
-        ctx.addIssue(data, arg);
-      },
-      get path() {
-        return pathToArray(ctx.path);
-      },
-    };
-
-    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
-
-    let invalid = false;
-    const applyEffect = (
-      acc: any,
-      effect: Effect<any>
-    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
-      switch (effect.type) {
-        case ""refinement"":
-          const result = effect.refinement(acc, checkCtx);
-          if (result instanceof Promise) {
-            if (isSync) {
-              throw new Error(
-                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-              );
-            } else {
-              return result.then((_res) => {
-                const issueFound = checkCtx.issueFound;
-                invalid = invalid || issueFound;
-                return acc;
-              });
-            }
-          } else {
-            const issueFound = checkCtx.issueFound;
-            invalid = invalid || issueFound;
-            return acc;
-          }
-        case ""transform"":
-          const transformed = effect.transform(acc);
-          if (transformed instanceof Promise && isSync) {
+    const isSync = ctx.async === false;
+    const effect = this._def.effect || null;
+    const data = initialData;
+    const parsedType: ZodParsedType = initialParsedType;
+
+    if (effect.type === ""preprocess"") {
+      const processed = effect.transform(initialData);
+
+      if (ctx.async) {
+        return Promise.resolve(processed).then((val) =>
+          this._def.schema._parseAsync(ctx, val, getParsedType(val))
+        );
+      } else {
+        const result = this._def.schema._parseSync(
+          ctx,
+          processed,
+          getParsedType(processed)
+        );
+        if (result instanceof Promise)
+          throw new Error(
+            ""Asynchronous preprocess step encountered during synchronous parse operation. Use .parseAsync instead.""
+          );
+        return result;
+      }
+    }
+
+    if (effect.type === ""refinement"") {
+      const invalid = false;
+
+      const executeRefinement = (
+        acc: any,
+        effect: RefinementEffect<any>
+      ): any => {
+        const result = effect.refinement(acc, checkCtx);
+        if (result instanceof Promise) {
+          if (isSync) {
-              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+              ""Async refinement encountered during synchronous parse operation. Use .parseAsync instead.""
-          return transformed;
-        default:
-          throw new Error(`Invalid effect type.`);
-      }
-    };
-
-    if (isSync) {
-      const base = this._def.schema._parseSync(ctx, data, parsedType);
-      if (isOk(base)) {
-        const result = effects.reduce(applyEffect, base.value);
+          return result.then(() => acc);
+        }
+        return acc;
+      };
+
+      const checkCtx: RefinementCtx = {
+        addIssue: function (arg: IssueData) {
+          // don't abort early on refinement issues
+          // invalid = true;
+          ctx.addIssue(data, arg);
+        },
+        get path() {
+          return pathToArray(ctx.path);
+        },
+      };
+
+      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = executeRefinement(base.value, effect);
-        return INVALID;
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((result) => {
+            if (isInvalid(result)) return INVALID;
+            return executeRefinement(result.value, effect);
+          })
+          .then((val) => (invalid ? INVALID : OK(val)));
-    } else {
-      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
-        const result = effects.reduce((acc, eff) => {
-          return acc instanceof Promise
-            ? acc.then((val) => applyEffect(val, eff))
-            : applyEffect(acc, eff);
-        }, base);
-        if (result instanceof Promise) {
-          return ASYNC(
-            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+    }
+
+    if (effect.type === ""transform"") {
+      const invalid = false;
+      const applyTransform = (acc: any, effect: TransformEffect<any>): any => {
+        const transformed = effect.transform(acc);
+        if (transformed instanceof Promise && isSync) {
+          throw new Error(
+            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
-        } else {
-          return invalid ? INVALID : OK(result);
+        return transformed;
-      const baseResult = this._def.schema._parse(ctx, data, parsedType);
-      if (isOk(baseResult)) {
-        return applyAsyncEffects(baseResult.value);
-      } else if (isInvalid(baseResult)) {
-        return INVALID;
+      if (isSync) {
+        const base = this._def.schema._parseSync(ctx, data, parsedType);
+        if (isInvalid(base)) return INVALID;
+        const result = applyTransform(base.value, effect);
+        return invalid ? INVALID : OK(result);
-        return ASYNC(
-          baseResult.promise.then((base) => {
+        return this._def.schema
+          ._parseAsync(ctx, data, parsedType)
+          .then((base) => {
-            const result = applyAsyncEffects(base.value);
-            return isAsync(result) ? result.promise : result;
+            return applyTransform(base.value, effect);
-        );
+          .then((val) => (invalid ? INVALID : OK(val)));
-  }
-
-  constructor(def: ZodEffectsDef<T>) {
-    super(def);
-    // if (def.schema instanceof ZodEffects) {
-    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
-    // }
+
+    util.assertNever(effect);
-    schema: I
+    schema: I,
+    effect: Effect<I[""_output""]>
+      effect,
-      preprocess: { type: ""transform"", transform: preprocess },
+      effect: { type: ""preprocess"", transform: preprocess },"
colinhacks_zod,405e33b0833682a8960bcfa1717276ce49fd0995,Merge branch 'fix-refine-inference' into no-pseudopromise,deno/lib/types.ts,"-import { PseudoPromise } from ""./PseudoPromise.ts"";
+// import { PseudoPromise } from ""./PseudoPromise"";
-  ): ASYNC<SyncParseReturnType<Output>> {
+  ): Promise<SyncParseReturnType<Output>> {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
+      tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks?.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      return PseudoPromise.all(
+      return Promise.all(
-      return PseudoPromise.all([
+      return Promise.all([
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks?.push(parsedItem.then((parsed) => handleParsed(parsed)));
-// type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any,any>
-//   ? T
-//   : ZodEffects<T, T[""_output""]>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-        baseResult.promise.then((base) => {
+        baseResult.then((base) => {
-          return isAsync(result) ? result.promise : result;
+          return isAsync(result) ? result : result;
-      //     baseResult.promise.then((base) => {
+      //     baseResult.then((base) => {
-      //       return isAsync(result) ? result.promise : result;
+      //       return isAsync(result) ? result : result;","-    let invalid = false;
+    const invalid = false;
-        invalid = true;
+        // don't abort early on refinement issues
+        // invalid = true;","-import { PseudoPromise } from ""./PseudoPromise.ts"";
+// import { PseudoPromise } from ""./PseudoPromise"";
-  ): ASYNC<SyncParseReturnType<Output>> {
+  ): Promise<SyncParseReturnType<Output>> {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
+      tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks?.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      return PseudoPromise.all(
+      return Promise.all(
-      return PseudoPromise.all([
+      return Promise.all([
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks?.push(parsedItem.then((parsed) => handleParsed(parsed)));
-// type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any,any>
-//   ? T
-//   : ZodEffects<T, T[""_output""]>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    let invalid = false;
+    const invalid = false;
-        invalid = true;
+        // don't abort early on refinement issues
+        // invalid = true;
-        baseResult.promise.then((base) => {
+        baseResult.then((base) => {
-          return isAsync(result) ? result.promise : result;
+          return isAsync(result) ? result : result;
-      //     baseResult.promise.then((base) => {
+      //     baseResult.then((base) => {
-      //       return isAsync(result) ? result.promise : result;
+      //       return isAsync(result) ? result : result;"
colinhacks_zod,405e33b0833682a8960bcfa1717276ce49fd0995,Merge branch 'fix-refine-inference' into no-pseudopromise,src/types.ts,"-import { PseudoPromise } from ""./PseudoPromise"";
+// import { PseudoPromise } from ""./PseudoPromise"";
-  ): ASYNC<SyncParseReturnType<Output>> {
+  ): Promise<SyncParseReturnType<Output>> {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
+      tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks?.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      return PseudoPromise.all(
+      return Promise.all(
-      return PseudoPromise.all([
+      return Promise.all([
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks?.push(parsedItem.then((parsed) => handleParsed(parsed)));
-// type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any,any>
-//   ? T
-//   : ZodEffects<T, T[""_output""]>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-        baseResult.promise.then((base) => {
+        baseResult.then((base) => {
-          return isAsync(result) ? result.promise : result;
+          return isAsync(result) ? result : result;
-      //     baseResult.promise.then((base) => {
+      //     baseResult.then((base) => {
-      //       return isAsync(result) ? result.promise : result;
+      //       return isAsync(result) ? result : result;","-    let invalid = false;
+    const invalid = false;
-        invalid = true;
+        // don't abort early on refinement issues
+        // invalid = true;","-import { PseudoPromise } from ""./PseudoPromise"";
+// import { PseudoPromise } from ""./PseudoPromise"";
-  ): ASYNC<SyncParseReturnType<Output>> {
+  ): Promise<SyncParseReturnType<Output>> {
-      ? maybeAsyncResult.promise
+      ? maybeAsyncResult
-      tasks?.push(
-        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-      );
+      tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-        tasks?.push(
-          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
-        );
+        tasks?.push(parsedValue.then((parsed) => handleParsed(key, parsed)));
-      return PseudoPromise.all(
+      return Promise.all(
-      return PseudoPromise.all([
+      return Promise.all([
-        tasks?.push(
-          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
-        );
+        tasks?.push(parsedItem.then((parsed) => handleParsed(index, parsed)));
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+          Promise.all([parsedKey, parsedValue]).then(([k, v]) =>
-        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+        tasks?.push(parsedItem.then((parsed) => handleParsed(parsed)));
-// type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any,any>
-//   ? T
-//   : ZodEffects<T, T[""_output""]>;
-  Output = T[""_type""]
-> extends ZodType<Output, ZodEffectsDef<T>, T[""_input""]> {
+  Output = T[""_output""],
+  Input = T[""_input""]
+> extends ZodType<Output, ZodEffectsDef<T>, Input> {
-    let invalid = false;
+    const invalid = false;
-        invalid = true;
+        // don't abort early on refinement issues
+        // invalid = true;
-        baseResult.promise.then((base) => {
+        baseResult.then((base) => {
-          return isAsync(result) ? result.promise : result;
+          return isAsync(result) ? result : result;
-      //     baseResult.promise.then((base) => {
+      //     baseResult.then((base) => {
-      //       return isAsync(result) ? result.promise : result;
+      //       return isAsync(result) ? result : result;"
colinhacks_zod,3e6c8022c114e42ae0456ff0d38bff8b42d3548a,Merge branch 'v3.9' into keys-in-records,deno/lib/types.ts,"-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodType<
-  ZodRecordDef<Value>,
+  ZodRecordDef<Value, Key>,
+    const keyType = this._def.keyType;
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+  static create<Value extends ZodTypeAny>(valueType: Value): ZodRecord<Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
-  ): ZodRecord<Value> => {
+  ): ZodRecord<Value>;
+  static create<Value extends ZodTypeAny = ZodTypeAny>(
+    first: any,
+    second?: any
+  ): ZodRecord<Value> {
+    if (second) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+      });
+    }
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-  };
+  }","-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+
-    } else if (!rest && data.length < this._def.items.length) {
+    }
+
+    if (data.length < this._def.items.length) {
+
-      restData.forEach((item, _index) => {
+      restData.forEach((dataItem, _index) => {
-          rest._parse(ctx.stepInto(index), item, getParsedType(item))
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))","-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+
-    } else if (!rest && data.length < this._def.items.length) {
+    }
+
+    if (data.length < this._def.items.length) {
+
-      restData.forEach((item, _index) => {
+      restData.forEach((dataItem, _index) => {
-          rest._parse(ctx.stepInto(index), item, getParsedType(item))
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodType<
-  ZodRecordDef<Value>,
+  ZodRecordDef<Value, Key>,
+    const keyType = this._def.keyType;
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+  static create<Value extends ZodTypeAny>(valueType: Value): ZodRecord<Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
-  ): ZodRecord<Value> => {
+  ): ZodRecord<Value>;
+  static create<Value extends ZodTypeAny = ZodTypeAny>(
+    first: any,
+    second?: any
+  ): ZodRecord<Value> {
+    if (second) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+      });
+    }
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-  };
+  }"
colinhacks_zod,3e6c8022c114e42ae0456ff0d38bff8b42d3548a,Merge branch 'v3.9' into keys-in-records,src/types.ts,"-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodType<
-  ZodRecordDef<Value>,
+  ZodRecordDef<Value, Key>,
+    const keyType = this._def.keyType;
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+  static create<Value extends ZodTypeAny>(valueType: Value): ZodRecord<Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
-  ): ZodRecord<Value> => {
+  ): ZodRecord<Value>;
+  static create<Value extends ZodTypeAny = ZodTypeAny>(
+    first: any,
+    second?: any
+  ): ZodRecord<Value> {
+    if (second) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+      });
+    }
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-  };
+  }","-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+
-    } else if (!rest && data.length < this._def.items.length) {
+    }
+
+    if (data.length < this._def.items.length) {
+
-      restData.forEach((item, _index) => {
+      restData.forEach((dataItem, _index) => {
-          rest._parse(ctx.stepInto(index), item, getParsedType(item))
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))","-export type OutputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
-};
+export type AssertArray<T extends any> = T extends any[] ? T : never;
+export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_output""] : never;
+  }
+>;
-export type InputTypeOfTuple<T extends ZodTupleItems | []> = {
-  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
-};
+export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<
+  {
+    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][""_input""] : never;
+  }
+>;
+
-    } else if (!rest && data.length < this._def.items.length) {
+    }
+
+    if (data.length < this._def.items.length) {
+
-      restData.forEach((item, _index) => {
+      restData.forEach((dataItem, _index) => {
-          rest._parse(ctx.stepInto(index), item, getParsedType(item))
+          rest._parse(ctx.stepInto(index), dataItem, getParsedType(dataItem))
-export interface ZodRecordDef<Value extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
+export interface ZodRecordDef<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodTypeDef {
+  keyType: Key;
-export class ZodRecord<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
+type KeySchema = ZodType<string | number | symbol, any, any>;
+export class ZodRecord<
+  Value extends ZodTypeAny = ZodTypeAny,
+  Key extends KeySchema = ZodString
+> extends ZodType<
-  ZodRecordDef<Value>,
+  ZodRecordDef<Value, Key>,
+    const keyType = this._def.keyType;
-  static create = <Value extends ZodTypeAny = ZodTypeAny>(
+  static create<Value extends ZodTypeAny>(valueType: Value): ZodRecord<Value>;
+  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
-  ): ZodRecord<Value> => {
+  ): ZodRecord<Value>;
+  static create<Value extends ZodTypeAny = ZodTypeAny>(
+    first: any,
+    second?: any
+  ): ZodRecord<Value> {
+    if (second) {
+      return new ZodRecord({
+        keyType: first,
+        valueType: second,
+        typeName: ZodFirstPartyTypeKind.ZodRecord,
+      });
+    }
-      valueType,
+      keyType: ZodString.create(),
+      valueType: first,
-  };
+  }"
colinhacks_zod,7fdfae12d08f9a740dfd39aba2086a100967401b,Merge branch 'master' of github.com:vriad/zod,deno/lib/types.ts,"-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  };
+
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {"
colinhacks_zod,7fdfae12d08f9a740dfd39aba2086a100967401b,Merge branch 'master' of github.com:vriad/zod,src/types.ts,"-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  };
+
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
-  ): ParseReturnType<T & U> {
+  ): ParseReturnType<T[""_output""] & U[""_output""]> {"
colinhacks_zod,73a1129b55e1a186102286fe59df92d40b356a7a,Merge branch 'master' into add-partial-by,deno/lib/types.ts,"+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  };
+
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;"
colinhacks_zod,73a1129b55e1a186102286fe59df92d40b356a7a,Merge branch 'master' into add-partial-by,src/types.ts,"+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;","-  | { kind: ""int""; message?: string };
+  | { kind: ""int""; message?: string }
+  | { kind: ""multipleOf""; value: number; message?: string };
+      } else if (check.kind === ""multipleOf"") {
+        if (data % check.value !== 0) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.not_multiple_of,
+            multipleOf: check.value,
+            message: check.message,
+          });
+        }
+
+  multipleOf = (value: number, message?: errorUtil.ErrMessage) =>
+    new ZodNumber({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""multipleOf"",
+          value: value,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+  step = this.multipleOf;
+  };
+
+  partialBy = <Mask extends { [k in keyof T]?: true }>(
+    mask: Mask
+  ): ZodObject<
+    objectUtil.noNever<
+      {
+        [k in keyof T]: k extends keyof Mask
+          ? ReturnType<T[k][""optional""]>
+          : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  > => {
+    const newShape: any = {};
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
+        newShape[key] = this.shape[key];
+      } else {
+        newShape[key] = this.shape[key].optional();
+      }
+    });
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,deno/lib/ZodError.ts,"-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    // restore prototype chain
+
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
+    this.name = ""ZodError"";
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);
-    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+    return this.message;
-    // const errorMessage: string[] = [
-    //   `${this.issues.length} validation issue(s)`,
-    //   '',
-    // ];
-    // for (const err of this.issues) {
-    //   errorMessage.push(
-    //     `  Issue #${this.issues.indexOf(err)}: ${err.code} at ${err.path.join(
-    //       '.',
-    //     )}`,
-    //   );
-    //   errorMessage.push(`  ` + err.message);
-    //   errorMessage.push('');
-    // }
-    // return errorMessage.join('\n');
-    // return quotelessJson(this);
-    // .map(({ path, message }) => {
-    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-    // })
-    // .join('\n');
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));
-  // denormalize = ():DenormalizedError{
-
-  // }
-
-  // path: (string | number)[];
-  // details: any;
-  // metadata: object;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
-      message = `Invalid input.`;
+      message = `Invalid input`;
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
-      message = `Invalid input.`;
+      message = _ctx.defaultError;
-  // return `Invalid input.`;","-export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"";
+export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"" | ""cuid"";","-export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"";
+export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"" | ""cuid"";
-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    // restore prototype chain
+
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
+    this.name = ""ZodError"";
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);
-    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+    return this.message;
-    // const errorMessage: string[] = [
-    //   `${this.issues.length} validation issue(s)`,
-    //   '',
-    // ];
-    // for (const err of this.issues) {
-    //   errorMessage.push(
-    //     `  Issue #${this.issues.indexOf(err)}: ${err.code} at ${err.path.join(
-    //       '.',
-    //     )}`,
-    //   );
-    //   errorMessage.push(`  ` + err.message);
-    //   errorMessage.push('');
-    // }
-    // return errorMessage.join('\n');
-    // return quotelessJson(this);
-    // .map(({ path, message }) => {
-    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-    // })
-    // .join('\n');
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));
-  // denormalize = ():DenormalizedError{
-
-  // }
-
-  // path: (string | number)[];
-  // details: any;
-  // metadata: object;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
-      message = `Invalid input.`;
+      message = `Invalid input`;
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
-      message = `Invalid input.`;
+      message = _ctx.defaultError;
-  // return `Invalid input.`;"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,deno/lib/__tests__/string.test.ts,"+  uuid.parse(""00000000-0000-0000-0000-000000000000"");","+test(""cuid"", () => {
+  const cuid = z.string().cuid();
+  cuid.parse(""ckopqwooh000001la8mbi2im9"");
+  const result = cuid.safeParse(""cifjhdsfhsd-invalid-cuid"");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(""Invalid cuid"");
+  }
+});
+","+  uuid.parse(""00000000-0000-0000-0000-000000000000"");
+  }
+});
+
+test(""cuid"", () => {
+  const cuid = z.string().cuid();
+  cuid.parse(""ckopqwooh000001la8mbi2im9"");
+  const result = cuid.safeParse(""cifjhdsfhsd-invalid-cuid"");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(""Invalid cuid"");"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,deno/lib/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
+  issueFound: boolean;
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
-  : ZodEffects<T, T[""_output""]>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
+
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""Synchronous parse encountered promise."");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
+        typeName: ZodFirstPartyTypeKind.ZodEffects,
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+
-    return ZodUnion.create([this, option]);
+    return ZodUnion.create([this, option]) as any;
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
+      typeName: ZodFirstPartyTypeKind.ZodDefault,
+type ZodStringCheck =
+  | { kind: ""min""; value: number; message?: string }
+  | { kind: ""max""; value: number; message?: string }
+  | { kind: ""email""; message?: string }
+  | { kind: ""url""; message?: string }
+  | { kind: ""uuid""; message?: string }
+  | { kind: ""regex""; regex: RegExp; message?: string };
-  // validation: {
-  //   uuid?: true;
-  //   custom?: ((val: any) => boolean)[];
-  // };
-  isEmail: { message?: string } | false;
-  isURL: { message?: string } | false;
-  isUUID: { message?: string } | false;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+  checks: ZodStringCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodString;
+}
+
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""email"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isEmail.message,
-      });
-    }
-
-    if (this._def.isURL) {
-      try {
-        new URL(ctx.data);
-      } catch {
-        ctx.addIssue({
-          validation: ""url"",
-          code: ZodIssueCode.invalid_string,
-          message: this._def.isURL.message,
-        });
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""min"") {
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+            // ...errorUtil.errToObj(this._def.maxLength.message),
+          });
+        }
+      } else if (check.kind === ""email"") {
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""uuid"") {
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""url"") {
+        try {
+          new URL(data);
+        } catch {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""regex"") {
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
-    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""uuid"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isUUID.message,
-      });
-    }
-
-    if (this._def.minLength !== null) {
-      if (ctx.data.length < this._def.minLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: this._def.minLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.minLength.message,
-          // ...errorUtil.errToObj(this._def.minLength.message),
-        });
-      }
-    }
-
-    if (this._def.maxLength !== null) {
-      if (ctx.data.length > this._def.maxLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: this._def.maxLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.maxLength.message,
-          // ...errorUtil.errToObj(this._def.maxLength.message),
-        });
-      }
-    }
-
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-      isEmail: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""email"", ...errorUtil.errToObj(message) },
+      ],
-      isURL: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""url"", ...errorUtil.errToObj(message) },
+      ],
-      isUUID: errorUtil.errToObj(message),
-    });
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, ""regex"", message);
+      checks: [
+        ...this._def.checks,
+        { kind: ""uuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
+      ],
+    });
-      minLength: {
-        value: minLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
+      ],
-      maxLength: {
-        value: maxLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
+      ],
+  get isEmail() {
+    return !!this._def.checks.find((ch) => ch.kind === ""email"");
+  }
+  get isURL() {
+    return !!this._def.checks.find((ch) => ch.kind === ""url"");
+  }
+  get isUUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""uuid"");
+  }
+  get minLength() {
+    let min: number | null = -Infinity;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) {
+          min = ch.value;
+        }
+      }
+    });
+    return min;
+  }
+  get maxLength() {
+    let max: number | null = null;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) {
+          max = ch.value;
+        }
+      }
+    });
+    return max;
+  }
-      isEmail: false,
-      isURL: false,
-      isUUID: false,
-      minLength: null,
-      maxLength: null,
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodString,
+type ZodNumberCheck =
+  | { kind: ""min""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""max""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""int""; message?: string };
-  minimum: null | { value: number; inclusive: boolean; message?: string };
-  maximum: null | { value: number; inclusive: boolean; message?: string };
-  isInteger: false | { message?: string };
+  checks: ZodNumberCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodNumber;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
-
-    if (this._def.minimum) {
-      const MIN = this._def.minimum;
-      const tooSmall = MIN.inclusive
-        ? ctx.data < MIN.value
-        : ctx.data <= MIN.value;
-      if (tooSmall) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: MIN.value,
-          type: ""number"",
-          inclusive: MIN.inclusive,
-          message: MIN.message,
-        });
+
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""int"") {
+        if (!util.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""min"") {
+        // const MIN = check.value;
+        const tooSmall = check.inclusive
+          ? data < check.value
+          : data <= check.value;
+        if (tooSmall) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        const tooBig = check.inclusive
+          ? data > check.value
+          : data >= check.value;
+        if (tooBig) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
-    if (this._def.maximum) {
-      const MAX = this._def.maximum;
-      const tooBig = MAX.inclusive
-        ? ctx.data > MAX.value
-        : ctx.data >= MAX.value;
-      if (tooBig) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: MAX.value,
-          type: ""number"",
-          inclusive: MAX.inclusive,
-          message: MAX.message,
-        });
-      }
-    }
-
-    if (this._def.isInteger) {
-      if (!Number.isInteger(ctx.data)) {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_type,
-          expected: ""integer"",
-          received: ""float"",
-          message: this._def.isInteger.message,
-        });
-      }
-    }
-
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-      minimum: null,
-      maximum: null,
-      isInteger: false,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodNumber,
+    });
+  };
+
+  gte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  min = this.gte;
+
+  gt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, false, errorUtil.toString(message));
+
+  lte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  max = this.lte;
+
+  lt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, false, errorUtil.toString(message));
+
+  protected setLimit = (
+    kind: ""min"" | ""max"",
+    value: number,
+    inclusive: boolean,
+    message?: string
+  ) =>
-      minimum: {
-        value: minimum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      maximum: {
-        value: maximum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind,
+          value,
+          inclusive,
+          message: errorUtil.toString(message),
+        },
+      ],
-      isInteger: { message: errorUtil.toString(message) },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""int"",
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+
+  get minValue() {
+    let min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      }
+    }
+    return min;
+  }
+
+  get maxValue() {
+    let max: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return max;
+  }
+
+  get isInt() {
+    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+  }
-export type ZodBigIntDef = ZodTypeDef;
+export interface ZodBigIntDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBigInt;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBigInt({});
+    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
-export type ZodBooleanDef = ZodTypeDef;
+export interface ZodBooleanDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBoolean;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBoolean({});
+    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
-export type ZodDateDef = ZodTypeDef;
+export interface ZodDateDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodDate;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-    return new ZodDate({});
+    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
-export type ZodUndefinedDef = ZodTypeDef;
-
-export class ZodUndefined extends ZodType<undefined> {
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+export interface ZodUndefinedDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUndefined;
+}
+
+export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodUndefined({});
+    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
-export type ZodNullDef = ZodTypeDef;
+export interface ZodNullDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNull;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodNull({});
+    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
-export type ZodAnyDef = ZodTypeDef;
+export interface ZodAnyDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodAny;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
+  _any: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-    return new ZodAny({});
+    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
-export type ZodUnknownDef = ZodTypeDef;
+export interface ZodUnknownDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUnknown;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // required
+  _unknown: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-    return new ZodUnknown({});
+    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
-export type ZodNeverDef = ZodTypeDef;
+export interface ZodNeverDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNever;
+}
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-    return new ZodNever({});
+    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
-export type ZodVoidDef = ZodTypeDef;
+export interface ZodVoidDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodVoid;
+}
-  _parse(ctx: ParseContext): any {
-    if (
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
-    ) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodVoid({});
+    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  typeName: ZodFirstPartyTypeKind.ZodArray;
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T[""_output""][],
+export type ArrayCardinality = ""many"" | ""atleastone"";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> = Cardinality extends ""atleastone""
+  ? [T[""_output""], ...T[""_output""][]]
+  : T[""_output""][];
+
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
-  T[""_input""][]
+  Cardinality extends ""atleastone""
+    ? [T[""_input""], ...T[""_input""][]]
+    : T[""_input""][]
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    return parseArray(ctx, data, parsedType, this._def) as any;
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def });
+  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
+    message?: any
+  ) => {
+    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
-    });
-  };
-}
-
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-//////////                            //////////
-//////////      ZodNonEmptyArray      //////////
-//////////                            //////////
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  type: T;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T[""_output""], ...T[""_output""][]],
-  ZodNonEmptyArrayDef<T>,
-  [T[""_input""], ...T[""_input""][]]
-> {
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
-  }
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      minLength: { value: minLength, message: errorUtil.toString(message) },
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      maxLength: { value: maxLength, message: errorUtil.toString(message) },
-    });
-
-  length = (len: number, message?: errorUtil.ErrMessage) =>
-    this.min(len, message).max(len, message);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
-    return new ZodNonEmptyArray({
-      type: schema,
-      minLength: null,
-      maxLength: null,
-    });
-  };
-}
+      typeName: ZodFirstPartyTypeKind.ZodArray,
+    });
+  };
+}
+
+export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, ""atleastone"">;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
+    typeName: ZodFirstPartyTypeKind.ZodObject,
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+  typeName: ZodFirstPartyTypeKind.ZodObject;
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else {
+    return schema;
+  }
+}
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = util.objectKeys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = util.objectKeys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
+   */
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+      typeName: ZodFirstPartyTypeKind.ZodObject,
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+  typeName: ZodFirstPartyTypeKind.ZodUnion;
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodUnion,
+  typeName: ZodFirstPartyTypeKind.ZodIntersection;
+}
+
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
+      typeName: ZodFirstPartyTypeKind.ZodIntersection,
+  typeName: ZodFirstPartyTypeKind.ZodTuple;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodTuple,
+  typeName: ZodFirstPartyTypeKind.ZodRecord;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodRecord,
+  typeName: ZodFirstPartyTypeKind.ZodMap;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodMap,
+  typeName: ZodFirstPartyTypeKind.ZodSet;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodSet,
+  typeName: ZodFirstPartyTypeKind.ZodFunction;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
+        const result = await fn(...(parsedArgs as any));
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
-      }
-    };
-    return validatedFunction;
+        return parsedReturns;
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+      });
+    }
+      typeName: ZodFirstPartyTypeKind.ZodFunction,
+  typeName: ZodFirstPartyTypeKind.ZodLazy;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodLazy,
+  typeName: ZodFirstPartyTypeKind.ZodLiteral;
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+  }
+
+  get value() {
+    return this._def.value;
+      typeName: ZodFirstPartyTypeKind.ZodLiteral,
+  typeName: ZodFirstPartyTypeKind.ZodEnum;
+}
+
+type Writeable<T> = { -readonly [P in keyof T]: T[P] };
+
+function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
+  values: T
+): ZodEnum<Writeable<T>>;
+function createZodEnum<U extends string, T extends [U, ...U[]]>(
+  values: T
+): ZodEnum<T>;
+function createZodEnum(values: any) {
+  return new ZodEnum({
+    values: values as any,
+    typeName: ZodFirstPartyTypeKind.ZodEnum,
+  }) as any;
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      values: values,
-    }) as any;
-  };
+  static create = createZodEnum;
+  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+  typeName: ZodFirstPartyTypeKind.ZodPromise;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
+      typeName: ZodFirstPartyTypeKind.ZodPromise,
-//////////      ZodEffects      //////////
+//////////        ZodEffects        //////////
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  : ZodEffects<T, T[""_output""]>;
+
+export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
+export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+  typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  innerType() {
+    return this._def.schema;
+  }
+
+  _parse(
+    ctx: ParseContext,
+    initialData: any,
+    initialParsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
-      addIssue: (arg: MakeErrorData) => {
-        ctx.addIssue(arg);
+      issueFound: false,
+      addIssue: function (arg: MakeErrorData) {
+        this.issueFound = true;
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((_res) => {
+                const issueFound = checkCtx.issueFound;
+                invalid = invalid || issueFound;
+                return acc;
+              });
+            }
+          } else {
+            const issueFound = checkCtx.issueFound;
+            invalid = invalid || issueFound;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    // }
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I[""_output""]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: ""transform"", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+  typeName: ZodFirstPartyTypeKind.ZodOptional;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+  typeName: ZodFirstPartyTypeKind.ZodNullable;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodNullable,
+  typeName: ZodFirstPartyTypeKind.ZodDefault;
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+export enum ZodFirstPartyTypeKind {
+  ZodString = ""ZodString"",
+  ZodNumber = ""ZodNumber"",
+  ZodBigInt = ""ZodBigInt"",
+  ZodBoolean = ""ZodBoolean"",
+  ZodDate = ""ZodDate"",
+  ZodUndefined = ""ZodUndefined"",
+  ZodNull = ""ZodNull"",
+  ZodAny = ""ZodAny"",
+  ZodUnknown = ""ZodUnknown"",
+  ZodNever = ""ZodNever"",
+  ZodVoid = ""ZodVoid"",
+  ZodArray = ""ZodArray"",
+  ZodObject = ""ZodObject"",
+  ZodUnion = ""ZodUnion"",
+  ZodIntersection = ""ZodIntersection"",
+  ZodTuple = ""ZodTuple"",
+  ZodRecord = ""ZodRecord"",
+  ZodMap = ""ZodMap"",
+  ZodSet = ""ZodSet"",
+  ZodFunction = ""ZodFunction"",
+  ZodLazy = ""ZodLazy"",
+  ZodLiteral = ""ZodLiteral"",
+  ZodEnum = ""ZodEnum"",
+  ZodEffects = ""ZodEffects"",
+  ZodNativeEnum = ""ZodNativeEnum"",
+  ZodOptional = ""ZodOptional"",
+  ZodNullable = ""ZodNullable"",
+  ZodDefault = ""ZodDefault"",
+  ZodPromise = ""ZodPromise"",
+}
+const preprocessType = ZodEffects.createWithPreprocess;
+  preprocessType as preprocess,","+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+      isCUID: false,","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
+  issueFound: boolean;
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
-  : ZodEffects<T, T[""_output""]>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
+
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""Synchronous parse encountered promise."");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
+        typeName: ZodFirstPartyTypeKind.ZodEffects,
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+
-    return ZodUnion.create([this, option]);
+    return ZodUnion.create([this, option]) as any;
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
+      typeName: ZodFirstPartyTypeKind.ZodDefault,
+type ZodStringCheck =
+  | { kind: ""min""; value: number; message?: string }
+  | { kind: ""max""; value: number; message?: string }
+  | { kind: ""email""; message?: string }
+  | { kind: ""url""; message?: string }
+  | { kind: ""uuid""; message?: string }
+  | { kind: ""cuid""; message?: string }
+  | { kind: ""regex""; regex: RegExp; message?: string };
-  // validation: {
-  //   uuid?: true;
-  //   custom?: ((val: any) => boolean)[];
-  // };
-  isEmail: { message?: string } | false;
-  isURL: { message?: string } | false;
-  isUUID: { message?: string } | false;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+  checks: ZodStringCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodString;
+}
+
+const cuidRegex = /^c[^\s-]{8,}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""email"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isEmail.message,
-      });
-    }
-
-    if (this._def.isURL) {
-      try {
-        new URL(ctx.data);
-      } catch {
-        ctx.addIssue({
-          validation: ""url"",
-          code: ZodIssueCode.invalid_string,
-          message: this._def.isURL.message,
-        });
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""min"") {
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+            // ...errorUtil.errToObj(this._def.maxLength.message),
+          });
+        }
+      } else if (check.kind === ""email"") {
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""uuid"") {
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""cuid"") {
+        if (!cuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""url"") {
+        try {
+          new URL(data);
+        } catch {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""regex"") {
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
-    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""uuid"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isUUID.message,
-      });
-    }
-
-    if (this._def.minLength !== null) {
-      if (ctx.data.length < this._def.minLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: this._def.minLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.minLength.message,
-          // ...errorUtil.errToObj(this._def.minLength.message),
-        });
-      }
-    }
-
-    if (this._def.maxLength !== null) {
-      if (ctx.data.length > this._def.maxLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: this._def.maxLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.maxLength.message,
-          // ...errorUtil.errToObj(this._def.maxLength.message),
-        });
-      }
-    }
-
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-      isEmail: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""email"", ...errorUtil.errToObj(message) },
+      ],
-      isURL: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""url"", ...errorUtil.errToObj(message) },
+      ],
-      isUUID: errorUtil.errToObj(message),
-    });
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, ""regex"", message);
+      checks: [
+        ...this._def.checks,
+        { kind: ""uuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""cuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
+      ],
+    });
-      minLength: {
-        value: minLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
+      ],
-      maxLength: {
-        value: maxLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
+      ],
+  get isEmail() {
+    return !!this._def.checks.find((ch) => ch.kind === ""email"");
+  }
+  get isURL() {
+    return !!this._def.checks.find((ch) => ch.kind === ""url"");
+  }
+  get isUUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""uuid"");
+  }
+  get minLength() {
+    let min: number | null = -Infinity;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) {
+          min = ch.value;
+        }
+      }
+    });
+    return min;
+  }
+  get maxLength() {
+    let max: number | null = null;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) {
+          max = ch.value;
+        }
+      }
+    });
+    return max;
+  }
-      isEmail: false,
-      isURL: false,
-      isUUID: false,
-      minLength: null,
-      maxLength: null,
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodString,
+type ZodNumberCheck =
+  | { kind: ""min""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""max""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""int""; message?: string };
-  minimum: null | { value: number; inclusive: boolean; message?: string };
-  maximum: null | { value: number; inclusive: boolean; message?: string };
-  isInteger: false | { message?: string };
+  checks: ZodNumberCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodNumber;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
-
-    if (this._def.minimum) {
-      const MIN = this._def.minimum;
-      const tooSmall = MIN.inclusive
-        ? ctx.data < MIN.value
-        : ctx.data <= MIN.value;
-      if (tooSmall) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: MIN.value,
-          type: ""number"",
-          inclusive: MIN.inclusive,
-          message: MIN.message,
-        });
+
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""int"") {
+        if (!util.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""min"") {
+        // const MIN = check.value;
+        const tooSmall = check.inclusive
+          ? data < check.value
+          : data <= check.value;
+        if (tooSmall) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        const tooBig = check.inclusive
+          ? data > check.value
+          : data >= check.value;
+        if (tooBig) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
-    if (this._def.maximum) {
-      const MAX = this._def.maximum;
-      const tooBig = MAX.inclusive
-        ? ctx.data > MAX.value
-        : ctx.data >= MAX.value;
-      if (tooBig) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: MAX.value,
-          type: ""number"",
-          inclusive: MAX.inclusive,
-          message: MAX.message,
-        });
-      }
-    }
-
-    if (this._def.isInteger) {
-      if (!Number.isInteger(ctx.data)) {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_type,
-          expected: ""integer"",
-          received: ""float"",
-          message: this._def.isInteger.message,
-        });
-      }
-    }
-
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-      minimum: null,
-      maximum: null,
-      isInteger: false,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodNumber,
+    });
+  };
+
+  gte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  min = this.gte;
+
+  gt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, false, errorUtil.toString(message));
+
+  lte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  max = this.lte;
+
+  lt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, false, errorUtil.toString(message));
+
+  protected setLimit = (
+    kind: ""min"" | ""max"",
+    value: number,
+    inclusive: boolean,
+    message?: string
+  ) =>
-      minimum: {
-        value: minimum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      maximum: {
-        value: maximum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind,
+          value,
+          inclusive,
+          message: errorUtil.toString(message),
+        },
+      ],
-      isInteger: { message: errorUtil.toString(message) },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""int"",
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+
+  get minValue() {
+    let min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      }
+    }
+    return min;
+  }
+
+  get maxValue() {
+    let max: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return max;
+  }
+
+  get isInt() {
+    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+  }
-export type ZodBigIntDef = ZodTypeDef;
+export interface ZodBigIntDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBigInt;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBigInt({});
+    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
-export type ZodBooleanDef = ZodTypeDef;
+export interface ZodBooleanDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBoolean;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBoolean({});
+    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
-export type ZodDateDef = ZodTypeDef;
+export interface ZodDateDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodDate;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-    return new ZodDate({});
+    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
-export type ZodUndefinedDef = ZodTypeDef;
-
-export class ZodUndefined extends ZodType<undefined> {
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+export interface ZodUndefinedDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUndefined;
+}
+
+export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodUndefined({});
+    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
-export type ZodNullDef = ZodTypeDef;
+export interface ZodNullDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNull;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodNull({});
+    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
-export type ZodAnyDef = ZodTypeDef;
+export interface ZodAnyDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodAny;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
+  _any: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-    return new ZodAny({});
+    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
-export type ZodUnknownDef = ZodTypeDef;
+export interface ZodUnknownDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUnknown;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // required
+  _unknown: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-    return new ZodUnknown({});
+    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
-export type ZodNeverDef = ZodTypeDef;
+export interface ZodNeverDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNever;
+}
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-    return new ZodNever({});
+    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
-export type ZodVoidDef = ZodTypeDef;
+export interface ZodVoidDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodVoid;
+}
-  _parse(ctx: ParseContext): any {
-    if (
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
-    ) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodVoid({});
+    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  typeName: ZodFirstPartyTypeKind.ZodArray;
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T[""_output""][],
+export type ArrayCardinality = ""many"" | ""atleastone"";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> = Cardinality extends ""atleastone""
+  ? [T[""_output""], ...T[""_output""][]]
+  : T[""_output""][];
+
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
-  T[""_input""][]
+  Cardinality extends ""atleastone""
+    ? [T[""_input""], ...T[""_input""][]]
+    : T[""_input""][]
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    return parseArray(ctx, data, parsedType, this._def) as any;
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def });
+  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
+    message?: any
+  ) => {
+    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
-    });
-  };
-}
-
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-//////////                            //////////
-//////////      ZodNonEmptyArray      //////////
-//////////                            //////////
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  type: T;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T[""_output""], ...T[""_output""][]],
-  ZodNonEmptyArrayDef<T>,
-  [T[""_input""], ...T[""_input""][]]
-> {
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
-  }
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      minLength: { value: minLength, message: errorUtil.toString(message) },
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      maxLength: { value: maxLength, message: errorUtil.toString(message) },
-    });
-
-  length = (len: number, message?: errorUtil.ErrMessage) =>
-    this.min(len, message).max(len, message);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
-    return new ZodNonEmptyArray({
-      type: schema,
-      minLength: null,
-      maxLength: null,
-    });
-  };
-}
+      typeName: ZodFirstPartyTypeKind.ZodArray,
+    });
+  };
+}
+
+export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, ""atleastone"">;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
+    typeName: ZodFirstPartyTypeKind.ZodObject,
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+  typeName: ZodFirstPartyTypeKind.ZodObject;
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else {
+    return schema;
+  }
+}
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = util.objectKeys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = util.objectKeys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
+   */
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+      typeName: ZodFirstPartyTypeKind.ZodObject,
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+  typeName: ZodFirstPartyTypeKind.ZodUnion;
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodUnion,
+  typeName: ZodFirstPartyTypeKind.ZodIntersection;
+}
+
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
+      typeName: ZodFirstPartyTypeKind.ZodIntersection,
+  typeName: ZodFirstPartyTypeKind.ZodTuple;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodTuple,
+  typeName: ZodFirstPartyTypeKind.ZodRecord;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodRecord,
+  typeName: ZodFirstPartyTypeKind.ZodMap;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodMap,
+  typeName: ZodFirstPartyTypeKind.ZodSet;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodSet,
+  typeName: ZodFirstPartyTypeKind.ZodFunction;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
+        const result = await fn(...(parsedArgs as any));
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
-      }
-    };
-    return validatedFunction;
+        return parsedReturns;
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+      });
+    }
+      typeName: ZodFirstPartyTypeKind.ZodFunction,
+  typeName: ZodFirstPartyTypeKind.ZodLazy;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodLazy,
+  typeName: ZodFirstPartyTypeKind.ZodLiteral;
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+  }
+
+  get value() {
+    return this._def.value;
+      typeName: ZodFirstPartyTypeKind.ZodLiteral,
+  typeName: ZodFirstPartyTypeKind.ZodEnum;
+}
+
+type Writeable<T> = { -readonly [P in keyof T]: T[P] };
+
+function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
+  values: T
+): ZodEnum<Writeable<T>>;
+function createZodEnum<U extends string, T extends [U, ...U[]]>(
+  values: T
+): ZodEnum<T>;
+function createZodEnum(values: any) {
+  return new ZodEnum({
+    values: values as any,
+    typeName: ZodFirstPartyTypeKind.ZodEnum,
+  }) as any;
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      values: values,
-    }) as any;
-  };
+  static create = createZodEnum;
+  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+  typeName: ZodFirstPartyTypeKind.ZodPromise;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
+      typeName: ZodFirstPartyTypeKind.ZodPromise,
-//////////      ZodEffects      //////////
+//////////        ZodEffects        //////////
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  : ZodEffects<T, T[""_output""]>;
+
+export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
+export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+  typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  innerType() {
+    return this._def.schema;
+  }
+
+  _parse(
+    ctx: ParseContext,
+    initialData: any,
+    initialParsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
-      addIssue: (arg: MakeErrorData) => {
-        ctx.addIssue(arg);
+      issueFound: false,
+      addIssue: function (arg: MakeErrorData) {
+        this.issueFound = true;
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((_res) => {
+                const issueFound = checkCtx.issueFound;
+                invalid = invalid || issueFound;
+                return acc;
+              });
+            }
+          } else {
+            const issueFound = checkCtx.issueFound;
+            invalid = invalid || issueFound;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    // }
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I[""_output""]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: ""transform"", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+  typeName: ZodFirstPartyTypeKind.ZodOptional;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+  typeName: ZodFirstPartyTypeKind.ZodNullable;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodNullable,
+  typeName: ZodFirstPartyTypeKind.ZodDefault;
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+export enum ZodFirstPartyTypeKind {
+  ZodString = ""ZodString"",
+  ZodNumber = ""ZodNumber"",
+  ZodBigInt = ""ZodBigInt"",
+  ZodBoolean = ""ZodBoolean"",
+  ZodDate = ""ZodDate"",
+  ZodUndefined = ""ZodUndefined"",
+  ZodNull = ""ZodNull"",
+  ZodAny = ""ZodAny"",
+  ZodUnknown = ""ZodUnknown"",
+  ZodNever = ""ZodNever"",
+  ZodVoid = ""ZodVoid"",
+  ZodArray = ""ZodArray"",
+  ZodObject = ""ZodObject"",
+  ZodUnion = ""ZodUnion"",
+  ZodIntersection = ""ZodIntersection"",
+  ZodTuple = ""ZodTuple"",
+  ZodRecord = ""ZodRecord"",
+  ZodMap = ""ZodMap"",
+  ZodSet = ""ZodSet"",
+  ZodFunction = ""ZodFunction"",
+  ZodLazy = ""ZodLazy"",
+  ZodLiteral = ""ZodLiteral"",
+  ZodEnum = ""ZodEnum"",
+  ZodEffects = ""ZodEffects"",
+  ZodNativeEnum = ""ZodNativeEnum"",
+  ZodOptional = ""ZodOptional"",
+  ZodNullable = ""ZodNullable"",
+  ZodDefault = ""ZodDefault"",
+  ZodPromise = ""ZodPromise"",
+}
+const preprocessType = ZodEffects.createWithPreprocess;
+  preprocessType as preprocess,"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,src/ZodError.ts,"-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    // restore prototype chain
+
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
+    this.name = ""ZodError"";
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);
-    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+    return this.message;
-    // const errorMessage: string[] = [
-    //   `${this.issues.length} validation issue(s)`,
-    //   '',
-    // ];
-    // for (const err of this.issues) {
-    //   errorMessage.push(
-    //     `  Issue #${this.issues.indexOf(err)}: ${err.code} at ${err.path.join(
-    //       '.',
-    //     )}`,
-    //   );
-    //   errorMessage.push(`  ` + err.message);
-    //   errorMessage.push('');
-    // }
-    // return errorMessage.join('\n');
-    // return quotelessJson(this);
-    // .map(({ path, message }) => {
-    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-    // })
-    // .join('\n');
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));
-  // denormalize = ():DenormalizedError{
-
-  // }
-
-  // path: (string | number)[];
-  // details: any;
-  // metadata: object;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
-      message = `Invalid input.`;
+      message = `Invalid input`;
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
-      message = `Invalid input.`;
+      message = _ctx.defaultError;
-  // return `Invalid input.`;","-export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"";
+export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"" | ""cuid"";","-export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"";
+export type StringValidation = ""email"" | ""url"" | ""uuid"" | ""regex"" | ""cuid"";
-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    // restore prototype chain
+
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
+    this.name = ""ZodError"";
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);
-    return `ZodError: ${JSON.stringify(this.issues, null, 2)}`;
+    return this.message;
-    // const errorMessage: string[] = [
-    //   `${this.issues.length} validation issue(s)`,
-    //   '',
-    // ];
-    // for (const err of this.issues) {
-    //   errorMessage.push(
-    //     `  Issue #${this.issues.indexOf(err)}: ${err.code} at ${err.path.join(
-    //       '.',
-    //     )}`,
-    //   );
-    //   errorMessage.push(`  ` + err.message);
-    //   errorMessage.push('');
-    // }
-    // return errorMessage.join('\n');
-    // return quotelessJson(this);
-    // .map(({ path, message }) => {
-    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-    // })
-    // .join('\n');
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));
-  // denormalize = ():DenormalizedError{
-
-  // }
-
-  // path: (string | number)[];
-  // details: any;
-  // metadata: object;
-    // case ZodIssueCode.too_small:
-    //   const tooShortNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at least ${error.minimum} ${tooShortNoun}`;
-    //   break;
-    // case ZodIssueCode.too_big:
-    //   const tooLongNoun = _ctx.data === 'string' ? 'characters' : 'items';
-    //   message = `Too short, should be at most ${error.maximum} ${tooLongNoun}`;
-    //   break;
-    // case ZodIssueCode.invalid_url:
-    //   message = 'Invalid URL.';
-    //   break;
-    // case ZodIssueCode.invalid_uuid:
-    //   message = 'Invalid UUID.';
-    //   break;
-      message = `Invalid input.`;
+      message = `Invalid input`;
-      message = `Intersections only support objects`;
+      message = `Intersection results could not be merged`;
-      message = `Invalid input.`;
+      message = _ctx.defaultError;
-  // return `Invalid input.`;"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,src/__tests__/string.test.ts,"+  uuid.parse(""00000000-0000-0000-0000-000000000000"");","+test(""cuid"", () => {
+  const cuid = z.string().cuid();
+  cuid.parse(""ckopqwooh000001la8mbi2im9"");
+  const result = cuid.safeParse(""cifjhdsfhsd-invalid-cuid"");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(""Invalid cuid"");
+  }
+});
+","+  uuid.parse(""00000000-0000-0000-0000-000000000000"");
+  }
+});
+
+test(""cuid"", () => {
+  const cuid = z.string().cuid();
+  cuid.parse(""ckopqwooh000001la8mbi2im9"");
+  const result = cuid.safeParse(""cifjhdsfhsd-invalid-cuid"");
+  expect(result.success).toEqual(false);
+  if (!result.success) {
+    expect(result.error.issues[0].message).toEqual(""Invalid cuid"");"
colinhacks_zod,6347453d4f06e05e8644287ae602ba9f0dc817d6,Fix merge conflicts for CUID,src/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
+  issueFound: boolean;
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
-  : ZodEffects<T, T[""_output""]>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
+
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""Synchronous parse encountered promise."");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
+        typeName: ZodFirstPartyTypeKind.ZodEffects,
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+
-    return ZodUnion.create([this, option]);
+    return ZodUnion.create([this, option]) as any;
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
+      typeName: ZodFirstPartyTypeKind.ZodDefault,
+type ZodStringCheck =
+  | { kind: ""min""; value: number; message?: string }
+  | { kind: ""max""; value: number; message?: string }
+  | { kind: ""email""; message?: string }
+  | { kind: ""url""; message?: string }
+  | { kind: ""uuid""; message?: string }
+  | { kind: ""regex""; regex: RegExp; message?: string };
-  // validation: {
-  //   uuid?: true;
-  //   custom?: ((val: any) => boolean)[];
-  // };
-  isEmail: { message?: string } | false;
-  isURL: { message?: string } | false;
-  isUUID: { message?: string } | false;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+  checks: ZodStringCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodString;
+}
+
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""email"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isEmail.message,
-      });
-    }
-
-    if (this._def.isURL) {
-      try {
-        new URL(ctx.data);
-      } catch {
-        ctx.addIssue({
-          validation: ""url"",
-          code: ZodIssueCode.invalid_string,
-          message: this._def.isURL.message,
-        });
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""min"") {
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+            // ...errorUtil.errToObj(this._def.maxLength.message),
+          });
+        }
+      } else if (check.kind === ""email"") {
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""uuid"") {
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""url"") {
+        try {
+          new URL(data);
+        } catch {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""regex"") {
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
-    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""uuid"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isUUID.message,
-      });
-    }
-
-    if (this._def.minLength !== null) {
-      if (ctx.data.length < this._def.minLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: this._def.minLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.minLength.message,
-          // ...errorUtil.errToObj(this._def.minLength.message),
-        });
-      }
-    }
-
-    if (this._def.maxLength !== null) {
-      if (ctx.data.length > this._def.maxLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: this._def.maxLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.maxLength.message,
-          // ...errorUtil.errToObj(this._def.maxLength.message),
-        });
-      }
-    }
-
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-      isEmail: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""email"", ...errorUtil.errToObj(message) },
+      ],
-      isURL: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""url"", ...errorUtil.errToObj(message) },
+      ],
-      isUUID: errorUtil.errToObj(message),
-    });
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, ""regex"", message);
+      checks: [
+        ...this._def.checks,
+        { kind: ""uuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
+      ],
+    });
-      minLength: {
-        value: minLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
+      ],
-      maxLength: {
-        value: maxLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
+      ],
+  get isEmail() {
+    return !!this._def.checks.find((ch) => ch.kind === ""email"");
+  }
+  get isURL() {
+    return !!this._def.checks.find((ch) => ch.kind === ""url"");
+  }
+  get isUUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""uuid"");
+  }
+  get minLength() {
+    let min: number | null = -Infinity;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) {
+          min = ch.value;
+        }
+      }
+    });
+    return min;
+  }
+  get maxLength() {
+    let max: number | null = null;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) {
+          max = ch.value;
+        }
+      }
+    });
+    return max;
+  }
-      isEmail: false,
-      isURL: false,
-      isUUID: false,
-      minLength: null,
-      maxLength: null,
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodString,
+type ZodNumberCheck =
+  | { kind: ""min""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""max""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""int""; message?: string };
-  minimum: null | { value: number; inclusive: boolean; message?: string };
-  maximum: null | { value: number; inclusive: boolean; message?: string };
-  isInteger: false | { message?: string };
+  checks: ZodNumberCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodNumber;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
-
-    if (this._def.minimum) {
-      const MIN = this._def.minimum;
-      const tooSmall = MIN.inclusive
-        ? ctx.data < MIN.value
-        : ctx.data <= MIN.value;
-      if (tooSmall) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: MIN.value,
-          type: ""number"",
-          inclusive: MIN.inclusive,
-          message: MIN.message,
-        });
+
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""int"") {
+        if (!util.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""min"") {
+        // const MIN = check.value;
+        const tooSmall = check.inclusive
+          ? data < check.value
+          : data <= check.value;
+        if (tooSmall) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        const tooBig = check.inclusive
+          ? data > check.value
+          : data >= check.value;
+        if (tooBig) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
-    if (this._def.maximum) {
-      const MAX = this._def.maximum;
-      const tooBig = MAX.inclusive
-        ? ctx.data > MAX.value
-        : ctx.data >= MAX.value;
-      if (tooBig) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: MAX.value,
-          type: ""number"",
-          inclusive: MAX.inclusive,
-          message: MAX.message,
-        });
-      }
-    }
-
-    if (this._def.isInteger) {
-      if (!Number.isInteger(ctx.data)) {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_type,
-          expected: ""integer"",
-          received: ""float"",
-          message: this._def.isInteger.message,
-        });
-      }
-    }
-
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-      minimum: null,
-      maximum: null,
-      isInteger: false,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodNumber,
+    });
+  };
+
+  gte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  min = this.gte;
+
+  gt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, false, errorUtil.toString(message));
+
+  lte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  max = this.lte;
+
+  lt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, false, errorUtil.toString(message));
+
+  protected setLimit = (
+    kind: ""min"" | ""max"",
+    value: number,
+    inclusive: boolean,
+    message?: string
+  ) =>
-      minimum: {
-        value: minimum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      maximum: {
-        value: maximum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind,
+          value,
+          inclusive,
+          message: errorUtil.toString(message),
+        },
+      ],
-      isInteger: { message: errorUtil.toString(message) },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""int"",
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+
+  get minValue() {
+    let min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      }
+    }
+    return min;
+  }
+
+  get maxValue() {
+    let max: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return max;
+  }
+
+  get isInt() {
+    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+  }
-export type ZodBigIntDef = ZodTypeDef;
+export interface ZodBigIntDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBigInt;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBigInt({});
+    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
-export type ZodBooleanDef = ZodTypeDef;
+export interface ZodBooleanDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBoolean;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBoolean({});
+    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
-export type ZodDateDef = ZodTypeDef;
+export interface ZodDateDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodDate;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-    return new ZodDate({});
+    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
-export type ZodUndefinedDef = ZodTypeDef;
-
-export class ZodUndefined extends ZodType<undefined> {
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+export interface ZodUndefinedDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUndefined;
+}
+
+export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodUndefined({});
+    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
-export type ZodNullDef = ZodTypeDef;
+export interface ZodNullDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNull;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodNull({});
+    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
-export type ZodAnyDef = ZodTypeDef;
+export interface ZodAnyDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodAny;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
+  _any: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-    return new ZodAny({});
+    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
-export type ZodUnknownDef = ZodTypeDef;
+export interface ZodUnknownDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUnknown;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // required
+  _unknown: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-    return new ZodUnknown({});
+    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
-export type ZodNeverDef = ZodTypeDef;
+export interface ZodNeverDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNever;
+}
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-    return new ZodNever({});
+    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
-export type ZodVoidDef = ZodTypeDef;
+export interface ZodVoidDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodVoid;
+}
-  _parse(ctx: ParseContext): any {
-    if (
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
-    ) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodVoid({});
+    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  typeName: ZodFirstPartyTypeKind.ZodArray;
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T[""_output""][],
+export type ArrayCardinality = ""many"" | ""atleastone"";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> = Cardinality extends ""atleastone""
+  ? [T[""_output""], ...T[""_output""][]]
+  : T[""_output""][];
+
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
-  T[""_input""][]
+  Cardinality extends ""atleastone""
+    ? [T[""_input""], ...T[""_input""][]]
+    : T[""_input""][]
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    return parseArray(ctx, data, parsedType, this._def) as any;
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def });
+  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
+    message?: any
+  ) => {
+    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
-    });
-  };
-}
-
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-//////////                            //////////
-//////////      ZodNonEmptyArray      //////////
-//////////                            //////////
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  type: T;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T[""_output""], ...T[""_output""][]],
-  ZodNonEmptyArrayDef<T>,
-  [T[""_input""], ...T[""_input""][]]
-> {
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
-  }
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      minLength: { value: minLength, message: errorUtil.toString(message) },
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      maxLength: { value: maxLength, message: errorUtil.toString(message) },
-    });
-
-  length = (len: number, message?: errorUtil.ErrMessage) =>
-    this.min(len, message).max(len, message);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
-    return new ZodNonEmptyArray({
-      type: schema,
-      minLength: null,
-      maxLength: null,
-    });
-  };
-}
+      typeName: ZodFirstPartyTypeKind.ZodArray,
+    });
+  };
+}
+
+export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, ""atleastone"">;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
+    typeName: ZodFirstPartyTypeKind.ZodObject,
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+  typeName: ZodFirstPartyTypeKind.ZodObject;
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else {
+    return schema;
+  }
+}
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = util.objectKeys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = util.objectKeys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
+   */
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+      typeName: ZodFirstPartyTypeKind.ZodObject,
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+  typeName: ZodFirstPartyTypeKind.ZodUnion;
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodUnion,
+  typeName: ZodFirstPartyTypeKind.ZodIntersection;
+}
+
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
+      typeName: ZodFirstPartyTypeKind.ZodIntersection,
+  typeName: ZodFirstPartyTypeKind.ZodTuple;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodTuple,
+  typeName: ZodFirstPartyTypeKind.ZodRecord;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodRecord,
+  typeName: ZodFirstPartyTypeKind.ZodMap;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodMap,
+  typeName: ZodFirstPartyTypeKind.ZodSet;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodSet,
+  typeName: ZodFirstPartyTypeKind.ZodFunction;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
+        const result = await fn(...(parsedArgs as any));
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
-      }
-    };
-    return validatedFunction;
+        return parsedReturns;
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+      });
+    }
+      typeName: ZodFirstPartyTypeKind.ZodFunction,
+  typeName: ZodFirstPartyTypeKind.ZodLazy;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodLazy,
+  typeName: ZodFirstPartyTypeKind.ZodLiteral;
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+  }
+
+  get value() {
+    return this._def.value;
+      typeName: ZodFirstPartyTypeKind.ZodLiteral,
+  typeName: ZodFirstPartyTypeKind.ZodEnum;
+}
+
+type Writeable<T> = { -readonly [P in keyof T]: T[P] };
+
+function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
+  values: T
+): ZodEnum<Writeable<T>>;
+function createZodEnum<U extends string, T extends [U, ...U[]]>(
+  values: T
+): ZodEnum<T>;
+function createZodEnum(values: any) {
+  return new ZodEnum({
+    values: values as any,
+    typeName: ZodFirstPartyTypeKind.ZodEnum,
+  }) as any;
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      values: values,
-    }) as any;
-  };
+  static create = createZodEnum;
+  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+  typeName: ZodFirstPartyTypeKind.ZodPromise;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
+      typeName: ZodFirstPartyTypeKind.ZodPromise,
-//////////      ZodEffects      //////////
+//////////        ZodEffects        //////////
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  : ZodEffects<T, T[""_output""]>;
+
+export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
+export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+  typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  innerType() {
+    return this._def.schema;
+  }
+
+  _parse(
+    ctx: ParseContext,
+    initialData: any,
+    initialParsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
-      addIssue: (arg: MakeErrorData) => {
-        ctx.addIssue(arg);
+      issueFound: false,
+      addIssue: function (arg: MakeErrorData) {
+        this.issueFound = true;
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((_res) => {
+                const issueFound = checkCtx.issueFound;
+                invalid = invalid || issueFound;
+                return acc;
+              });
+            }
+          } else {
+            const issueFound = checkCtx.issueFound;
+            invalid = invalid || issueFound;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    // }
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I[""_output""]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: ""transform"", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+  typeName: ZodFirstPartyTypeKind.ZodOptional;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+  typeName: ZodFirstPartyTypeKind.ZodNullable;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodNullable,
+  typeName: ZodFirstPartyTypeKind.ZodDefault;
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+export enum ZodFirstPartyTypeKind {
+  ZodString = ""ZodString"",
+  ZodNumber = ""ZodNumber"",
+  ZodBigInt = ""ZodBigInt"",
+  ZodBoolean = ""ZodBoolean"",
+  ZodDate = ""ZodDate"",
+  ZodUndefined = ""ZodUndefined"",
+  ZodNull = ""ZodNull"",
+  ZodAny = ""ZodAny"",
+  ZodUnknown = ""ZodUnknown"",
+  ZodNever = ""ZodNever"",
+  ZodVoid = ""ZodVoid"",
+  ZodArray = ""ZodArray"",
+  ZodObject = ""ZodObject"",
+  ZodUnion = ""ZodUnion"",
+  ZodIntersection = ""ZodIntersection"",
+  ZodTuple = ""ZodTuple"",
+  ZodRecord = ""ZodRecord"",
+  ZodMap = ""ZodMap"",
+  ZodSet = ""ZodSet"",
+  ZodFunction = ""ZodFunction"",
+  ZodLazy = ""ZodLazy"",
+  ZodLiteral = ""ZodLiteral"",
+  ZodEnum = ""ZodEnum"",
+  ZodEffects = ""ZodEffects"",
+  ZodNativeEnum = ""ZodNativeEnum"",
+  ZodOptional = ""ZodOptional"",
+  ZodNullable = ""ZodNullable"",
+  ZodDefault = ""ZodDefault"",
+  ZodPromise = ""ZodPromise"",
+}
+const preprocessType = ZodEffects.createWithPreprocess;
+  preprocessType as preprocess,","+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+      isCUID: false,","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
+  issueFound: boolean;
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
-  : ZodEffects<T, T[""_output""]>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
+
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""Synchronous parse encountered promise."");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
+        typeName: ZodFirstPartyTypeKind.ZodEffects,
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
+
-    return ZodUnion.create([this, option]);
+    return ZodUnion.create([this, option]) as any;
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
+      typeName: ZodFirstPartyTypeKind.ZodDefault,
+type ZodStringCheck =
+  | { kind: ""min""; value: number; message?: string }
+  | { kind: ""max""; value: number; message?: string }
+  | { kind: ""email""; message?: string }
+  | { kind: ""url""; message?: string }
+  | { kind: ""uuid""; message?: string }
+  | { kind: ""cuid""; message?: string }
+  | { kind: ""regex""; regex: RegExp; message?: string };
-  // validation: {
-  //   uuid?: true;
-  //   custom?: ((val: any) => boolean)[];
-  // };
-  isEmail: { message?: string } | false;
-  isURL: { message?: string } | false;
-  isUUID: { message?: string } | false;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+  checks: ZodStringCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodString;
+}
+
+const cuidRegex = /^c[^\s-]{8,}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-    if (this._def.isEmail && !emailRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""email"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isEmail.message,
-      });
-    }
-
-    if (this._def.isURL) {
-      try {
-        new URL(ctx.data);
-      } catch {
-        ctx.addIssue({
-          validation: ""url"",
-          code: ZodIssueCode.invalid_string,
-          message: this._def.isURL.message,
-        });
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""min"") {
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""string"",
+            inclusive: true,
+            message: check.message,
+            // ...errorUtil.errToObj(this._def.maxLength.message),
+          });
+        }
+      } else if (check.kind === ""email"") {
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""email"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""uuid"") {
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""uuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""cuid"") {
+        if (!cuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""cuid"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""url"") {
+        try {
+          new URL(data);
+        } catch {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""url"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""regex"") {
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            validation: ""regex"",
+            code: ZodIssueCode.invalid_string,
+            message: check.message,
+          });
+        }
-    if (this._def.isUUID && !uuidRegex.test(ctx.data)) {
-      ctx.addIssue({
-        validation: ""uuid"",
-        code: ZodIssueCode.invalid_string,
-        message: this._def.isUUID.message,
-      });
-    }
-
-    if (this._def.minLength !== null) {
-      if (ctx.data.length < this._def.minLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: this._def.minLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.minLength.message,
-          // ...errorUtil.errToObj(this._def.minLength.message),
-        });
-      }
-    }
-
-    if (this._def.maxLength !== null) {
-      if (ctx.data.length > this._def.maxLength.value) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: this._def.maxLength.value,
-          type: ""string"",
-          inclusive: true,
-          message: this._def.maxLength.message,
-          // ...errorUtil.errToObj(this._def.maxLength.message),
-        });
-      }
-    }
-
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-      isEmail: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""email"", ...errorUtil.errToObj(message) },
+      ],
-      isURL: errorUtil.errToObj(message),
+      checks: [
+        ...this._def.checks,
+        { kind: ""url"", ...errorUtil.errToObj(message) },
+      ],
-      isUUID: errorUtil.errToObj(message),
-    });
-
-  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) =>
-    this._regex(regexp, ""regex"", message);
+      checks: [
+        ...this._def.checks,
+        { kind: ""uuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""cuid"", ...errorUtil.errToObj(message) },
+      ],
+    });
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      checks: [
+        ...this._def.checks,
+        { kind: ""regex"", regex: regex, ...errorUtil.errToObj(message) },
+      ],
+    });
-      minLength: {
-        value: minLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""min"", value: minLength, ...errorUtil.errToObj(message) },
+      ],
-      maxLength: {
-        value: maxLength,
-        message: errorUtil.errToObj(message).message,
-      },
+      checks: [
+        ...this._def.checks,
+        { kind: ""max"", value: maxLength, ...errorUtil.errToObj(message) },
+      ],
+  get isEmail() {
+    return !!this._def.checks.find((ch) => ch.kind === ""email"");
+  }
+  get isURL() {
+    return !!this._def.checks.find((ch) => ch.kind === ""url"");
+  }
+  get isUUID() {
+    return !!this._def.checks.find((ch) => ch.kind === ""uuid"");
+  }
+  get minLength() {
+    let min: number | null = -Infinity;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) {
+          min = ch.value;
+        }
+      }
+    });
+    return min;
+  }
+  get maxLength() {
+    let max: number | null = null;
+    this._def.checks.map((ch) => {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) {
+          max = ch.value;
+        }
+      }
+    });
+    return max;
+  }
-      isEmail: false,
-      isURL: false,
-      isUUID: false,
-      minLength: null,
-      maxLength: null,
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodString,
+type ZodNumberCheck =
+  | { kind: ""min""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""max""; value: number; inclusive: boolean; message?: string }
+  | { kind: ""int""; message?: string };
-  minimum: null | { value: number; inclusive: boolean; message?: string };
-  maximum: null | { value: number; inclusive: boolean; message?: string };
-  isInteger: false | { message?: string };
+  checks: ZodNumberCheck[];
+  typeName: ZodFirstPartyTypeKind.ZodNumber;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
-
-    if (this._def.minimum) {
-      const MIN = this._def.minimum;
-      const tooSmall = MIN.inclusive
-        ? ctx.data < MIN.value
-        : ctx.data <= MIN.value;
-      if (tooSmall) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_small,
-          minimum: MIN.value,
-          type: ""number"",
-          inclusive: MIN.inclusive,
-          message: MIN.message,
-        });
+
+    let invalid = false;
+
+    for (const check of this._def.checks) {
+      if (check.kind === ""int"") {
+        if (!util.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.invalid_type,
+            expected: ""integer"",
+            received: ""float"",
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""min"") {
+        // const MIN = check.value;
+        const tooSmall = check.inclusive
+          ? data < check.value
+          : data <= check.value;
+        if (tooSmall) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_small,
+            minimum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
+      } else if (check.kind === ""max"") {
+        const tooBig = check.inclusive
+          ? data > check.value
+          : data >= check.value;
+        if (tooBig) {
+          invalid = true;
+          ctx.addIssue(data, {
+            code: ZodIssueCode.too_big,
+            maximum: check.value,
+            type: ""number"",
+            inclusive: check.inclusive,
+            message: check.message,
+          });
+        }
-    if (this._def.maximum) {
-      const MAX = this._def.maximum;
-      const tooBig = MAX.inclusive
-        ? ctx.data > MAX.value
-        : ctx.data >= MAX.value;
-      if (tooBig) {
-        ctx.addIssue({
-          code: ZodIssueCode.too_big,
-          maximum: MAX.value,
-          type: ""number"",
-          inclusive: MAX.inclusive,
-          message: MAX.message,
-        });
-      }
-    }
-
-    if (this._def.isInteger) {
-      if (!Number.isInteger(ctx.data)) {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_type,
-          expected: ""integer"",
-          received: ""float"",
-          message: this._def.isInteger.message,
-        });
-      }
-    }
-
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-      minimum: null,
-      maximum: null,
-      isInteger: false,
-    });
-  };
-
-  min = (minimum: number, message?: errorUtil.ErrMessage) =>
+      checks: [],
+      typeName: ZodFirstPartyTypeKind.ZodNumber,
+    });
+  };
+
+  gte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, true, errorUtil.toString(message));
+  min = this.gte;
+
+  gt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""min"", value, false, errorUtil.toString(message));
+
+  lte = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, true, errorUtil.toString(message));
+  max = this.lte;
+
+  lt = (value: number, message?: errorUtil.ErrMessage) =>
+    this.setLimit(""max"", value, false, errorUtil.toString(message));
+
+  protected setLimit = (
+    kind: ""min"" | ""max"",
+    value: number,
+    inclusive: boolean,
+    message?: string
+  ) =>
-      minimum: {
-        value: minimum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
-
-  max = (maximum: number, message?: errorUtil.ErrMessage) =>
-    new ZodNumber({
-      ...this._def,
-      maximum: {
-        value: maximum,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind,
+          value,
+          inclusive,
+          message: errorUtil.toString(message),
+        },
+      ],
-      isInteger: { message: errorUtil.toString(message) },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""int"",
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: false,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: false,
+          message: errorUtil.toString(message),
+        },
+      ],
-      maximum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""max"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
-      minimum: {
-        value: 0,
-        inclusive: true,
-        message: errorUtil.toString(message),
-      },
-    });
+      checks: [
+        ...this._def.checks,
+        {
+          kind: ""min"",
+          value: 0,
+          inclusive: true,
+          message: errorUtil.toString(message),
+        },
+      ],
+    });
+
+  get minValue() {
+    let min: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""min"") {
+        if (min === null || ch.value > min) min = ch.value;
+      }
+    }
+    return min;
+  }
+
+  get maxValue() {
+    let max: number | null = null;
+    for (const ch of this._def.checks) {
+      if (ch.kind === ""max"") {
+        if (max === null || ch.value < max) max = ch.value;
+      }
+    }
+    return max;
+  }
+
+  get isInt() {
+    return !!this._def.checks.find((ch) => ch.kind === ""int"");
+  }
-export type ZodBigIntDef = ZodTypeDef;
+export interface ZodBigIntDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBigInt;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBigInt({});
+    return new ZodBigInt({ typeName: ZodFirstPartyTypeKind.ZodBigInt });
-export type ZodBooleanDef = ZodTypeDef;
+export interface ZodBooleanDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodBoolean;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodBoolean({});
+    return new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean });
-export type ZodDateDef = ZodTypeDef;
+export interface ZodDateDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodDate;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-    return new ZodDate({});
+    return new ZodDate({ typeName: ZodFirstPartyTypeKind.ZodDate });
-export type ZodUndefinedDef = ZodTypeDef;
-
-export class ZodUndefined extends ZodType<undefined> {
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+export interface ZodUndefinedDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUndefined;
+}
+
+export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodUndefined({});
+    return new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined });
-export type ZodNullDef = ZodTypeDef;
+export interface ZodNullDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNull;
+}
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodNull({});
+    return new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull });
-export type ZodAnyDef = ZodTypeDef;
+export interface ZodAnyDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodAny;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
+  _any: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-    return new ZodAny({});
+    return new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny });
-export type ZodUnknownDef = ZodTypeDef;
+export interface ZodUnknownDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodUnknown;
+}
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  // required
+  _unknown: true = true;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-    return new ZodUnknown({});
+    return new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown });
-export type ZodNeverDef = ZodTypeDef;
+export interface ZodNeverDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodNever;
+}
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-    return new ZodNever({});
+    return new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever });
-export type ZodVoidDef = ZodTypeDef;
+export interface ZodVoidDef extends ZodTypeDef {
+  typeName: ZodFirstPartyTypeKind.ZodVoid;
+}
-  _parse(ctx: ParseContext): any {
-    if (
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
-    ) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-    return new ZodVoid({});
+    return new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid });
+  typeName: ZodFirstPartyTypeKind.ZodArray;
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-export class ZodArray<T extends ZodTypeAny> extends ZodType<
-  T[""_output""][],
+export type ArrayCardinality = ""many"" | ""atleastone"";
+type arrayOutputType<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> = Cardinality extends ""atleastone""
+  ? [T[""_output""], ...T[""_output""][]]
+  : T[""_output""][];
+
+export class ZodArray<
+  T extends ZodTypeAny,
+  Cardinality extends ArrayCardinality = ""many""
+> extends ZodType<
+  arrayOutputType<T, Cardinality>,
-  T[""_input""][]
+  Cardinality extends ""atleastone""
+    ? [T[""_input""], ...T[""_input""][]]
+    : T[""_input""][]
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<arrayOutputType<T, Cardinality>> {
+    return parseArray(ctx, data, parsedType, this._def) as any;
-  nonempty: () => ZodNonEmptyArray<T> = () => {
-    return new ZodNonEmptyArray({ ...this._def });
+  nonempty: (message?: errorUtil.ErrMessage) => ZodArray<T, ""atleastone""> = (
+    message?: any
+  ) => {
+    return this.min(1, message) as any; // new ZodArray({ ...this._def, cardinality:""atleastone"" });
-    });
-  };
-}
-
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-//////////                            //////////
-//////////      ZodNonEmptyArray      //////////
-//////////                            //////////
-////////////////////////////////////////////////
-////////////////////////////////////////////////
-export interface ZodNonEmptyArrayDef<T extends ZodTypeAny = ZodTypeAny>
-  extends ZodTypeDef {
-  type: T;
-  minLength: { value: number; message?: string } | null;
-  maxLength: { value: number; message?: string } | null;
-}
-
-export class ZodNonEmptyArray<T extends ZodTypeAny> extends ZodType<
-  [T[""_output""], ...T[""_output""][]],
-  ZodNonEmptyArrayDef<T>,
-  [T[""_input""], ...T[""_input""][]]
-> {
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
-  }
-
-  min = (minLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      minLength: { value: minLength, message: errorUtil.toString(message) },
-    });
-
-  max = (maxLength: number, message?: errorUtil.ErrMessage) =>
-    new ZodNonEmptyArray({
-      ...this._def,
-      maxLength: { value: maxLength, message: errorUtil.toString(message) },
-    });
-
-  length = (len: number, message?: errorUtil.ErrMessage) =>
-    this.min(len, message).max(len, message);
-
-  static create = <T extends ZodTypeAny>(schema: T): ZodNonEmptyArray<T> => {
-    return new ZodNonEmptyArray({
-      type: schema,
-      minLength: null,
-      maxLength: null,
-    });
-  };
-}
+      typeName: ZodFirstPartyTypeKind.ZodArray,
+    });
+  };
+}
+
+export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, ""atleastone"">;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
+    typeName: ZodFirstPartyTypeKind.ZodObject,
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+  typeName: ZodFirstPartyTypeKind.ZodObject;
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
+
+function deepPartialify(schema: ZodTypeAny): any {
+  if (schema instanceof ZodObject) {
+    const newShape: any = {};
+
+    for (const key in schema.shape) {
+      const fieldSchema = schema.shape[key];
+      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
+    }
+    return new ZodObject({
+      ...schema._def,
+      shape: () => newShape,
+    }) as any;
+  } else if (schema instanceof ZodArray) {
+    return ZodArray.create(deepPartialify(schema.element));
+  } else {
+    return schema;
+  }
+}
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = util.objectKeys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = util.objectKeys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = util.objectKeys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
+   */
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+      typeName: ZodFirstPartyTypeKind.ZodObject,
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-  deepPartial: () => partialUtil.RootDeepPartial<this> = () => {
-    const newShape: any = {};
-
-    for (const key in this.shape) {
-      const fieldSchema = this.shape[key];
-      if (fieldSchema instanceof ZodObject) {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : (fieldSchema.deepPartial() as any).optional();
-      } else {
-        newShape[key] = fieldSchema.isOptional()
-          ? fieldSchema
-          : fieldSchema.optional();
-      }
-    }
-    return new ZodObject({
-      ...this._def,
-      shape: () => newShape,
-    }) as any;
+  deepPartial: () => partialUtil.DeepPartial<this> = () => {
+    return deepPartialify(this) as any;
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+      typeName: ZodFirstPartyTypeKind.ZodObject,
+  typeName: ZodFirstPartyTypeKind.ZodUnion;
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodUnion,
+  typeName: ZodFirstPartyTypeKind.ZodIntersection;
+}
+
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
+      typeName: ZodFirstPartyTypeKind.ZodIntersection,
+  typeName: ZodFirstPartyTypeKind.ZodTuple;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodTuple,
+  typeName: ZodFirstPartyTypeKind.ZodRecord;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodRecord,
+  typeName: ZodFirstPartyTypeKind.ZodMap;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodMap,
+  typeName: ZodFirstPartyTypeKind.ZodSet;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
+      typeName: ZodFirstPartyTypeKind.ZodSet,
+  typeName: ZodFirstPartyTypeKind.ZodFunction;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
+      return INVALID;
+    }
+
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
+        const result = await fn(...(parsedArgs as any));
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
-          }
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
-      }
-    };
-    return validatedFunction;
+        return parsedReturns;
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+      });
+    }
+      typeName: ZodFirstPartyTypeKind.ZodFunction,
+  typeName: ZodFirstPartyTypeKind.ZodLazy;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodLazy,
+  typeName: ZodFirstPartyTypeKind.ZodLiteral;
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+  }
+
+  get value() {
+    return this._def.value;
+      typeName: ZodFirstPartyTypeKind.ZodLiteral,
+  typeName: ZodFirstPartyTypeKind.ZodEnum;
+}
+
+type Writeable<T> = { -readonly [P in keyof T]: T[P] };
+
+function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
+  values: T
+): ZodEnum<Writeable<T>>;
+function createZodEnum<U extends string, T extends [U, ...U[]]>(
+  values: T
+): ZodEnum<T>;
+function createZodEnum(values: any) {
+  return new ZodEnum({
+    values: values as any,
+    typeName: ZodFirstPartyTypeKind.ZodEnum,
+  }) as any;
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  static create = <U extends string, T extends [U, ...U[]]>(
-    values: T
-  ): ZodEnum<T> => {
-    return new ZodEnum({
-      values: values,
-    }) as any;
-  };
+  static create = createZodEnum;
+  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
+      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
+  typeName: ZodFirstPartyTypeKind.ZodPromise;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
+      typeName: ZodFirstPartyTypeKind.ZodPromise,
-//////////      ZodEffects      //////////
+//////////        ZodEffects        //////////
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  : ZodEffects<T, T[""_output""]>;
+
+export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
+export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;
+  typeName: ZodFirstPartyTypeKind.ZodEffects;
+  preprocess?: Mod<any>;
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  innerType() {
+    return this._def.schema;
+  }
+
+  _parse(
+    ctx: ParseContext,
+    initialData: any,
+    initialParsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
+    const preprocess = this._def.preprocess;
+
+    let data = initialData;
+    let parsedType: ZodParsedType = initialParsedType;
+    if (preprocess) {
+      data = preprocess.transform(initialData);
+      parsedType = getParsedType(data);
+    }
+
-      addIssue: (arg: MakeErrorData) => {
-        ctx.addIssue(arg);
+      issueFound: false,
+      addIssue: function (arg: MakeErrorData) {
+        this.issueFound = true;
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
+
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((_res) => {
+                const issueFound = checkCtx.issueFound;
+                invalid = invalid || issueFound;
+                return acc;
+              });
+            }
+          } else {
+            const issueFound = checkCtx.issueFound;
+            invalid = invalid || issueFound;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(ZodFirstPartyTypeKind.ZodEffectscannot be nested."");
+    // }
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+    });
+
+    return newTx;
+  };
+
+  static createWithPreprocess = <I extends ZodTypeAny>(
+    preprocess: (arg: unknown) => unknown,
+    schema: I
+  ): ZodEffects<I, I[""_output""]> => {
+    const newTx = new ZodEffects({
+      schema,
+      preprocess: { type: ""transform"", transform: preprocess },
+      typeName: ZodFirstPartyTypeKind.ZodEffects,
+  typeName: ZodFirstPartyTypeKind.ZodOptional;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+  typeName: ZodFirstPartyTypeKind.ZodNullable;
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
+      typeName: ZodFirstPartyTypeKind.ZodNullable,
+  typeName: ZodFirstPartyTypeKind.ZodDefault;
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));
+      typeName: ZodFirstPartyTypeKind.ZodOptional,
+export enum ZodFirstPartyTypeKind {
+  ZodString = ""ZodString"",
+  ZodNumber = ""ZodNumber"",
+  ZodBigInt = ""ZodBigInt"",
+  ZodBoolean = ""ZodBoolean"",
+  ZodDate = ""ZodDate"",
+  ZodUndefined = ""ZodUndefined"",
+  ZodNull = ""ZodNull"",
+  ZodAny = ""ZodAny"",
+  ZodUnknown = ""ZodUnknown"",
+  ZodNever = ""ZodNever"",
+  ZodVoid = ""ZodVoid"",
+  ZodArray = ""ZodArray"",
+  ZodObject = ""ZodObject"",
+  ZodUnion = ""ZodUnion"",
+  ZodIntersection = ""ZodIntersection"",
+  ZodTuple = ""ZodTuple"",
+  ZodRecord = ""ZodRecord"",
+  ZodMap = ""ZodMap"",
+  ZodSet = ""ZodSet"",
+  ZodFunction = ""ZodFunction"",
+  ZodLazy = ""ZodLazy"",
+  ZodLiteral = ""ZodLiteral"",
+  ZodEnum = ""ZodEnum"",
+  ZodEffects = ""ZodEffects"",
+  ZodNativeEnum = ""ZodNativeEnum"",
+  ZodOptional = ""ZodOptional"",
+  ZodNullable = ""ZodNullable"",
+  ZodDefault = ""ZodDefault"",
+  ZodPromise = ""ZodPromise"",
+}
+const preprocessType = ZodEffects.createWithPreprocess;
+  preprocessType as preprocess,"
colinhacks_zod,a1d2d089dd66ac0bbaf0fdd64709c66d796e83a3,Ignore deno playground,deno/lib/types.ts,"-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;","-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.","-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;"
colinhacks_zod,a1d2d089dd66ac0bbaf0fdd64709c66d796e83a3,Ignore deno playground,src/types.ts,"-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;","-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.","-   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   * If you want to pass through unknown properties, use `.passthrough()` instead.
-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;"
colinhacks_zod,076f93d160fe81c6d7fdc7cdde7049755e84d9d8,WIP,deno/lib/types.ts,+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);,"-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;","-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);"
colinhacks_zod,076f93d160fe81c6d7fdc7cdde7049755e84d9d8,WIP,src/types.ts,+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);,"-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;","-    const handleArgs = (
-      args: any,
-      parsedArgs:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedArgs.success) {
-        const issue = makeIssue(
-          args,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_arguments,
-            argumentsError: parsedArgs.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedArgs.data;
-    };
-
-    const handleReturns = (
-      returns: any,
-      parsedReturns:
-        | { success: true; data: any }
-        | { success: false; error: ZodError }
-    ): any => {
-      if (!parsedReturns.success) {
-        const issue = makeIssue(
-          returns,
-          pathToArray(ctx.path),
-          ctx.params.errorMap,
-          {
-            code: ZodIssueCode.invalid_return_type,
-            returnTypeError: parsedReturns.error,
-          }
-        );
-        throw new ZodError([issue]);
-      }
-      return parsedReturns.data;
-    };
+    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
+      return makeIssue(args, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_arguments,
+        argumentsError: error,
+      });
+    }
+
+    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
+      return makeIssue(returns, pathToArray(ctx.path), ctx.params.errorMap, {
+        code: ZodIssueCode.invalid_return_type,
+        returnTypeError: error,
+      });
+    }
-        const parsedArgs = handleArgs(
-          args,
-          await this._def.args.spa(args, params)
-        );
+        const error = new ZodError([]);
+        const parsedArgs = await this._def.args
+          .parseAsync(args, params)
+          .catch((e) => {
+            error.addIssue(makeArgsIssue(args, e));
+            throw error;
+          });
-        return handleReturns(
-          result,
-          await this._def.returns.spa(result, params)
-        );
+        const parsedReturns = await this._def.returns
+          .parseAsync(result, params)
+          .catch((e) => {
+            error.addIssue(makeReturnsIssue(result, e));
+            throw error;
+          });
+        return parsedReturns;
-        const parsedArgs = handleArgs(
-          args,
-          this._def.args.safeParse(args, params)
-        );
-        const result = fn(...(parsedArgs as any));
-        return handleReturns(
-          result,
-          this._def.returns.safeParse(result, params)
-        );
+        const parsedArgs = this._def.args.safeParse(args, params);
+        if (!parsedArgs.success) {
+          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
+        }
+        const result = fn(...(parsedArgs.data as any));
+        const parsedReturns = this._def.returns.safeParse(result, params);
+        if (!parsedReturns.success) {
+          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
+        }
+        return parsedReturns.data;
+    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);"
colinhacks_zod,fb1a57a19de876a636bdbec1cdc00be099aeb59d,FMC,deno/lib/playground.ts,"-  const propertySchema = z.string();
-  const schema = z
-    .object({
-      a: propertySchema,
-      b: propertySchema,
-    })
-    .refine(
-      (val) => {
-        return val.a === val.b;
-      },
-      { message: ""Must be equal"" }
-    );
+  const schema = z.object({
+    people: z.string().array().min(2),
+  });
-  try {
-    schema.parse({
-      a: ""asdf"",
-      b: ""qwer"",
-    });
-  } catch (error) {
-    if (error instanceof z.ZodError) {
-      console.log(error);
-      console.log(error.flatten((iss) => iss.code));
-    }
-  }
+  const result = schema.safeParse({
+    people: [1234],
+  });
+
+  console.log(result);","-import { z } from ""./index.ts"";
-
-const run = async () => {
-  z;
-
-  const propertySchema = z.string();
-  const schema = z
-    .object({
-      a: propertySchema,
-      b: propertySchema,
-    })
-    .refine(
-      (val) => {
-        return val.a === val.b;
-      },
-      { message: ""Must be equal"" }
-    );
-
-  try {
-    schema.parse({
-      a: ""asdf"",
-      b: ""qwer"",
-    });
-  } catch (error) {
-    if (error instanceof z.ZodError) {
-      console.log(error);
-      console.log(error.flatten((iss) => iss.code));
-    }
-  }
-};
-run();
-
-export {};","-
-  const propertySchema = z.string();
-  const schema = z
-    .object({
-      a: propertySchema,
-      b: propertySchema,
-    })
-    .refine(
-      (val) => {
-        return val.a === val.b;
-      },
-      { message: ""Must be equal"" }
-    );
-
-  try {
-    schema.parse({
-      a: ""asdf"",
-      b: ""qwer"",
-    });
-  } catch (error) {
-    if (error instanceof z.ZodError) {
-      console.log(error);
-      console.log(error.flatten((iss) => iss.code));
-    }
-  }"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,deno/lib/ZodError.ts,"-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,deno/lib/helpers/parseUtil.ts,"-  x === INVALID;
+  (x as any).valid === false;","-      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;","-      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
-  x === INVALID;
+  (x as any).valid === false;"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,deno/lib/types.ts,"+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (","-        if (!Number.isInteger(data)) {
+        if (!util.isInteger(data)) {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
-    const keys = Object.keys(shape);
+    const keys = util.objectKeys(shape);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-      const dataKeys = Object.keys(data);
+      const dataKeys = util.objectKeys(data);
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-    const bKeysSet = new Set(Object.keys(b));
-    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-        if (!Number.isInteger(data)) {
+        if (!util.isInteger(data)) {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-    const keys = Object.keys(shape);
+    const keys = util.objectKeys(shape);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-      const dataKeys = Object.keys(data);
+      const dataKeys = util.objectKeys(data);
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-    const bKeysSet = new Set(Object.keys(b));
-    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,package.json,"-  ""version"": ""3.5.1"",
+  ""version"": ""3.5.3"",","+    ""eslint-plugin-ban"": ""^1.5.2"",","-  ""version"": ""3.5.1"",
+  ""version"": ""3.5.3"",
+    ""eslint-plugin-ban"": ""^1.5.2"","
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,src/ZodError.ts,"-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      // eslint-disable-next-line ban/ban
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-  flatten = (): {
-    formErrors: string[];
-    fieldErrors: { [k: string]: string[] };
+  flatten = <U = string>(
+    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
+  ): {
+    formErrors: U[];
+    fieldErrors: { [k: string]: U[] };
-    const formErrors: string[] = [];
+    const formErrors: U[] = [];
-        fieldErrors[sub.path[0]].push(sub.message);
+        fieldErrors[sub.path[0]].push(mapper(sub));
-        formErrors.push(sub.message);
+        formErrors.push(mapper(sub));"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,src/helpers/parseUtil.ts,"-  x === INVALID;
+  (x as any).valid === false;","-      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;","-      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
+      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
-  x === INVALID;
+  (x as any).valid === false;"
colinhacks_zod,b90b2be71dbe51f3aa00cb5e9f2ccc0c5a609034,IE11 support,src/types.ts,"+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (","-        if (!Number.isInteger(data)) {
+        if (!util.isInteger(data)) {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
-    const keys = Object.keys(shape);
+    const keys = util.objectKeys(shape);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-      const dataKeys = Object.keys(data);
+      const dataKeys = util.objectKeys(data);
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-    const bKeysSet = new Set(Object.keys(b));
-    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-        if (!Number.isInteger(data)) {
+        if (!util.isInteger(data)) {
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
+    const firstKeys = util.objectKeys(first);
+    const secondKeys = util.objectKeys(second);
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-    const keys = Object.keys(shape);
+    const keys = util.objectKeys(shape);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-        const dataKeys = Object.keys(data);
+        const dataKeys = util.objectKeys(data);
-      const dataKeys = Object.keys(data);
+      const dataKeys = util.objectKeys(data);
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
-    Object.keys(mask).map((key) => {
+    util.objectKeys(mask).map((key) => {
-    Object.keys(this.shape).map((key) => {
-      if (Object.keys(mask).indexOf(key) === -1) {
+    util.objectKeys(this.shape).map((key) => {
+      if (util.objectKeys(mask).indexOf(key) === -1) {
-    const bKeysSet = new Set(Object.keys(b));
-    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+    const bKeys = util.objectKeys(b);
+    const sharedKeys = util
+      .objectKeys(a)
+      .filter((key) => bKeys.indexOf(key) !== -1);"
colinhacks_zod,337522b08d27a171346f231b52ba1f58c70b16af,Merge branch 'master' of github.com:vriad/zod,deno/lib/types.ts,"-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-      if (ch.kind === ""min"") {
+      if (ch.kind === ""max"") {","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-      if (ch.kind === ""min"") {
+      if (ch.kind === ""max"") {
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = ("
colinhacks_zod,337522b08d27a171346f231b52ba1f58c70b16af,Merge branch 'master' of github.com:vriad/zod,src/types.ts,"-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-      if (ch.kind === ""min"") {
+      if (ch.kind === ""max"") {","+
+  promise: () => ZodPromise<this> = () => ZodPromise.create(this);
-      if (ch.kind === ""min"") {
+      if (ch.kind === ""max"") {
-type extend<A, B> = {
+export type extendShape<A, B> = {
-  extend<ReturnType<Def[""shape""]>, Augmentation>,
+  extendShape<ReturnType<Def[""shape""]>, Augmentation>,
+export type SomeZodObject = ZodObject<
+  ZodRawShape,
+  UnknownKeysParam,
+  ZodTypeAny,
+  any,
+  any
+>;
-  ZodObject<extend<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = (
+  ZodObject<extendShape<T, Incoming[""_shape""]>, UnknownKeys, Catchall> = ("
colinhacks_zod,def91a0fe5c1c7b23c99e67f7fd8c90da40d673d,Update changelog,deno/lib/playground.ts,"-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);
+  z.string().parse(1234);
+
+  interface SyncHasMany<T> {
+    // ...
+    toArray(): T[];
+  }
+
+  function hasMany<T extends z.ZodTypeAny>(itemSchema: T) {
+    return z
+      .unknown()
+      .transform(
+        // z.array(itemSchema),
+        // In case it is hasMany we should convert it to plain Array so Zod can digest it.
+        (rel) =>
+          Array.isArray(rel)
+            ? (rel as z.TypeOf<T>[])
+            : (rel as SyncHasMany<z.TypeOf<T>>).toArray()
+      )
+      .refine((arr) => {
+        console.log(arr);
+        return arr.every((el) => itemSchema.safeParse(el).success);
+      });
+  }
+
+  const asdf = hasMany(z.string());
+  console.log(asdf.safeParse([""asdf"", ""qwer""]));","-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);
+
+  const Animal = z.object({
+    properties: z.object({
+      is_animal: z.boolean(),
+    }),
+  });
+  const Cat = z
+    .object({
+      properties: z.object({
+        jumped: z.boolean(),
+      }),
+    })
+    .and(Animal);
+
+  type Cat = z.infer<typeof Cat>;
+  // const cat:Cat = 'asdf' as any;
+  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
+  console.log(cat.properties);
+  console.log(cat.properties);","-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);"
colinhacks_zod,def91a0fe5c1c7b23c99e67f7fd8c90da40d673d,Update changelog,src/playground.ts,"-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);
+  z.string().parse(1234);
+
+  interface SyncHasMany<T> {
+    // ...
+    toArray(): T[];
+  }
+
+  function hasMany<T extends z.ZodTypeAny>(itemSchema: T) {
+    return z
+      .unknown()
+      .transform(
+        // z.array(itemSchema),
+        // In case it is hasMany we should convert it to plain Array so Zod can digest it.
+        (rel) =>
+          Array.isArray(rel)
+            ? (rel as z.TypeOf<T>[])
+            : (rel as SyncHasMany<z.TypeOf<T>>).toArray()
+      )
+      .refine((arr) => {
+        console.log(arr);
+        return arr.every((el) => itemSchema.safeParse(el).success);
+      });
+  }
+
+  const asdf = hasMany(z.string());
+  console.log(asdf.safeParse([""asdf"", ""qwer""]));","-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);
+
+  const Animal = z.object({
+    properties: z.object({
+      is_animal: z.boolean(),
+    }),
+  });
+  const Cat = z
+    .object({
+      properties: z.object({
+        jumped: z.boolean(),
+      }),
+    })
+    .and(Animal);
+
+  type Cat = z.infer<typeof Cat>;
+  // const cat:Cat = 'asdf' as any;
+  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
+  console.log(cat.properties);
+  console.log(cat.properties);","-class Test {
-  constructor(public readonly path: string) {}
-}
-
-const test = new Test(""asdf"");
-console.log(test.path);"
colinhacks_zod,f7f71f5219e0a08b130d3826f6d5abc22b3014cf,Merge branch 'master' into zod4,deno/lib/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeysSet = new Set(Object.keys(b));
+    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
+}
+
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));","+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   */","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   */
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeysSet = new Set(Object.keys(b));
+    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
+}
+
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));"
colinhacks_zod,f7f71f5219e0a08b130d3826f6d5abc22b3014cf,Merge branch 'master' into zod4,src/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeysSet = new Set(Object.keys(b));
+    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
+}
+
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));","+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   */","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
+  /**
+   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
+   * If you want to pass through unknown properies, use `.passthrough()` instead.
+   */
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
+function mergeValues(
+  a: any,
+  b: any
+): { valid: true; data: any } | { valid: false } {
+  const aType = getParsedType(a);
+  const bType = getParsedType(b);
+
+  if (a === b) {
+    return { valid: true, data: a };
+  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
+    const bKeysSet = new Set(Object.keys(b));
+    const sharedKeys = Object.keys(a).filter((key) => bKeysSet.has(key));
+
+    const newObj: any = { ...a, ...b };
+    for (const key of sharedKeys) {
+      const sharedValue = mergeValues(a[key], b[key]);
+      if (!sharedValue.valid) {
+        return { valid: false };
+      }
+      newObj[key] = sharedValue.data;
+    }
+
+    return { valid: true, data: newObj };
+  } else {
+    return { valid: false };
+  }
+}
+
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+
+      const merged = mergeValues(parsedLeft.value, parsedRight.value);
+      if (!merged.valid) {
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+      return OK(merged.data);
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));"
colinhacks_zod,3f204b30350c30f5ae1b3825aa3acca3ef616187,FMC,deno/lib/ZodError.ts,"-export class ZodError<T = any> extends Error {
+export class ZodError<T = any> {
-    super();
+    // super();
-    const actualProto = new.target.prototype;
-    Object.setPrototypeOf(this, actualProto);
+    // const actualProto = new.target.prototype;
+    // Object.setPrototypeOf(this, actualProto);","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-export class ZodError<T = any> extends Error {
+export class ZodError<T = any> {
-    super();
-    // restore prototype chain
-    const actualProto = new.target.prototype;
-    Object.setPrototypeOf(this, actualProto);"
colinhacks_zod,3f204b30350c30f5ae1b3825aa3acca3ef616187,FMC,deno/lib/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+      const parsedLeftValue = parsedLeft.value as any;
+      const parsedRightValue = parsedRight.value as any;
+      const parsedLeftType = getParsedType(parsedLeftValue);
+      const parsedRightType = getParsedType(parsedRightValue);
+
+      if (parsedLeftValue === parsedRightValue) {
+        return OK(parsedLeftValue);
-        return { ...parsedLeft, ...parsedRight };
+        return OK({ ...parsedLeftValue, ...parsedRightValue });
-        ctx.addIssue({
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));","-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util.ts"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise.ts"";
+import { util } from ""./helpers/util.ts"";
+import { PseudoPromise } from ""./PseudoPromise.ts"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+      const parsedLeftValue = parsedLeft.value as any;
+      const parsedRightValue = parsedRight.value as any;
+      const parsedLeftType = getParsedType(parsedLeftValue);
+      const parsedRightType = getParsedType(parsedRightValue);
+
+      if (parsedLeftValue === parsedRightValue) {
+        return OK(parsedLeftValue);
-        return { ...parsedLeft, ...parsedRight };
+        return OK({ ...parsedLeftValue, ...parsedRightValue });
-        ctx.addIssue({
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));"
colinhacks_zod,3f204b30350c30f5ae1b3825aa3acca3ef616187,FMC,src/ZodError.ts,"-export class ZodError<T = any> extends Error {
+export class ZodError<T = any> {
-    super();
+    // super();
-    const actualProto = new.target.prototype;
-    Object.setPrototypeOf(this, actualProto);
+    // const actualProto = new.target.prototype;
+    // Object.setPrototypeOf(this, actualProto);","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-export class ZodError<T = any> extends Error {
+export class ZodError<T = any> {
-    super();
-    // restore prototype chain
-    const actualProto = new.target.prototype;
-    Object.setPrototypeOf(this, actualProto);"
colinhacks_zod,3f204b30350c30f5ae1b3825aa3acca3ef616187,FMC,src/types.ts,"+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+      const parsedLeftValue = parsedLeft.value as any;
+      const parsedRightValue = parsedRight.value as any;
+      const parsedLeftType = getParsedType(parsedLeftValue);
+      const parsedRightType = getParsedType(parsedRightValue);
+
+      if (parsedLeftValue === parsedRightValue) {
+        return OK(parsedLeftValue);
-        return { ...parsedLeft, ...parsedRight };
+        return OK({ ...parsedLeftValue, ...parsedRightValue });
-        ctx.addIssue({
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));","-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;","+  ASYNC,
-  issueHelpers,
+  INVALID,
+  isAsync,
+  isInvalid,
+  isOk,
+  makeIssue,
+  OK,
-  ParseParams,
-  ParseParamsWithOptionals,
+  ParseReturnType,
+  pathFromArray,
+  pathToArray,
+  SyncParseReturnType,
-  ZodParserReturnType,
-import { INVALID, util } from ""./helpers/util"";
-import { NOSET, PseudoPromise } from ""./PseudoPromise"";
+import { util } from ""./helpers/util"";
+import { PseudoPromise } from ""./PseudoPromise"";
+  ZodIssue,
-type ParseReturnType<T> = T | INVALID | PseudoPromise<T | INVALID>;
+type AsyncTasks = Promise<void>[] | null;
+const createTasks = (ctx: ParseContext): AsyncTasks =>
+  ctx.params.async ? [] : null;
+
+const createRootContext = (params: Partial<ParseParamsNoData>): ParseContext =>
+  new ParseContext(pathFromArray(params.path || []), [], {
+    async: params.async ?? false,
+    errorMap: params.errorMap || overrideErrorMap,
+  });
+
+const handleResult = <Input, Output>(
+  ctx: ParseContext,
+  result: SyncParseReturnType<Output>,
+  parentError: ZodError | undefined
+):
+  | { success: true; data: Output }
+  | { success: false; error: ZodError<Input> } => {
+  if (isOk(result)) {
+    return { success: true, data: result.value };
+  } else {
+    parentError?.addIssues(ctx.issues);
+    const error = new ZodError(ctx.issues);
+    return { success: false, error };
+  }
+};
-  abstract _parse(_ctx: ParseContext): any;
-
-  _parseInternal(params: ParseParams): ZodParserReturnType<Output> {
-    const data = params.data;
-    let PROMISE: PseudoPromise<any>;
-    const ERROR = new ZodError([]);
-    const { makeIssue, addIssue } = issueHelpers(ERROR, { ...params });
-
-    const parsedType = getParsedType(data);
-    try {
-      const parsedValue = this._parse({
-        ...params,
-        currentError: ERROR,
-        makeIssue,
-        addIssue,
-        parsedType,
-      });
-
-      PROMISE =
-        parsedValue instanceof PseudoPromise
-          ? parsedValue
-          : PseudoPromise.resolve(parsedValue);
-    } catch (err) {
-      // default to invalid
-      PROMISE = PseudoPromise.resolve(INVALID);
-    }
-
-    const isSync = params.async === false || this instanceof ZodPromise;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ERROR.isEmpty) throw ERROR;
-      return data;
-    };
-
-    PROMISE = PROMISE.then(THROW_ERROR_IF_PRESENT(""post effects""))
-      .then((data) => {
-        return { success: true, data };
-      })
-      .catch((error) => {
-        params.parentError.addIssues(ERROR.issues);
-        if (error instanceof ZodError) return { success: false, error: error };
-        throw error;
-      });
-
-    return isSync ? PROMISE.getValueSync() : PROMISE.getValueAsync();
-  }
-
-  _parseInternalOptionalParams: (
-    params: ParseParamsWithOptionals
-  ) => ZodParserReturnType<Output> = (params) => {
-    // if(!params.data) throw
-
-    const fullParams: ParseParams = {
-      data: params.data,
-      path: params.path || [],
-      parentError: params.parentError || new ZodError([]),
-      errorMap: params.errorMap || overrideErrorMap,
-      async: params.async ?? false,
-    };
-
-    return this._parseInternal(fullParams);
-  };
+  abstract _parse(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<Output>;
+
+  _parseSync(
+    _ctx: ParseContext,
+    _data: any,
+    _parsedType: ZodParsedType
+  ): SyncParseReturnType<Output> {
+    const result = this._parse(_ctx, _data, _parsedType);
+    if (isAsync(result)) {
+      throw new Error(""TODO"");
+    }
+    return result;
+  }
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .parse() on a schema containing async elements. Use .parseAsync instead.""
-      );
+    const result = this.safeParse(data, params);
-    const result = this._parseInternalOptionalParams({ data, ...params });
-    if (result instanceof Promise)
-      throw new Error(
-        ""You can't use .safeParse() on a schema containing async elements. Use .parseAsync instead.""
-      );
-    return result;
+    const ctx = createRootContext({ ...params, async: false });
+    const result = this._parseSync(ctx, data, getParsedType(data));
+    return handleResult(ctx, result, params?.parentError);
-    const result = await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const result = await this.safeParseAsync(data, params);
-    return await this._parseInternalOptionalParams({
-      data,
-      ...params,
-      async: true,
-    });
+    const ctx = createRootContext({ ...params, async: true });
+    const maybeAsyncResult = this._parse(ctx, data, getParsedType(data));
+    const result = await (isAsync(maybeAsyncResult)
+      ? maybeAsyncResult.promise
+      : Promise.resolve(maybeAsyncResult));
+    return handleResult(ctx, result, params?.parentError);
-
-  _parseWithInvalidFallback: (
-    data: unknown,
-    params: ParseParamsNoData
-  ) => Promise<Output | INVALID> | Output | INVALID = (data, params) => {
-    const result = this._parseInternal({ ...params, data });
-    // const parser = ZodParser(this);
-    // const result = parser({ ...params, data });
-    if (result instanceof Promise) {
-      return result.then((result) => {
-        if (result.success) return result.data;
-        return INVALID;
-      });
-    }
-    if (result.success) return result.data;
-    return INVALID;
-  };
-    if (typeof message === ""string"" || typeof message === ""undefined"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            message,
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
-    if (typeof message === ""function"") {
-      return this._refinement((val, ctx) => {
-        const result = check(val);
-        const setError = () =>
-          ctx.addIssue({
-            code: ZodIssueCode.custom,
-            ...message(val),
-          });
-        if (result instanceof Promise) {
-          return result.then((data) => {
-            if (!data) setError();
-          });
-        }
-        if (!result) {
-          setError();
-          return result;
-        }
-      });
-    }
+    const getIssueProperties: any = (val: Output) => {
+      if (typeof message === ""string"" || typeof message === ""undefined"") {
+        return { message };
+      } else if (typeof message === ""function"") {
+        return message(val);
+      } else {
+        return message;
+      }
+    };
-          ...message,
+          ...getIssueProperties(val),
-          if (!data) setError();
+          if (!data) {
+            setError();
+            return false;
+          } else {
+            return true;
+          }
-
-        return result;
+        return false;
+      } else {
+        return true;
+        return false;
+      } else {
+        return true;
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-  _parse(ctx: ParseContext): ParseReturnType<string> {
-    if (ctx.parsedType !== ZodParsedType.string) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: string,
+    parsedType: ZodParsedType
+  ): ParseReturnType<string> {
+    if (parsedType !== ZodParsedType.string) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
+    let invalid = false;
-        if (ctx.data.length < check.value) {
-          ctx.addIssue({
+        if (data.length < check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (ctx.data.length > check.value) {
-          ctx.addIssue({
+        if (data.length > check.value) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!emailRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!emailRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!uuidRegex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!uuidRegex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          new URL(ctx.data);
+          new URL(data);
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-        if (!check.regex.test(ctx.data)) {
-          ctx.addIssue({
+        if (!check.regex.test(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.number) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: number,
+    parsedType: ZodParsedType
+  ): ParseReturnType<number> {
+    if (parsedType !== ZodParsedType.number) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-    if (Number.isNaN(ctx.data)) {
-      ctx.addIssue({
-        code: ZodIssueCode.invalid_type,
-        expected: ZodParsedType.number,
-        received: ZodParsedType.nan,
-      });
-
-      return INVALID;
-    }
+
+    let invalid = false;
-        if (!Number.isInteger(ctx.data)) {
-          ctx.addIssue({
+        if (!Number.isInteger(data)) {
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data < check.value
-          : ctx.data <= check.value;
+          ? data < check.value
+          : data <= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-          ? ctx.data > check.value
-          : ctx.data >= check.value;
+          ? data > check.value
+          : data >= check.value;
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
-    return ctx.data as number;
+    return invalid ? INVALID : OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.bigint) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: bigint,
+    parsedType: ZodParsedType
+  ): ParseReturnType<bigint> {
+    if (parsedType !== ZodParsedType.bigint) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.boolean) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: boolean,
+    parsedType: ZodParsedType
+  ): ParseReturnType<boolean> {
+    if (parsedType !== ZodParsedType.boolean) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.date) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: Date,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Date> {
+    if (parsedType !== ZodParsedType.date) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    if (isNaN(ctx.data.getTime())) {
-      ctx.addIssue({
+      return INVALID;
+    }
+    if (isNaN(data.getTime())) {
+      ctx.addIssue(data, {
-      return;
-    }
-
-    return new Date((ctx.data as Date).getTime());
+      return INVALID;
+    }
+
+    return OK(new Date((data as Date).getTime()));
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.undefined) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: undefined,
+    parsedType: ZodParsedType
+  ): ParseReturnType<undefined> {
+    if (parsedType !== ZodParsedType.undefined) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.null) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: null,
+    parsedType: ZodParsedType
+  ): ParseReturnType<null> {
+    if (parsedType !== ZodParsedType.null) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    return ctx.data;
+  _parse(
+    _ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<unknown> {
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<never> {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-    return;
+      received: parsedType,
+    });
+    return INVALID;
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<void> {
-      ctx.parsedType !== ZodParsedType.undefined &&
-      ctx.parsedType !== ZodParsedType.null
+      parsedType !== ZodParsedType.undefined &&
+      parsedType !== ZodParsedType.null
-      ctx.addIssue({
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-const parseArray = (ctx: ParseContext, def: ZodArrayDef<any>) => {
-  if (ctx.parsedType !== ZodParsedType.array) {
-    ctx.addIssue({
+const parseArray = <T>(
+  ctx: ParseContext,
+  data: any[],
+  parsedType: ZodParsedType,
+  def: ZodArrayDef<any>,
+  nonEmpty: boolean
+): ParseReturnType<T[]> => {
+  if (parsedType !== ZodParsedType.array) {
+    ctx.addIssue(data, {
-      received: ctx.parsedType,
-    });
-
-    return false;
-  }
-
+      received: parsedType,
+    });
+
+    return INVALID;
+  }
+
+  let invalid = false;
-    if (ctx.data.length < def.minLength.value) {
-      ctx.addIssue({
+    if (data.length < def.minLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-    if (ctx.data.length > def.maxLength.value) {
-      ctx.addIssue({
+    if (data.length > def.maxLength.value) {
+      invalid = true;
+      ctx.addIssue(data, {
-  return true;
+  if (nonEmpty && data.length < 1) {
+    invalid = true;
+    ctx.addIssue(data, {
+      code: ZodIssueCode.too_small,
+      minimum: 1,
+      type: ""array"",
+      inclusive: true,
+      // message: this._def.minLength.message,
+      // ...errorUtil.errToObj(this._def.minLength.message),
+    });
+  }
+
+  if (invalid) {
+    return INVALID;
+  }
+
+  const tasks = createTasks(ctx);
+  const result: T[] = new Array(data.length);
+  const type = def.type;
+  const handleParsed = (
+    index: number,
+    parsedItem: ParseReturnType<T>
+  ): void => {
+    if (isOk(parsedItem)) {
+      result[index] = parsedItem.value;
+    } else if (isInvalid(parsedItem)) {
+      invalid = true;
+    } else {
+      tasks?.push(
+        parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+      );
+    }
+  };
+
+  data.forEach((item, index) => {
+    handleParsed(
+      index,
+      type._parse(ctx.stepInto(index), item, getParsedType(item))
+    );
+  });
+
+  if (tasks !== null && tasks.length > 0) {
+    return ASYNC(
+      Promise.all(tasks).then(() => (invalid ? INVALID : OK(result)))
+    );
+  } else {
+    return invalid ? INVALID : OK(result);
+  }
-  _parse(ctx: ParseContext): any {
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""][]> {
+    const nonEmpty = false;
+    return parseArray(ctx, data, parsedType, this._def, nonEmpty);
-  _parse(ctx: ParseContext): any {
-    // if (ctx.parsedType !== ZodParsedType.array) {
-    //   ctx.addIssue({
-    //     code: ZodIssueCode.invalid_type,
-    //     expected: ZodParsedType.array,
-    //     received: ctx.parsedType,
-    //   });
-
-    //   return;
-    // }
-
-    const result = parseArray(ctx, this._def);
-    if (!result) return;
-
-    if (ctx.data.length < 1) {
-      ctx.addIssue({
-        code: ZodIssueCode.too_small,
-        minimum: 1,
-        type: ""array"",
-        inclusive: true,
-        // message: this._def.minLength.message,
-        // ...errorUtil.errToObj(this._def.minLength.message),
-      });
-    }
-
-    return PseudoPromise.all(
-      (ctx.data as any[]).map((item, i) => {
-        return new PseudoPromise().then(() =>
-          this._def.type._parseWithInvalidFallback(item, {
-            ...ctx,
-            path: [...ctx.path, i],
-            parentError: ctx.currentError,
-          })
-        );
-      }) as any
-    );
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<[T[""_output""], ...T[""_output""][]]> {
+    const nonEmpty = true;
+    return parseArray(
+      ctx,
+      data,
+      parsedType,
+      this._def,
+      nonEmpty
+    ) as ParseReturnType<[T[""_output""], ...T[""_output""][]]>;
-    [k in keyof T]: undefined extends T[k] ? k : never;
+    [k in keyof T]: unknown extends T[k]
+      ? never
+      : undefined extends T[k]
+      ? k
+      : never;
-
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  private _cached: { shape: T; keys: string[] } | null = null;
+
+  _getCached(): { shape: T; keys: string[] } {
+    if (this._cached !== null) return this._cached;
+    const shape = this._def.shape();
+    const keys = Object.keys(shape);
+    return (this._cached = { shape, keys });
+  }
+
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-
-    const shape = this._def.shape();
-    const shapeKeys = Object.keys(shape);
-    const dataKeys = Object.keys(ctx.data);
-
-    const extraKeys = dataKeys.filter((k) => shapeKeys.indexOf(k) === -1);
+      return INVALID;
+    }
+
+    const { shape, keys: shapeKeys } = this._getCached();
+
+    let invalid = false;
+    const tasks = createTasks(ctx);
+    const resultObject: Record<string, any> = {};
+
+    const handleParsed = (
+      key: string,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedValue)) {
+        const value = parsedValue.value;
+        if (typeof value !== ""undefined"" || key in data) {
+          // key was valid but result was undefined: add it to the result object
+          // only if key was in the input data object - if it wasn't, then it's
+          // an optional key that should not be added
+          resultObject[key] = value;
+        }
+      } else if (isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedValue.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
-      const keyValidator = shapeKeys.includes(key)
-        ? shape[key]
-        : !(this._def.catchall instanceof ZodNever)
-        ? this._def.catchall
-        : undefined;
-
-      if (!keyValidator) {
-        continue;
-      }
-
-      // if value for key is not set
-      // and schema is optional
-      // don't add the
-      // first check is required to avoid non-enumerable keys
-      if (typeof ctx.data[key] === ""undefined"" && !dataKeys.includes(key)) {
-        objectPromises[key] = new PseudoPromise()
-          .then(() => {
-            return keyValidator._parseWithInvalidFallback(undefined, {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            });
-          })
-
-          .then((data) => {
-            if (data === undefined) {
-              // schema is optional
-              // data is not defined
-              // don't explicity add `key: undefined` to outut
-              // this is a feature of PseudoPromises
-              return NOSET;
-            } else {
-              return data;
-            }
-          });
-
-        continue;
-      }
-
-      objectPromises[key] = new PseudoPromise()
-        .then(() => {
-          return keyValidator._parseWithInvalidFallback(ctx.data[key], {
-            ...ctx,
-            path: [...ctx.path, key],
-            parentError: ctx.currentError,
-          });
-        })
-        .then((data) => {
-          return data;
-        });
+      const keyValidator = shape[key];
+      const value = data[key];
+      handleParsed(
+        key,
+        keyValidator._parse(ctx.stepInto(key), value, getParsedType(value))
+      );
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          objectPromises[key] = PseudoPromise.resolve(ctx.data[key]);
+          resultObject[key] = data[key];
+        const dataKeys = Object.keys(data);
+        const extraKeys = dataKeys.filter((k) => !(k in shape));
-          ctx.addIssue({
+          invalid = true;
+          ctx.addIssue(data, {
+      const catchall = this._def.catchall;
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter((k) => !(k in shape));
-        objectPromises[key] = new PseudoPromise().then(() => {
-          const parsedValue = this._def.catchall._parseWithInvalidFallback(
-            ctx.data[key],
-            {
-              ...ctx,
-              path: [...ctx.path, key],
-              parentError: ctx.currentError,
-            }
-          );
-
-          return parsedValue;
-        });
+        const value = data[key];
+        handleParsed(
+          key,
+          catchall._parse(ctx.stepInto(key), value, getParsedType(value))
+        );
-    return PseudoPromise.object(objectPromises).then((data) => {
-      return data;
-    });
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() =>
+          invalid ? INVALID : OK(resultObject as Output)
+        )
+      );
+    } else {
+      return invalid ? INVALID : OK(resultObject as Output);
+    }
-  _parse(ctx: ParseContext): any {
-    const unionErrors: ZodError[] = [...Array(this._def.options.length)].map(
-      () => new ZodError([])
-    );
-
-    return PseudoPromise.all(
-      this._def.options.map((opt, _j) => {
-        return new PseudoPromise().then(() => {
-          return opt._parseWithInvalidFallback(ctx.data, {
-            ...ctx,
-            parentError: unionErrors[_j],
-          });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[number][""_output""]> {
+    const options = this._def.options;
+    const noMatch = (allIssues: ZodIssue[][]) => {
+      const unionErrors = allIssues.map((issues) => new ZodError(issues));
+      const nonTypeErrors = unionErrors.filter((err) => {
+        return err.issues[0].code !== ""invalid_type"";
+      });
+      if (nonTypeErrors.length === 1) {
+        // TODO encapsulate
+        nonTypeErrors[0].issues.forEach((issue) => ctx.issues.push(issue));
+      } else {
+        ctx.addIssue(data, {
+          code: ZodIssueCode.invalid_union,
+          unionErrors,
-      }) as any
-    )
-      .then((unionResults) => {
-        const isValid = !!unionErrors.find((err) => err.isEmpty);
-        const GUESSING = false;
-
-        if (!isValid) {
-          if (!GUESSING) {
-            ctx.addIssue({
-              code: ZodIssueCode.invalid_union,
-              unionErrors,
-            });
-          } else {
-            const nonTypeErrors = unionErrors.filter((err) => {
-              return err.issues[0].code !== ""invalid_type"";
-            });
-            if (nonTypeErrors.length === 1) {
-              ctx.currentError.addIssues(nonTypeErrors[0].issues);
-            } else {
-              ctx.addIssue({
-                code: ZodIssueCode.invalid_union,
-                unionErrors,
-              });
-            }
+      }
+      return INVALID;
+    };
+
+    if (ctx.params.async) {
+      const contexts = options.map(
+        () => new ParseContext(ctx.path, [], ctx.params)
+      );
+      return PseudoPromise.all(
+        options.map((option, index) =>
+          option._parse(contexts[index], data, parsedType)
+        )
+      ).then((parsedOptions) => {
+        for (const parsedOption of parsedOptions) {
+          if (isOk(parsedOption)) {
+            return parsedOption;
-
-        return unionResults;
-      })
-      .then((unionResults: any) => {
-        const validIndex = unionErrors.indexOf(
-          unionErrors.find((err) => err.isEmpty)!
-        );
-        return unionResults[validIndex];
+        return noMatch(contexts.map((ctx) => ctx.issues));
+    } else {
+      const allIssues: ZodIssue[][] = [];
+      for (const option of options) {
+        const optionCtx = new ParseContext(ctx.path, [], ctx.params);
+        const parsedOption = option._parseSync(optionCtx, data, parsedType);
+        if (isInvalid(parsedOption)) {
+          allIssues.push(optionCtx.issues);
+        } else {
+          return parsedOption;
+        }
+      }
+      return noMatch(allIssues);
+    }
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T & U> {
+    const handleParsed = (
+      parsedLeft: SyncParseReturnType<T>,
+      parsedRight: SyncParseReturnType<U>
+    ): SyncParseReturnType<T & U> => {
+      if (isInvalid(parsedLeft) || isInvalid(parsedRight)) {
+        return INVALID;
+      }
+      const parsedLeftValue = parsedLeft.value as any;
+      const parsedRightValue = parsedRight.value as any;
+      const parsedLeftType = getParsedType(parsedLeftValue);
+      const parsedRightType = getParsedType(parsedRightValue);
+
+      if (parsedLeftValue === parsedRightValue) {
+        return OK(parsedLeftValue);
-        return { ...parsedLeft, ...parsedRight };
+        return OK({ ...parsedLeftValue, ...parsedRightValue });
-        ctx.addIssue({
+        ctx.addIssue(data, {
+        return INVALID;
-    });
+    };
+
+    if (ctx.params.async) {
+      return PseudoPromise.all([
+        this._def.left._parse(ctx, data, parsedType),
+        this._def.right._parse(ctx, data, parsedType),
+      ]).then(([left, right]: any) => handleParsed(left, right));
+    } else {
+      return handleParsed(
+        this._def.left._parseSync(ctx, data, parsedType),
+        this._def.right._parseSync(ctx, data, parsedType)
+      );
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.array) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.array) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    if (ctx.data.length > this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    }
+
+    if (data.length > this._def.items.length) {
+      ctx.addIssue(data, {
-    } else if (ctx.data.length < this._def.items.length) {
-      ctx.addIssue({
+      return INVALID;
+    } else if (data.length < this._def.items.length) {
+      ctx.addIssue(data, {
-    }
-
-    const tupleData: any[] = ctx.data;
-
-    return PseudoPromise.all(
-      tupleData.map((item, index) => {
-        const itemParser = this._def.items[index];
-
-        if (!itemParser) {
-          // tupleData length != ZodTuple.items length
-          // this issue already addressed above
-          return PseudoPromise.resolve(item);
-        }
-        return new PseudoPromise()
-          .then(() => {
-            return itemParser._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, index],
-              parentError: ctx.currentError,
-            });
-          })
-          .then((tupleItem) => {
-            return tupleItem;
-          });
-      }) as any
-    );
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const items = this._def.items as ZodType<any>[];
+    const parseResult: any[] = new Array(items.length);
+    let invalid = false;
+
+    const handleParsed = (index: number, parsedItem: ParseReturnType<any>) => {
+      if (isOk(parsedItem)) {
+        parseResult[index] = parsedItem.value;
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedItem.promise.then((parsed) => handleParsed(index, parsed))
+        );
+      }
+    };
+
+    items.forEach((item, index) => {
+      handleParsed(
+        index,
+        item._parse(
+          ctx.stepInto(index),
+          data[index],
+          getParsedType(data[index])
+        )
+      );
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.object) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Record<string, any>> {
+    if (parsedType !== ZodParsedType.object) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-
-      return;
-    }
-
-    const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
-    for (const key in ctx.data) {
-      parsedRecordPromises[key] = new PseudoPromise().then(() => {
-        return this._def.valueType._parseWithInvalidFallback(ctx.data[key], {
-          ...ctx,
-          path: [...ctx.path, key],
-          parentError: ctx.currentError,
-        });
-      });
-    }
-    return PseudoPromise.object(parsedRecordPromises);
+      return INVALID;
+    }
+
+    const tasks = createTasks(ctx);
+    const valueType = this._def.valueType;
+    const parseResult: Record<string, ParseReturnType<any>> = {};
+    let invalid = false;
+    const handleParsed = (
+      key: string,
+      parsedKey: ParseReturnType<any>
+    ): void => {
+      if (isOk(parsedKey)) {
+        parseResult[key] = parsedKey.value;
+      } else if (isInvalid(parsedKey)) {
+        invalid = true;
+      } else {
+        tasks?.push(
+          parsedKey.promise.then((parsed) => handleParsed(key, parsed))
+        );
+      }
+    };
+
+    for (const key in data) {
+      handleParsed(
+        key,
+        valueType._parse(ctx.stepInto(key), data[key], getParsedType(data[key]))
+      );
+    }
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.map) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Map<any, any>> {
+    if (parsedType !== ZodParsedType.map) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataMap: Map<unknown, unknown> = ctx.data;
-    const returnedMap = new Map();
-
-    return PseudoPromise.all(
-      [...dataMap.entries()].map(([key, value], index) => {
-        return PseudoPromise.all([
-          new PseudoPromise().then(() => {
-            return this._def.keyType._parseWithInvalidFallback(key, {
-              ...ctx,
-              path: [...ctx.path, index, ""key""],
-              parentError: ctx.currentError,
-            });
-          }),
-          new PseudoPromise().then(() => {
-            const mapValue = this._def.valueType._parseWithInvalidFallback(
-              value,
-              {
-                ...ctx,
-                path: [...ctx.path, index, ""value""],
-                parentError: ctx.currentError,
-              }
-            );
-
-            return mapValue;
-          }),
-        ]).then((item: any) => {
-          returnedMap.set(item[0], item[1]);
-        });
-      }) as any
-    ).then(() => {
-      return returnedMap;
-    });
+      return INVALID;
+    }
+
+    const keyType = this._def.keyType;
+    const valueType = this._def.valueType;
+    const dataMap: Map<unknown, unknown> = data;
+    const parseResult = new Map();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+    const handleParsed = (
+      parsedKey: ParseReturnType<any>,
+      parsedValue: ParseReturnType<any>
+    ): void => {
+      if (isAsync(parsedKey) || isAsync(parsedValue)) {
+        tasks?.push(
+          PseudoPromise.all([parsedKey, parsedValue]).promise.then(([k, v]) =>
+            handleParsed(k, v)
+          )
+        );
+      } else if (isInvalid(parsedKey) || isInvalid(parsedValue)) {
+        invalid = true;
+      } else {
+        parseResult.set(parsedKey.value, parsedValue.value);
+      }
+    };
+
+    [...dataMap.entries()].forEach(([key, value], index) => {
+      const entryCtx = ctx.stepInto(index);
+      const parsedKey = keyType._parse(
+        entryCtx.stepInto(""key""),
+        key,
+        getParsedType(key)
+      );
+      const parsedValue = valueType._parse(
+        entryCtx.stepInto(""value""),
+        value,
+        getParsedType(value)
+      );
+      handleParsed(parsedKey, parsedValue);
+    });
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parseResult)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parseResult);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.set) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Set<any>> {
+    if (parsedType !== ZodParsedType.set) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const dataSet: Set<unknown> = ctx.data;
-    const returnedSet = new Set();
-
-    return PseudoPromise.all(
-      [...dataSet.values()].map((item, i) => {
-        return new PseudoPromise()
-          .then(() =>
-            this._def.valueType._parseWithInvalidFallback(item, {
-              ...ctx,
-              path: [...ctx.path, i],
-              parentError: ctx.currentError,
-            })
-          )
-          .then((item) => {
-            returnedSet.add(item);
-          });
-      }) as any
-    ).then(() => {
-      return returnedSet;
-    });
+      return INVALID;
+    }
+
+    const dataSet: Set<unknown> = data;
+    const valueType = this._def.valueType;
+    const parsedSet = new Set();
+    const tasks = createTasks(ctx);
+    let invalid = false;
+
+    const handleParsed = (parsedItem: ParseReturnType<any>): void => {
+      if (isOk(parsedItem)) {
+        parsedSet.add(parsedItem.value);
+      } else if (isInvalid(parsedItem)) {
+        invalid = true;
+      } else {
+        tasks?.push(parsedItem.promise.then((parsed) => handleParsed(parsed)));
+      }
+    };
+
+    [...dataSet.values()].forEach((item, i) =>
+      handleParsed(valueType._parse(ctx.stepInto(i), item, getParsedType(item)))
+    );
+
+    if (tasks !== null && tasks.length > 0) {
+      return ASYNC(
+        Promise.all(tasks).then(() => (invalid ? INVALID : OK(parsedSet)))
+      );
+    } else {
+      return invalid ? INVALID : OK(parsedSet);
+    }
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.function) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<any> {
+    if (parsedType !== ZodParsedType.function) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
-    }
-
-    const isAsyncFunction = this._def.returns instanceof ZodPromise;
-
-    const validatedFunction = (...args: any[]) => {
-      const argsError = new ZodError([]);
-      const returnsError = new ZodError([]);
-      const internalProm = new PseudoPromise()
-        .then(() => {
-          return this._def.args._parseWithInvalidFallback(args as any, {
-            ...ctx,
-            parentError: argsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((args) => {
-          if (!argsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_arguments,
-              argumentsError: argsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+      return INVALID;
+    }
+
+    const handleArgs = (
+      args: any,
+      parsedArgs:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedArgs.success) {
+        const issue = makeIssue(
+          args,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_arguments,
+            argumentsError: parsedArgs.error,
-
-          return args;
-        })
-        .then((args) => {
-          return ctx.data(...(args as any));
-        })
-        .then((result) => {
-          return this._def.returns._parseWithInvalidFallback(result, {
-            ...ctx,
-            parentError: returnsError,
-            async: isAsyncFunction,
-          });
-        })
-        .then((result) => {
-          if (!returnsError.isEmpty) {
-            const newError = new ZodError([]);
-            const issue = ctx.makeIssue({
-              code: ZodIssueCode.invalid_return_type,
-              returnTypeError: returnsError,
-            });
-            newError.addIssue(issue);
-            throw newError;
+        );
+        throw new ZodError([issue]);
+      }
+      return parsedArgs.data;
+    };
+
+    const handleReturns = (
+      returns: any,
+      parsedReturns:
+        | { success: true; data: any }
+        | { success: false; error: ZodError }
+    ): any => {
+      if (!parsedReturns.success) {
+        const issue = makeIssue(
+          returns,
+          pathToArray(ctx.path),
+          ctx.params.errorMap,
+          {
+            code: ZodIssueCode.invalid_return_type,
+            returnTypeError: parsedReturns.error,
-          return result;
-        });
-
-      if (isAsyncFunction) {
-        return internalProm.getValueAsync();
-      } else {
-        return internalProm.getValueSync();
+        );
+        throw new ZodError([issue]);
+      return parsedReturns.data;
-    return validatedFunction;
+
+    const params = { errorMap: ctx.params.errorMap };
+    const fn = data;
+
+    if (this._def.returns instanceof ZodPromise) {
+      return OK(async (...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          await this._def.args.spa(args, params)
+        );
+        const result = await fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          await this._def.returns.spa(result, params)
+        );
+      });
+    } else {
+      return OK((...args: any[]) => {
+        const parsedArgs = handleArgs(
+          args,
+          this._def.args.safeParse(args, params)
+        );
+        const result = fn(...(parsedArgs as any));
+        return handleReturns(
+          result,
+          this._def.returns.safeParse(result, params)
+        );
+      });
+    }
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<output<T>> {
-    return PseudoPromise.resolve(
-      lazySchema._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      })
-    );
+    return lazySchema._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.data !== this._def.value) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T> {
+    if (data !== this._def.value) {
+      ctx.addIssue(data, {
-        received: ctx.data,
+        received: data,
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (this._def.values.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[number]> {
+    if (this._def.values.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    _parsedType: ZodParsedType
+  ): ParseReturnType<T[keyof T]> {
-    if (nativeEnumValues.indexOf(ctx.data) === -1) {
-      ctx.addIssue({
+    if (nativeEnumValues.indexOf(data) === -1) {
+      ctx.addIssue(data, {
-      return;
-    }
-    return ctx.data;
+      return INVALID;
+    }
+    return OK(data);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType !== ZodParsedType.promise && ctx.async === false) {
-      ctx.addIssue({
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Promise<T[""_output""]>> {
+    if (parsedType !== ZodParsedType.promise && ctx.params.async === false) {
+      ctx.addIssue(data, {
-        received: ctx.parsedType,
+        received: parsedType,
-      return;
+      return INVALID;
-      ctx.parsedType === ZodParsedType.promise
-        ? ctx.data
-        : Promise.resolve(ctx.data);
-    const promiseError = new ZodError([]);
-    return PseudoPromise.resolve(
-      promisified
-        .then((data: any) => {
-          const value = this._def.type._parseWithInvalidFallback(data, {
-            ...ctx,
-            parentError: promiseError,
-          });
-          return value;
-        })
-        .then((data: any) => {
-          if (!promiseError.isEmpty) {
-            throw promiseError;
-          }
-          return data;
-        })
+      parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+    return OK(
+      promisified.then((data: any) => {
+        return this._def.type.parseAsync(data, {
+          path: pathToArray(ctx.path),
+          errorMap: ctx.params.errorMap,
+        });
+      })
-  refinement: (arg: T, ctx: RefinementCtx) => any;
+  refinement: (arg: T, ctx: RefinementCtx) => boolean | Promise<boolean>;
-  // transform<NewOut, Inner extends ZodTypeAny = T>(
-  //   transform: (arg: Output) => NewOut | Promise<NewOut>
-  // ): ZodEffects<Inner, NewOut> {
-  //   return new ZodEffects({
-  //     ...this._def,
-  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
-  //   }) as any;
-  // }
-
-  _parse(ctx: ParseContext): any {
-    const isSync = ctx.async === false || this instanceof ZodPromise;
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<Output> {
+    const isSync = ctx.params.async === false;
-        ctx.addIssue(arg);
+        ctx.addIssue(data, arg);
-      path: ctx.path,
+      get path() {
+        return pathToArray(ctx.path);
+      },
-    // let refinementError: Error | null = null;
-
-    const THROW_ERROR_IF_PRESENT = (key: string) => (data: any) => {
-      key;
-      if (!ctx.currentError.isEmpty) throw ctx.currentError;
-      // if (ctx.data === INVALID) throw ctx.currentError;
-      // if (refinementError !== null) throw refinementError;
-      return data;
+    let invalid = false;
+    const applyEffect = (
+      acc: any,
+      effect: Effect<any>
+    ): SyncParseReturnType<any> | Promise<SyncParseReturnType<any>> => {
+      switch (effect.type) {
+        case ""refinement"":
+          const result = effect.refinement(acc, checkCtx);
+          if (result instanceof Promise) {
+            if (isSync) {
+              throw new Error(
+                ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+              );
+            } else {
+              return result.then((res) => {
+                invalid = invalid || !res;
+                return acc;
+              });
+            }
+          } else {
+            invalid = invalid || !result;
+            return acc;
+          }
+        case ""transform"":
+          const transformed = effect.transform(acc);
+          if (transformed instanceof Promise && isSync) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return transformed;
+        default:
+          throw new Error(`Invalid effect type.`);
+      }
-    let finalPromise = new PseudoPromise()
-      .then(() => {
-        return this._def.schema._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      })
-      .then(THROW_ERROR_IF_PRESENT(""pre-refinement""));
-
-    for (const effect of effects) {
-      if (effect.type === ""refinement"") {
-        finalPromise = finalPromise
-          .all((data) => {
-            return [
-              PseudoPromise.resolve(data),
-              PseudoPromise.resolve(data).then(() => {
-                const result = effect.refinement(data, checkCtx);
-
-                if (isSync && result instanceof Promise)
-                  throw new Error(
-                    ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-                  );
-                return result;
-              }),
-            ];
+    if (isSync) {
+      const base = this._def.schema._parseSync(ctx, data, parsedType);
+      if (isOk(base)) {
+        const result = effects.reduce(applyEffect, base.value);
+        return invalid ? INVALID : OK(result);
+      } else {
+        return INVALID;
+      }
+    } else {
+      const applyAsyncEffects = (base: any): ParseReturnType<any> => {
+        const result = effects.reduce((acc, eff) => {
+          return acc instanceof Promise
+            ? acc.then((val) => applyEffect(val, eff))
+            : applyEffect(acc, eff);
+        }, base);
+        if (result instanceof Promise) {
+          return ASYNC(
+            result.then((val: Output) => (invalid ? INVALID : OK(val)))
+          );
+        } else {
+          return invalid ? INVALID : OK(result);
+        }
+      };
+      const baseResult = this._def.schema._parse(ctx, data, parsedType);
+      if (isOk(baseResult)) {
+        return applyAsyncEffects(baseResult.value);
+      } else if (isInvalid(baseResult)) {
+        return INVALID;
+      } else {
+        return ASYNC(
+          baseResult.promise.then((base) => {
+            if (isInvalid(base)) return INVALID;
+            const result = applyAsyncEffects(base.value);
+            return isAsync(result) ? result.promise : result;
-          .then(([data, _]) => {
-            return data;
-          });
-      } else if (effect.type === ""transform"") {
-        finalPromise = finalPromise
-          .then(THROW_ERROR_IF_PRESENT(""before transform""))
-          .then((data) => {
-            if (!(this instanceof ZodEffects))
-              throw new Error(
-                ""Only transformers can contain transformation functions.""
-              );
-            const newData = effect.transform(data);
-
-            return newData;
-          })
-          .then((data) => {
-            if (isSync && data instanceof Promise) {
-              throw new Error(
-                `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-              );
-            }
-            return data;
-          });
-      } else {
-        throw new Error(`Invalid effect type.`);
+        );
-
-    return finalPromise;
-  _parse(ctx: ParseContext): any {
-    const data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
-      return undefined;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | undefined> {
+    if (parsedType === ZodParsedType.undefined) {
+      return OK(undefined);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    if (ctx.parsedType === ZodParsedType.null) {
-      return null;
-    }
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(ctx.data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<T[""_output""] | null> {
+    if (parsedType === ZodParsedType.null) {
+      return OK(null);
+    }
+    return this._def.innerType._parse(ctx, data, parsedType);
-  _parse(ctx: ParseContext): any {
-    let data = ctx.data;
-    if (ctx.parsedType === ZodParsedType.undefined) {
+  _parse(
+    ctx: ParseContext,
+    data: any,
+    parsedType: ZodParsedType
+  ): ParseReturnType<util.noUndefined<T[""_output""]>> {
+    if (parsedType === ZodParsedType.undefined) {
-
-    return new PseudoPromise().then(() => {
-      return this._def.innerType._parseWithInvalidFallback(data, {
-        ...ctx,
-        parentError: ctx.currentError,
-      });
-    });
+    return this._def.innerType._parse(ctx, data, getParsedType(data));"
colinhacks_zod,c8a96224d869a13852a462132bf8e0184ba6c206,Merge pull request #478 from mad-gooze/setPrototypeOf-v3  fix setPrototypeOf in v3,deno/lib/ZodError.ts,"-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);"
colinhacks_zod,c8a96224d869a13852a462132bf8e0184ba6c206,Merge pull request #478 from mad-gooze/setPrototypeOf-v3  fix setPrototypeOf in v3,src/ZodError.ts,"-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }","-  // | ZodNonEmptyArrayIsEmptyIssue
-  // | ZodInvalidLiteralValueIssue
-  const json = JSON.stringify(obj, null, 2); // {""name"":""John Smith""}
+  const json = JSON.stringify(obj, null, 2);
-export type ZodFormattedError<T> = T extends [any, ...any]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
+export type ZodFormattedError<T> = { _errors: string[] } & (T extends [
+  any,
+  ...any
+]
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
-  ? ZodFormattedError<T[number]>[] & { _errors: string[] }
+  ? ZodFormattedError<T[number]>[]
-  ? { [K in keyof T]?: ZodFormattedError<T[K]> } & { _errors: string[] }
-  : { _errors: string[] };
+  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
+  : { _errors: string[] });
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-          fieldErrors._errors.push(issue.message);
+          (fieldErrors as any)._errors.push(issue.message);"
colinhacks_zod,b70e143d1d79375fbe346d9bb9ec5756bed4ee19,Merge pull request #483 from tstehr/allow-nil-uuid  Fix not considering the nil UUID a valid UUID,deno/lib/types.ts,"-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
-  or<T extends ZodTypeAny, This extends this = this>(
-    option: T
-  ): This extends ZodUnion<infer Opts>
-    ? [...Opts, T] extends ZodUnionOptions
-      ? ZodUnion<[...Opts, T]>
-      : never
-    : ZodUnion<[This, T]> {
-    if (this instanceof ZodUnion) {
-      return ZodUnion.create([...this.options, option] as any) as any;
-    }
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  // transform<NewOut, Inner extends ZodTypeAny = T>(
+  //   transform: (arg: Output) => NewOut | Promise<NewOut>
+  // ): ZodEffects<Inner, NewOut> {
+  //   return new ZodEffects({
+  //     ...this._def,
+  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
+  //   }) as any;
+  // }
+
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(""ZodEffects cannot be nested."");
+    // }","-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;","-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
-  or<T extends ZodTypeAny, This extends this = this>(
-    option: T
-  ): This extends ZodUnion<infer Opts>
-    ? [...Opts, T] extends ZodUnionOptions
-      ? ZodUnion<[...Opts, T]>
-      : never
-    : ZodUnion<[This, T]> {
-    if (this instanceof ZodUnion) {
-      return ZodUnion.create([...this.options, option] as any) as any;
-    }
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  // transform<NewOut, Inner extends ZodTypeAny = T>(
+  //   transform: (arg: Output) => NewOut | Promise<NewOut>
+  // ): ZodEffects<Inner, NewOut> {
+  //   return new ZodEffects({
+  //     ...this._def,
+  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
+  //   }) as any;
+  // }
+
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(""ZodEffects cannot be nested."");
+    // }"
colinhacks_zod,b70e143d1d79375fbe346d9bb9ec5756bed4ee19,Merge pull request #483 from tstehr/allow-nil-uuid  Fix not considering the nil UUID a valid UUID,src/types.ts,"-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
-  or<T extends ZodTypeAny, This extends this = this>(
-    option: T
-  ): This extends ZodUnion<infer Opts>
-    ? [...Opts, T] extends ZodUnionOptions
-      ? ZodUnion<[...Opts, T]>
-      : never
-    : ZodUnion<[This, T]> {
-    if (this instanceof ZodUnion) {
-      return ZodUnion.create([...this.options, option] as any) as any;
-    }
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  // transform<NewOut, Inner extends ZodTypeAny = T>(
+  //   transform: (arg: Output) => NewOut | Promise<NewOut>
+  // ): ZodEffects<Inner, NewOut> {
+  //   return new ZodEffects({
+  //     ...this._def,
+  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
+  //   }) as any;
+  // }
+
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(""ZodEffects cannot be nested."");
+    // }","-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;","-  // _refinement: (refinement: InternalCheck<Output>[""refinement""]) => this = (
-  //   refinement
-  // ) => {
-  //   return new (this as any).constructor({
-  //     ...this._def,
-  //     effects: [
-  //       // ...(this._def.effects || []),
-  //       { type: ""check"", check: refinement },
-  //     ],
-  //   }) as this;
-  // };
-  or<T extends ZodTypeAny, This extends this = this>(
-    option: T
-  ): This extends ZodUnion<infer Opts>
-    ? [...Opts, T] extends ZodUnionOptions
-      ? ZodUnion<[...Opts, T]>
-      : never
-    : ZodUnion<[This, T]> {
-    if (this instanceof ZodUnion) {
-      return ZodUnion.create([...this.options, option] as any) as any;
-    }
+  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
-  transform<NewOut, This extends this>(
+  transform<NewOut>(
-  ): This extends ZodEffects<infer T, any>
-    ? ZodEffects<T, NewOut>
-    : ZodEffects<This, NewOut> {
-    let returnType;
-    if (this instanceof ZodEffects) {
-      returnType = new ZodEffects({
-        ...this._def,
-        effects: [
-          ...(this._def.effects || []),
-          { type: ""transform"", transform },
-        ],
-      }) as any;
-    } else {
-      returnType = new ZodEffects({
-        schema: this,
-        effects: [{ type: ""transform"", transform }],
-      }) as any;
-    }
-    return returnType;
+  ): ZodEffects<this, NewOut> {
+    return new ZodEffects({
+      schema: this,
+      effects: [{ type: ""transform"", transform }],
+    }) as any;
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
+const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
-type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<
-  infer Inner,
-  infer Out
->
-  ? ZodEffects<Inner, Out>
+type ZodEffectsType<T extends ZodTypeAny> = T extends ZodEffects<any, any>
+  ? T
+  // transform<NewOut, Inner extends ZodTypeAny = T>(
+  //   transform: (arg: Output) => NewOut | Promise<NewOut>
+  // ): ZodEffects<Inner, NewOut> {
+  //   return new ZodEffects({
+  //     ...this._def,
+  //     effects: [...(this._def.effects || []), { type: ""transform"", transform }],
+  //   }) as any;
+  // }
+
-                // try {
-                //   result = effect.refinement(data, checkCtx);
-                // } catch (err) {
-                //   throw err;
-                //   // if (refinementError === null) refinementError = err;
-                // }
-    if (def.schema instanceof ZodEffects) {
-      throw new Error(""ZodEffectss cannot be nested."");
-    }
+    // if (def.schema instanceof ZodEffects) {
+    //   throw new Error(""ZodEffects cannot be nested."");
+    // }"
colinhacks_zod,f96213f2bec73f018864515c55dfeda858867be7,Merge branch 'colinhacks:v3' into v3,deno/lib/types.ts,"+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+      isCUID: false,","+  /**
+   * Deprecated.
+   * Use z.string().min(1) instead.
+   */","+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+  /**
+   * Deprecated.
+   * Use z.string().min(1) instead.
+   */
+      isCUID: false,"
colinhacks_zod,f96213f2bec73f018864515c55dfeda858867be7,Merge branch 'colinhacks:v3' into v3,src/types.ts,"+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+      isCUID: false,","+  /**
+   * Deprecated.
+   * Use z.string().min(1) instead.
+   */","+  isCUID: { message?: string } | false;
+const cuidRegex = /^c[^\s-]{8,}$/i;
+    }
+
+    if (this._def.isCUID && !cuidRegex.test(ctx.data)) {
+      ctx.addIssue({
+        validation: ""cuid"",
+        code: ZodIssueCode.invalid_string,
+        message: this._def.isCUID.message,
+      });
+  cuid = (message?: errorUtil.ErrMessage) =>
+    new ZodString({
+      ...this._def,
+      isCUID: errorUtil.errToObj(message),
+    });
+
+  /**
+   * Deprecated.
+   * Use z.string().min(1) instead.
+   */
+      isCUID: false,"
colinhacks_zod,bb6aa905cf3d069061ce301060737c930472ad85,updated changelog with beta.1,deno/lib/types.ts,"-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;","-  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+  optional: <This extends this = this>() => ZodOptional<This> = () =>
-  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+  nullable: <This extends this = this>() => ZodNullable<This> = () =>
+  nullish: <This extends this = this>() => ZodNullable<
+    ZodOptional<This>
+  > = () => this.optional().nullable();
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
-  default<T extends () => Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
+  default<This extends this = this>(
+    def: util.noUndefined<Input>
+  ): ZodDefault<This>;
+  default<This extends this = this>(
+    def: () => util.noUndefined<Input>
+  ): ZodDefault<This>;
-    return new ZodOptional({
+    return new ZodDefault({
-type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any>
+type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
-        newField = (newField as ZodOptional<any, any>)._def.innerType;
+        newField = (newField as ZodOptional<any>)._def.innerType;
-  defaultValue: undefined | (() => T[""_input""]);
-}
-
-export type addDefaultToOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
-
-export type removeDefaultFromOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
-
-export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
-  infer U,
-  infer H
->
-  ? ZodOptional<U, H>
-  : ZodOptional<T, false>; // no default by default
-
-export class ZodOptional<
-  T extends ZodTypeAny,
-  HasDefault extends boolean = false
-> extends ZodType<
-  HasDefault extends true ? T[""_output""] : T[""_output""] | undefined,
+}
+
+export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
+
+export class ZodOptional<T extends ZodTypeAny> extends ZodType<
+  T[""_output""] | undefined,
-    let data = ctx.data;
+    const data = ctx.data;
-      if (this._def.defaultValue !== undefined) {
-        data = this._def.defaultValue();
-      } else {
-        return undefined;
-      }
+      return undefined;
-  removeDefault(): ZodOptional<T, false> {
-    return new ZodOptional({
-      ...this._def,
-      defaultValue: undefined,
-    });
-  }
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
-      defaultValue: undefined,
-// This type allows for nullable flattening
-export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
-  infer U
->
-  ? ZodNullable<U>
-  : ZodNullable<T>;
+export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    // An nullable nullable is the original nullable
-    if (type instanceof ZodNullable) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+      innerType: type,
+    }) as any;
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodDefault      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: () => util.noUndefined<T[""_input""]>;
+}
+
+export class ZodDefault<T extends ZodTypeAny> extends ZodType<
+  util.noUndefined<T[""_output""]>,
+  ZodDefaultDef<T>,
+  T[""_input""] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      data = this._def.defaultValue();
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  removeDefault() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+    return new ZodOptional({
-  | ZodOptional<any, any>
+  | ZodOptional<any>
+  | ZodDefault<any>","-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {
-  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+  optional: <This extends this = this>() => ZodOptional<This> = () =>
-  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+  nullable: <This extends this = this>() => ZodNullable<This> = () =>
+  nullish: <This extends this = this>() => ZodNullable<
+    ZodOptional<This>
+  > = () => this.optional().nullable();
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
-  default<T extends () => Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
+  default<This extends this = this>(
+    def: util.noUndefined<Input>
+  ): ZodDefault<This>;
+  default<This extends this = this>(
+    def: () => util.noUndefined<Input>
+  ): ZodDefault<This>;
-    return new ZodOptional({
+    return new ZodDefault({
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
-type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any>
+type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
-        newField = (newField as ZodOptional<any, any>)._def.innerType;
+        newField = (newField as ZodOptional<any>)._def.innerType;
-  defaultValue: undefined | (() => T[""_input""]);
-}
-
-export type addDefaultToOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
-
-export type removeDefaultFromOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
-
-export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
-  infer U,
-  infer H
->
-  ? ZodOptional<U, H>
-  : ZodOptional<T, false>; // no default by default
-
-export class ZodOptional<
-  T extends ZodTypeAny,
-  HasDefault extends boolean = false
-> extends ZodType<
-  HasDefault extends true ? T[""_output""] : T[""_output""] | undefined,
+}
+
+export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
+
+export class ZodOptional<T extends ZodTypeAny> extends ZodType<
+  T[""_output""] | undefined,
-    let data = ctx.data;
+    const data = ctx.data;
-      if (this._def.defaultValue !== undefined) {
-        data = this._def.defaultValue();
-      } else {
-        return undefined;
-      }
+      return undefined;
-  removeDefault(): ZodOptional<T, false> {
-    return new ZodOptional({
-      ...this._def,
-      defaultValue: undefined,
-    });
-  }
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
-      defaultValue: undefined,
-// This type allows for nullable flattening
-export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
-  infer U
->
-  ? ZodNullable<U>
-  : ZodNullable<T>;
+export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    // An nullable nullable is the original nullable
-    if (type instanceof ZodNullable) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+      innerType: type,
+    }) as any;
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodDefault      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: () => util.noUndefined<T[""_input""]>;
+}
+
+export class ZodDefault<T extends ZodTypeAny> extends ZodType<
+  util.noUndefined<T[""_output""]>,
+  ZodDefaultDef<T>,
+  T[""_input""] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      data = this._def.defaultValue();
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  removeDefault() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+    return new ZodOptional({
-  | ZodOptional<any, any>
+  | ZodOptional<any>
+  | ZodDefault<any>"
colinhacks_zod,bb6aa905cf3d069061ce301060737c930472ad85,updated changelog with beta.1,src/types.ts,"-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;","-  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+  optional: <This extends this = this>() => ZodOptional<This> = () =>
-  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+  nullable: <This extends this = this>() => ZodNullable<This> = () =>
+  nullish: <This extends this = this>() => ZodNullable<
+    ZodOptional<This>
+  > = () => this.optional().nullable();
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
-  default<T extends () => Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
+  default<This extends this = this>(
+    def: util.noUndefined<Input>
+  ): ZodDefault<This>;
+  default<This extends this = this>(
+    def: () => util.noUndefined<Input>
+  ): ZodDefault<This>;
-    return new ZodOptional({
+    return new ZodDefault({
-type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any>
+type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
-        newField = (newField as ZodOptional<any, any>)._def.innerType;
+        newField = (newField as ZodOptional<any>)._def.innerType;
-  defaultValue: undefined | (() => T[""_input""]);
-}
-
-export type addDefaultToOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
-
-export type removeDefaultFromOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
-
-export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
-  infer U,
-  infer H
->
-  ? ZodOptional<U, H>
-  : ZodOptional<T, false>; // no default by default
-
-export class ZodOptional<
-  T extends ZodTypeAny,
-  HasDefault extends boolean = false
-> extends ZodType<
-  HasDefault extends true ? T[""_output""] : T[""_output""] | undefined,
+}
+
+export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
+
+export class ZodOptional<T extends ZodTypeAny> extends ZodType<
+  T[""_output""] | undefined,
-    let data = ctx.data;
+    const data = ctx.data;
-      if (this._def.defaultValue !== undefined) {
-        data = this._def.defaultValue();
-      } else {
-        return undefined;
-      }
+      return undefined;
-  removeDefault(): ZodOptional<T, false> {
-    return new ZodOptional({
-      ...this._def,
-      defaultValue: undefined,
-    });
-  }
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
-      defaultValue: undefined,
-// This type allows for nullable flattening
-export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
-  infer U
->
-  ? ZodNullable<U>
-  : ZodNullable<T>;
+export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    // An nullable nullable is the original nullable
-    if (type instanceof ZodNullable) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+      innerType: type,
+    }) as any;
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodDefault      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: () => util.noUndefined<T[""_input""]>;
+}
+
+export class ZodDefault<T extends ZodTypeAny> extends ZodType<
+  util.noUndefined<T[""_output""]>,
+  ZodDefaultDef<T>,
+  T[""_input""] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      data = this._def.defaultValue();
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  removeDefault() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+    return new ZodOptional({
-  | ZodOptional<any, any>
+  | ZodOptional<any>
+  | ZodDefault<any>","-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {
-  optional: <This extends this = this>() => ZodOptionalType<This> = () =>
+  optional: <This extends this = this>() => ZodOptional<This> = () =>
-  nullable: <This extends this = this>() => ZodNullableType<This> = () =>
+  nullable: <This extends this = this>() => ZodNullable<This> = () =>
+  nullish: <This extends this = this>() => ZodNullable<
+    ZodOptional<This>
+  > = () => this.optional().nullable();
-  default<T extends Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
-  default<T extends () => Input, This extends this = this>(
-    def: T
-  ): ZodOptional<This, true>;
+  default<This extends this = this>(
+    def: util.noUndefined<Input>
+  ): ZodDefault<This>;
+  default<This extends this = this>(
+    def: () => util.noUndefined<Input>
+  ): ZodDefault<This>;
-    return new ZodOptional({
+    return new ZodDefault({
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;
-type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U, any>
+type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
-        newField = (newField as ZodOptional<any, any>)._def.innerType;
+        newField = (newField as ZodOptional<any>)._def.innerType;
-  defaultValue: undefined | (() => T[""_input""]);
-}
-
-export type addDefaultToOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, true> : never;
-
-export type removeDefaultFromOptional<
-  T extends ZodOptional<any, any>
-> = T extends ZodOptional<infer U, any> ? ZodOptional<U, false> : never;
-
-export type ZodOptionalType<T extends ZodTypeAny> = T extends ZodOptional<
-  infer U,
-  infer H
->
-  ? ZodOptional<U, H>
-  : ZodOptional<T, false>; // no default by default
-
-export class ZodOptional<
-  T extends ZodTypeAny,
-  HasDefault extends boolean = false
-> extends ZodType<
-  HasDefault extends true ? T[""_output""] : T[""_output""] | undefined,
+}
+
+export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;
+
+export class ZodOptional<T extends ZodTypeAny> extends ZodType<
+  T[""_output""] | undefined,
-    let data = ctx.data;
+    const data = ctx.data;
-      if (this._def.defaultValue !== undefined) {
-        data = this._def.defaultValue();
-      } else {
-        return undefined;
-      }
+      return undefined;
-  removeDefault(): ZodOptional<T, false> {
-    return new ZodOptional({
-      ...this._def,
-      defaultValue: undefined,
-    });
-  }
-
-  static create = <T extends ZodTypeAny>(type: T): ZodOptionalType<T> => {
-    if (type instanceof ZodOptional) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
-      defaultValue: undefined,
-// This type allows for nullable flattening
-export type ZodNullableType<T extends ZodTypeAny> = T extends ZodNullable<
-  infer U
->
-  ? ZodNullable<U>
-  : ZodNullable<T>;
+export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;
-  static create = <T extends ZodTypeAny>(type: T): ZodNullableType<T> => {
-    // An nullable nullable is the original nullable
-    if (type instanceof ZodNullable) return type as any;
+  static create = <T extends ZodTypeAny>(type: T): ZodNullable<T> => {
+      innerType: type,
+    }) as any;
+  };
+}
+
+////////////////////////////////////////////
+////////////////////////////////////////////
+//////////                        //////////
+//////////      ZodDefault      //////////
+//////////                        //////////
+////////////////////////////////////////////
+////////////////////////////////////////////
+export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  innerType: T;
+  defaultValue: () => util.noUndefined<T[""_input""]>;
+}
+
+export class ZodDefault<T extends ZodTypeAny> extends ZodType<
+  util.noUndefined<T[""_output""]>,
+  ZodDefaultDef<T>,
+  T[""_input""] | undefined
+> {
+  _parse(ctx: ParseContext): any {
+    let data = ctx.data;
+    if (ctx.parsedType === ZodParsedType.undefined) {
+      data = this._def.defaultValue();
+    }
+
+    return new PseudoPromise().then(() => {
+      return this._def.innerType._parseWithInvalidFallback(data, {
+        ...ctx,
+        parentError: ctx.currentError,
+      });
+    });
+  }
+
+  removeDefault() {
+    return this._def.innerType;
+  }
+
+  static create = <T extends ZodTypeAny>(type: T): ZodOptional<T> => {
+    return new ZodOptional({
-  | ZodOptional<any, any>
+  | ZodOptional<any>
+  | ZodDefault<any>"
colinhacks_zod,0d79f75a73d9a75bb40777d5b9fd3497543f780f,"Merge pull request #416 from Niek/v3  Add support for all UUID versions, fix #415",src/types.ts,"-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {","-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;","-  ) => ZodEffectsType<This> = (check, message = ""Invalid value."") => {
-    if (typeof message === ""string"") {
+  ) => ZodEffectsType<This> = (check, message) => {
+    if (typeof message === ""string"" || typeof message === ""undefined"") {
-const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/;
+const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i;"
colinhacks_zod,91e28d456a083e38284c782a5f3a05e8bba8a85b,Merge branch 'add-back-intersection' into v3,package.json,"-  ""version"": ""3.0.0-alpha.19"",
+  ""version"": ""3.0.0-alpha.21"",","-  ""type"": ""module"",
-      ""pre-commit"": ""yarn build:deno && lint-staged""
+      ""pre-commit"": ""yarn build:deno && lint-staged && git add .""","-  ""version"": ""3.0.0-alpha.19"",
+  ""version"": ""3.0.0-alpha.21"",
-  ""type"": ""module"",
-      ""pre-commit"": ""yarn build:deno && lint-staged""
+      ""pre-commit"": ""yarn build:deno && lint-staged && git add ."""
colinhacks_zod,fc3c44579cd546cb56d562c37d2254a18cb4e551,FMC,package.json,"-  ""version"": ""3.0.0-alpha.10"",
+  ""version"": ""3.0.0-alpha.11"",
+  ""type"": ""module"",","-  ""version"": ""3.0.0-alpha.10"",
+  ""version"": ""3.0.0-alpha.19"",","-  ""version"": ""3.0.0-alpha.10"",
+  ""version"": ""3.0.0-alpha.19"",
+  ""type"": ""module"","
colinhacks_zod,65bceeaed5b6d62675420ca6110149fb0f89aee8,FMC,src/playground.ts,"-  const BaseTeacher = z.object({
-    subjects: z.array(z.string()),
+  const schema = z
+    .object({
+      inner: z.object({
+        name: z
+          .string()
+          .refine((val) => val.length > 5)
+          .array()
+          .refine((val) => val.length > 5),
+      }),
+      password: z.string().refine((val) => val === val.toUpperCase()),
+      confirm: z.string(),
+    })
+    .refine(
+      (val) => {
+        console.log(`FORM DATA`);
+        console.log(JSON.stringify(val, null, 2));
+        return val.confirm === val.password;
+      },
+      { path: [""confirm""] }
+    );
+  const result = schema.safeParse({
+    inner: { name: [""aasd"", ""asdfasdfasfd"", ""aasd""] },
+    password: ""peanuts"",
+    confirm: ""peanuts"",
-  const HasID = z.object({ id: z.string() });
-
-  const Teacher = BaseTeacher.merge(HasID);
-  const data = {
-    subjects: [""math""],
-    id: ""asdfasdf"",
-  };
-  console.log(Teacher.safeParse({ ...data, extra: 12 }));
+  console.log(result);","-  const BaseTeacher = z.object({
-    subjects: z.array(z.string()),
+  const schema = z.object({
+    inner: z.object({
+      name: z
+        .string()
+        .refine((val) => val.length > 5)
+        .array()
+        .refine((val) => val.length <= 1),
+    }),
-  const HasID = z.object({ id: z.string() });
-  const Teacher = BaseTeacher.merge(HasID);
-  const data = {
-    subjects: [""math""],
-    id: ""asdfasdf"",
+  const invalidItem = {
+    inner: { name: [""aasd"", ""asdfasdfasfd""] },
-  console.log(Teacher.safeParse({ ...data, extra: 12 }));
+  const invalidArray = {
+    inner: { name: [""asdfasdf"", ""asdfasdfasfd""] },
+  };
+  const result1 = schema.safeParse(invalidItem);
+  result1;
+  const result2 = schema.safeParse(invalidArray);
+  if (!result2.success) console.log(result2.error?.format());","-  const BaseTeacher = z.object({
-    subjects: z.array(z.string()),
-  });
-  const HasID = z.object({ id: z.string() });
-
-  const Teacher = BaseTeacher.merge(HasID);
-  const data = {
-    subjects: [""math""],
-    id: ""asdfasdf"",
-  };
-  console.log(Teacher.safeParse({ ...data, extra: 12 }));"
colinhacks_zod,e0441bd587a54d62ecad2e8456a57a711855cd0c,Merge branch 'rip-out-intersection' into v3,src/types.ts,"-  transform: <Out, This extends this>(
-    transformer: (arg: Output) => Out | Promise<Out>
+  transform: <NewOut, This extends this>(
+    transformer: (arg: Output) => NewOut | Promise<NewOut>
-    ? ZodTransformer<T, Out>
-    : ZodTransformer<This, Out> = (mod) => {
+    ? ZodTransformer<T, NewOut>
+    : ZodTransformer<This, NewOut> = (mod) => {","-  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
+  export type extendShape<U extends ZodRawShape, V extends ZodRawShape> = {
-
-  type optionalKeys<T extends object> = {
+  export type optionalKeys<T extends object> = {
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  export type requiredKeys<T extends object> = Exclude<
+    keyof T,
+    optionalKeys<T>
+  >;
-  export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
-
-  export type NoNeverKeys<T extends ZodRawShape> = {
+  // export type identity<T> = T;
+  // export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+
+  export type noNeverKeys<T extends ZodRawShape> = {
-  export type NoNever<T extends ZodRawShape> = identity<
+  export type noNever<T extends ZodRawShape> = util.identity<
-      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
+      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
+    // const firstKeys = Object.keys(first);
+    // const secondKeys = Object.keys(second);
+    // const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
+
+    // const sharedShape: any = {};
+    // for (const k of sharedKeys) {
+    //   sharedShape[k] = ZodIntersection.create(first[k], second[k]);
+    // }
+    // return {
+    //   ...(first as object),
+    //   ...(second as object),
+    //   ...sharedShape,
+    // };
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
+      ...first,
+      ...second, // second overwrites first
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-  }) as any;
-  return merged;
-};
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+
+const ExtendFactory = <Def extends ZodObjectDef>(def: Def) => <
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
+export type baseObjectOutputType<Shape extends ZodRawShape> = util.flatten<
-  : objectUtil.flatten<
+  : util.flatten<
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
+export type baseObjectInputType<Shape extends ZodRawShape> = util.flatten<
-  : objectUtil.flatten<
+  : util.flatten<
-  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  augment = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-    other: Incoming
-  ) => ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = mergeObjects(
-    this as any
-  ) as any;
+    merging: Incoming
+  ) => ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+    const mergedShape = objectUtil.mergeShapes(
+      this._def.shape(),
+      merging._def.shape()
+    );
+    const merged: any = new ZodObject({
+      effects: [], // wipe all refinements
+      unknownKeys: this._def.unknownKeys,
+      catchall: this._def.catchall,
+      shape: () => mergedShape,
+    }) as any;
+    return merged;
+  };
-    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
-    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
-    objectUtil.NoNever<
+    objectUtil.noNever<
-        [k in keyof T]: [T[k][""_output""]] extends [Scalars] ? T[k] : never;
+        [k in keyof T]: [T[k][""_output""]] extends [util.Scalar] ? T[k] : never;
-    objectUtil.NoNever<
+    objectUtil.noNever<
-        [k in keyof T]: [T[k][""_output""]] extends [Scalars] ? never : T[k];
+        [k in keyof T]: [T[k][""_output""]] extends [util.Scalar] ? never : T[k];
-    });
-  };
-}
-
-///////////////////////////////////////////////
-///////////////////////////////////////////////
-//////////                           //////////
-//////////      ZodIntersection      //////////
-//////////                           //////////
-///////////////////////////////////////////////
-///////////////////////////////////////////////
-export interface ZodIntersectionDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  U extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  left: T;
-  right: U;
-}
-
-export class ZodIntersection<
-  T extends ZodTypeAny,
-  U extends ZodTypeAny
-> extends ZodType<
-  T[""_output""] & U[""_output""],
-  ZodIntersectionDef<T, U>,
-  T[""_input""] & U[""_input""]
-> {
-  isScalar(params: { root: boolean } = { root: true }) {
-    if (params.root === false) return false;
-    return this._def.left.isScalar(params) && this._def.right.isScalar(params);
-  }
-
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_intersection_types,
-        });
-      }
-    });
-  }
-
-  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
-    left: T,
-    right: U
-  ): ZodIntersection<T, U> => {
-    return new ZodIntersection({
-      left: left,
-      right: right,
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends util.Primitive>(value: T): ZodLiteral<T> => {
-  | ZodIntersection<any, any>
-const intersectionType = ZodIntersection.create;
-  intersectionType as intersection,","-  transform: <Out, This extends this>(
-    transformer: (arg: Output) => Out | Promise<Out>
+  transform: <NewOut, This extends this>(
+    transformer: (arg: Output) => NewOut | Promise<NewOut>
-    ? ZodTransformer<T, Out>
-    : ZodTransformer<This, Out> = (mod) => {
+    ? ZodTransformer<T, NewOut>
+    : ZodTransformer<This, NewOut> = (mod) => {
-  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
+  export type extendShape<U extends ZodRawShape, V extends ZodRawShape> = {
-
-  type optionalKeys<T extends object> = {
+  export type optionalKeys<T extends object> = {
-  type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
+  export type requiredKeys<T extends object> = Exclude<
+    keyof T,
+    optionalKeys<T>
+  >;
-  export type identity<T> = T;
-  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
-
-  export type NoNeverKeys<T extends ZodRawShape> = {
+  // export type identity<T> = T;
+  // export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
+
+  export type noNeverKeys<T extends ZodRawShape> = {
-  export type NoNever<T extends ZodRawShape> = identity<
+  export type noNever<T extends ZodRawShape> = util.identity<
-      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
+      [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
-    const firstKeys = Object.keys(first);
-    const secondKeys = Object.keys(second);
-    const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
-
-    const sharedShape: any = {};
-    for (const k of sharedKeys) {
-      sharedShape[k] = ZodIntersection.create(first[k], second[k]);
-    }
+    // const firstKeys = Object.keys(first);
+    // const secondKeys = Object.keys(second);
+    // const sharedKeys = firstKeys.filter((k) => secondKeys.indexOf(k) !== -1);
+
+    // const sharedShape: any = {};
+    // for (const k of sharedKeys) {
+    //   sharedShape[k] = ZodIntersection.create(first[k], second[k]);
+    // }
+    // return {
+    //   ...(first as object),
+    //   ...(second as object),
+    //   ...sharedShape,
+    // };
-      ...(first as object),
-      ...(second as object),
-      ...sharedShape,
+      ...first,
+      ...second, // second overwrites first
-export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-  Second extends AnyZodObject
->(
-  second: Second
-): ZodObject<
-  First[""_shape""] & Second[""_shape""],
-  First[""_unknownKeys""],
-  First[""_catchall""]
-> => {
-  const mergedShape = objectUtil.mergeShapes(
-    first._def.shape(),
-    second._def.shape()
-  );
-  const merged: any = new ZodObject({
-    effects: [...(first._def.effects || []), ...(second._def.effects || [])],
-    unknownKeys: first._def.unknownKeys,
-    catchall: first._def.catchall,
-    shape: () => mergedShape,
-  }) as any;
-  return merged;
-};
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+
+const ExtendFactory = <Def extends ZodObjectDef>(def: Def) => <
-export type Primitive = string | number | bigint | boolean | null | undefined;
-export type Scalars = Primitive | Primitive[];
-
-export type baseObjectOutputType<
-  Shape extends ZodRawShape
-> = objectUtil.flatten<
+export type baseObjectOutputType<Shape extends ZodRawShape> = util.flatten<
-  : objectUtil.flatten<
+  : util.flatten<
-export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
+export type baseObjectInputType<Shape extends ZodRawShape> = util.flatten<
-  : objectUtil.flatten<
+  : util.flatten<
-  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  augment = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = ExtendFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-    other: Incoming
-  ) => ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = mergeObjects(
-    this as any
-  ) as any;
+    merging: Incoming
+  ) => ZodObject<T & Incoming[""_shape""], UnknownKeys, Catchall> = (merging) => {
+    const mergedShape = objectUtil.mergeShapes(
+      this._def.shape(),
+      merging._def.shape()
+    );
+    const merged: any = new ZodObject({
+      effects: [], // wipe all refinements
+      unknownKeys: this._def.unknownKeys,
+      catchall: this._def.catchall,
+      shape: () => mergedShape,
+    }) as any;
+    return merged;
+  };
-    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
-    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
-    objectUtil.NoNever<
+    objectUtil.noNever<
-        [k in keyof T]: [T[k][""_output""]] extends [Scalars] ? T[k] : never;
+        [k in keyof T]: [T[k][""_output""]] extends [util.Scalar] ? T[k] : never;
-    objectUtil.NoNever<
+    objectUtil.noNever<
-        [k in keyof T]: [T[k][""_output""]] extends [Scalars] ? never : T[k];
+        [k in keyof T]: [T[k][""_output""]] extends [util.Scalar] ? never : T[k];
-    });
-  };
-}
-
-///////////////////////////////////////////////
-///////////////////////////////////////////////
-//////////                           //////////
-//////////      ZodIntersection      //////////
-//////////                           //////////
-///////////////////////////////////////////////
-///////////////////////////////////////////////
-export interface ZodIntersectionDef<
-  T extends ZodTypeAny = ZodTypeAny,
-  U extends ZodTypeAny = ZodTypeAny
-> extends ZodTypeDef {
-  left: T;
-  right: U;
-}
-
-export class ZodIntersection<
-  T extends ZodTypeAny,
-  U extends ZodTypeAny
-> extends ZodType<
-  T[""_output""] & U[""_output""],
-  ZodIntersectionDef<T, U>,
-  T[""_input""] & U[""_input""]
-> {
-  isScalar(params: { root: boolean } = { root: true }) {
-    if (params.root === false) return false;
-    return this._def.left.isScalar(params) && this._def.right.isScalar(params);
-  }
-
-  _parse(ctx: ParseContext): any {
-    return PseudoPromise.all([
-      new PseudoPromise().then(() => {
-        return this._def.left._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-      new PseudoPromise().then(() => {
-        return this._def.right._parseWithInvalidFallback(ctx.data, {
-          ...ctx,
-          parentError: ctx.currentError,
-        });
-      }),
-    ]).then(([parsedLeft, parsedRight]: any) => {
-      if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
-
-      const parsedLeftType = getParsedType(parsedLeft);
-      const parsedRightType = getParsedType(parsedRight);
-
-      if (parsedLeft === parsedRight) {
-        return parsedLeft;
-      } else if (
-        parsedLeftType === ZodParsedType.object &&
-        parsedRightType === ZodParsedType.object
-      ) {
-        return { ...parsedLeft, ...parsedRight };
-      } else {
-        ctx.addIssue({
-          code: ZodIssueCode.invalid_intersection_types,
-        });
-      }
-    });
-  }
-
-  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
-    left: T,
-    right: U
-  ): ZodIntersection<T, U> => {
-    return new ZodIntersection({
-      left: left,
-      right: right,
-  static create = <T extends Primitive>(value: T): ZodLiteral<T> => {
+  static create = <T extends util.Primitive>(value: T): ZodLiteral<T> => {
-  | ZodIntersection<any, any>
-const intersectionType = ZodIntersection.create;
-  intersectionType as intersection,"
colinhacks_zod,586676677ea580be57ea7dce47b24b8c7bf9d637,FMC,src/ZodError.ts,"-export const defaultErrorMap = (
+export let defaultErrorMap = (
-// export const setErrorMap = (map: ZodErrorMap) => {
-//   defaultErrorMap = map;
-// };
+export const setErrorMap = (map: ZodErrorMap) => {
+  defaultErrorMap = map;
+};","-    const fieldErrors: ZodFormattedError<T> = {} as any;
+    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
+        } else if (issue.path.length === 0) {
+          fieldErrors._errors.push(issue.message);","-    const fieldErrors: ZodFormattedError<T> = {} as any;
+    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
+        } else if (issue.path.length === 0) {
+          fieldErrors._errors.push(issue.message);
-export const defaultErrorMap = (
+export let defaultErrorMap = (
-// export const setErrorMap = (map: ZodErrorMap) => {
-//   defaultErrorMap = map;
-// };
+export const setErrorMap = (map: ZodErrorMap) => {
+  defaultErrorMap = map;
+};"
colinhacks_zod,586676677ea580be57ea7dce47b24b8c7bf9d637,FMC,src/playground.ts,"-  const errorMap: z.ZodErrorMap = (error, ctx) => {
-    if (error.code === z.ZodIssueCode.invalid_type) {
-      if (error.expected === ""string"") {
-        return { message: ""bad type!"" };
-      }
-    }
-    if (error.code === z.ZodIssueCode.custom) {
-      return { message: `less-than-${(error.params || {}).minimum}` };
-    }
-    return { message: ctx.defaultError };
-  };
-  errorMap;
-  console.log(z.string().safeParse(1234));
+  const promiseSchema = z.promise(z.number());
+  console.log(`test(""promise async parse bad""`);
+  const badData = Promise.resolve(""XXX"");
+  const badResult = await promiseSchema.safeParseAsync(badData);
+  console.log(badResult);","-  const errorMap: z.ZodErrorMap = (error, ctx) => {
-    if (error.code === z.ZodIssueCode.invalid_type) {
-      if (error.expected === ""string"") {
-        return { message: ""bad type!"" };
-      }
-    }
-    if (error.code === z.ZodIssueCode.custom) {
-      return { message: `less-than-${(error.params || {}).minimum}` };
-    }
-    return { message: ctx.defaultError };
-  };
-  errorMap;
-  console.log(z.string().safeParse(1234));
+  const schema = z.string().email();
+  const result = schema.safeParse(""asdfsdf"");
+  console.log(result);
+  if (!result.success) {
+    console.log(result.error.format());
+  }","-  const errorMap: z.ZodErrorMap = (error, ctx) => {
-    if (error.code === z.ZodIssueCode.invalid_type) {
-      if (error.expected === ""string"") {
-        return { message: ""bad type!"" };
-      }
-    }
-    if (error.code === z.ZodIssueCode.custom) {
-      return { message: `less-than-${(error.params || {}).minimum}` };
-    }
-    return { message: ctx.defaultError };
-  };
-  errorMap;
-  console.log(z.string().safeParse(1234));
+  z;"
colinhacks_zod,9056e04d53b39b67375f97adeb7a37228c752cb6,FMC,deno/lib/parser.ts,"+import { getParsedType, ZodParsedType } from ""./helpers/parseUtil.ts"";
-import { MakeErrorData, ZodError, ZodIssue, ZodIssueCode } from ""./ZodError.ts"";
-import { ZodParsedType } from ""./ZodParsedType.ts"";
+import { MakeErrorData, ZodError, ZodIssueCode } from ""./ZodError.ts"";
-export const getParsedType = (data: any): ZodParsedType => {
-  if (typeof data === ""string"") return ""string"";
-  if (typeof data === ""number"") {
-    if (Number.isNaN(data)) return ""nan"";
-    return ""number"";
-  }
-  if (typeof data === ""boolean"") return ""boolean"";
-  if (typeof data === ""bigint"") return ""bigint"";
-  if (typeof data === ""symbol"") return ""symbol"";
-  if (data instanceof Date) return ""date"";
-  if (typeof data === ""function"") return ""function"";
-  if (data === undefined) return ""undefined"";
-  if (typeof data === ""undefined"") return ""undefined"";
-  if (typeof data === ""object"") {
-    if (Array.isArray(data)) return ""array"";
-    if (data === null) return ""null"";
-    if (
-      data.then &&
-      typeof data.then === ""function"" &&
-      data.catch &&
-      typeof data.catch === ""function""
-    ) {
-      return ""promise"";
-    }
-    if (data instanceof Map) {
-      return ""map"";
-    }
-    if (data instanceof Set) {
-      return ""set"";
-    }
-    return ""object"";
-  }
-  return ""unknown"";
-};
-
-const makeError = (
+const addIssue = (
-): ZodIssue => {
+) => {
-  // params.error.addIssue(issue);
-  return issue;
+  params.error.addIssue(issue);
+  // return issue;
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.string,
-            received: parsedType,
-          })
-        );
+        // ERROR.addIssue(
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        });
+        // );
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: ZodParsedType.nan,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: ZodParsedType.nan,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.bigint,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.boolean,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.undefined,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.null,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        });
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.never,
-          received: parsedType,
-        })
-      );
+      addIssue(params, data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.void,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.nonempty_array_is_empty,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.nonempty_array_is_empty,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.map,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.set,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-            ERROR.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.unrecognized_keys,
-                keys: extraKeys,
-              })
-            );
+            addIssue(params, data, {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            });
-              ERROR.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_union,
-                  unionErrors,
-                })
-              );
+              addIssue(params, data, {
+                code: ZodIssueCode.invalid_union,
+                unionErrors,
+              });
-                ERROR.addIssue(
-                  makeError(params, data, {
-                    code: ZodIssueCode.invalid_union,
-                    unionErrors,
-                  })
-                );
+                addIssue(params, data, {
+                  code: ZodIssueCode.invalid_union,
+                  unionErrors,
+                });
-          ERROR.addIssue(
-            makeError(params, data, {
-              code: ZodIssueCode.invalid_intersection_types,
-            })
-          );
+          addIssue(params, data, {
+            code: ZodIssueCode.invalid_intersection_types,
+          });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_big,
-            maximum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_small,
-            minimum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-          // .catch((err) => {
-          //   if (err instanceof ZodError) {
-          //     ERROR.addIssues(err.issues);
-          //     return;
-          //   }
-          //   throw err;
-          // })
-          // .then((arg) => {
-          //   return arg;
-          // });
-        ERROR.addIssue(
-          makeError(params, data, {
-            // code: ZodIssueCode.invalid_literal_value,
-            code: ZodIssueCode.invalid_type,
-            expected: def.value,
-            received: data,
-          })
-        );
+        addIssue(params, data, {
+          // code: ZodIssueCode.invalid_literal_value,
+          code: ZodIssueCode.invalid_type,
+          expected: def.value,
+          received: data,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: def.values,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: def.values,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: util.objectValues(nativeEnumValues),
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.function,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        });
-          //     makeError(params, data, {
+          //     addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_arguments,
-                  argumentsError: argsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_arguments,
+                argumentsError: argsError,
+              });
+
-          //       makeError(params, data, {
+          //       addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_return_type,
-                  returnTypeError: returnsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_return_type,
+                returnTypeError: returnsError,
+              });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.date,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_date,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_date,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.promise,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        });
-      ERROR.addIssue(makeError(params, data, arg));
+      addIssue(params, data, arg);
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.custom,
-            message: ""Invalid"",
-          })
-        );
+
+        addIssue(params, data, {
+          code: ZodIssueCode.custom,
+          message: ""Invalid"",
+        });","+import { getParsedType, ZodParsedType } from ""./helpers/parseUtil.ts"";
-import { MakeErrorData, ZodError, ZodIssue, ZodIssueCode } from ""./ZodError.ts"";
-import { ZodParsedType } from ""./ZodParsedType.ts"";
+import { MakeErrorData, ZodError, ZodIssueCode } from ""./ZodError.ts"";
-export const getParsedType = (data: any): ZodParsedType => {
-  if (typeof data === ""string"") return ""string"";
-  if (typeof data === ""number"") {
-    if (Number.isNaN(data)) return ""nan"";
-    return ""number"";
-  }
-  if (typeof data === ""boolean"") return ""boolean"";
-  if (typeof data === ""bigint"") return ""bigint"";
-  if (typeof data === ""symbol"") return ""symbol"";
-  if (data instanceof Date) return ""date"";
-  if (typeof data === ""function"") return ""function"";
-  if (data === undefined) return ""undefined"";
-  if (typeof data === ""undefined"") return ""undefined"";
-  if (typeof data === ""object"") {
-    if (Array.isArray(data)) return ""array"";
-    if (data === null) return ""null"";
-    if (
-      data.then &&
-      typeof data.then === ""function"" &&
-      data.catch &&
-      typeof data.catch === ""function""
-    ) {
-      return ""promise"";
-    }
-    if (data instanceof Map) {
-      return ""map"";
-    }
-    if (data instanceof Set) {
-      return ""set"";
-    }
-    return ""object"";
-  }
-  return ""unknown"";
-};
-
-const makeError = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-): ZodIssue => {
+const addIssue = (params: ParseParams, data: any, errorData: MakeErrorData) => {
-  // params.error.addIssue(issue);
-  return issue;
+  params.error.addIssue(issue);
+  // return issue;
-  seen?: {
+  seen: {
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  error?: ZodError;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  error: ZodError;
+  async: boolean;
+  runAsyncValidationsInSeries: boolean;
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
+  baseParams: Partial<ParseParams> = {
+    seen: [],
+    errorMap: defaultErrorMap,
+    path: [],
+  }
-  const params: Required<ParseParams> = {
+  const params: ParseParams = {
-  (PROMISE as any)._default = true;
+  // (PROMISE as any)._default = true;
+  // console.log(`\n#########\nParsing ${def.t}`);
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.string,
-            received: parsedType,
-          })
-        );
+        // ERROR.addIssue(
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        });
+        // );
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: ZodParsedType.nan,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: ZodParsedType.nan,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.bigint,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.boolean,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.undefined,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.null,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        });
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.never,
-          received: parsedType,
-        })
-      );
+      addIssue(params, data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.void,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.nonempty_array_is_empty,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.nonempty_array_is_empty,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.map,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.set,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-            ERROR.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.unrecognized_keys,
-                keys: extraKeys,
-              })
-            );
+            addIssue(params, data, {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            });
-        })
+        }) as any
-              ERROR.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_union,
-                  unionErrors,
-                })
-              );
+              addIssue(params, data, {
+                code: ZodIssueCode.invalid_union,
+                unionErrors,
+              });
-                ERROR.addIssue(
-                  makeError(params, data, {
-                    code: ZodIssueCode.invalid_union,
-                    unionErrors,
-                  })
-                );
+                addIssue(params, data, {
+                  code: ZodIssueCode.invalid_union,
+                  unionErrors,
+                });
-        .then((unionResults: any[]) => {
+        .then((unionResults: any) => {
-          ERROR.addIssue(
-            makeError(params, data, {
-              code: ZodIssueCode.invalid_intersection_types,
-            })
-          );
+          addIssue(params, data, {
+            code: ZodIssueCode.invalid_intersection_types,
+          });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_big,
-            maximum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_small,
-            minimum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-          // .catch((err) => {
-          //   if (err instanceof ZodError) {
-          //     ERROR.addIssues(err.issues);
-          //     return;
-          //   }
-          //   throw err;
-          // })
-          // .then((arg) => {
-          //   return arg;
-          // });
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            // code: ZodIssueCode.invalid_literal_value,
-            code: ZodIssueCode.invalid_type,
-            expected: def.value,
-            received: data,
-          })
-        );
+        addIssue(params, data, {
+          // code: ZodIssueCode.invalid_literal_value,
+          code: ZodIssueCode.invalid_type,
+          expected: def.value,
+          received: data,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: def.values,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: def.values,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: util.objectValues(nativeEnumValues),
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.function,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        });
-          //     makeError(params, data, {
+          //     addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_arguments,
-                  argumentsError: argsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_arguments,
+                argumentsError: argsError,
+              });
+
-          //       makeError(params, data, {
+          //       addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_return_type,
-                  returnTypeError: returnsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_return_type,
+                returnTypeError: returnsError,
+              });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.date,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_date,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_date,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.promise,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        });
+  const isSync = params.async === false || def.t === ZodTypes.promise;
+
-
-      ERROR.addIssue(makeError(params, data, arg));
+      addIssue(params, data, arg);
-  // const isSync = !params.async;
-
-  const isSync = params.async === false || def.t === ZodTypes.promise;
-
-  if (isSync) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      throw new Error(
-        ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
-      );
+  console.log(`Running ${effects.length} effects`);
+
+  let finalPromise = PROMISE.then((data) => {
+    // if (!params.error.isEmpty) {
+    if (data === INVALID) {
+      console.log(`errors already exist! throwing...`);
+      throw params.error;
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      return { success: false, error: ERROR };
-      // throw ERROR;
+    return data;
+  });
+
+  for (const effect of effects) {
+    if (effect.type === ""check"") {
+      finalPromise = finalPromise
+        .all((data) => {
+          console.log(`CHECK`);
+          return [
+            PseudoPromise.resolve(data),
+            PseudoPromise.resolve(data).then(() => {
+              const result = effect.check(data, checkCtx);
+
+              if (isSync && result instanceof Promise)
+                throw new Error(
+                  ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+                );
+              return result;
+            }),
+          ];
+        })
+        .then(([data, result]) => {
+          console.log(`after check`);
+          console.log([data, result]);
+          return data;
+        });
+    } else if (effect.type === ""mod"") {
+      finalPromise = finalPromise
+        .then((data) => {
+          if (def.t !== ZodTypes.transformer)
+            throw new Error(
+              ""Only transformers can contain transformation functions.""
+            );
+          const newData = effect.mod(data);
+
+          return newData;
+        })
+        .then((data) => {
+          if (isSync && data instanceof Promise) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return data;
+        });
+    } else {
+      throw new Error(`Invalid effect type.`);
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      //
-      //
-      if (effect.type === ""check"") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        //
-        if (checkResult instanceof Promise)
-          throw new Error(
-            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-          );
-      } else if (effect.type === ""mod"") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error(""Only Modders can contain mods"");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      // throw ERROR;
-      return { success: false, error: ERROR };
-    }
-
-    return { success: true, data: finalValue };
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.custom,
-            message: ""Invalid"",
-          })
+  }
+
+  finalPromise = finalPromise
+    .then((data) => {
+      if (!params.error.isEmpty) throw params.error;
+      if (data === INVALID && params.error.isEmpty) {
+        throw new Error(
+          ""Internal Zod error: please file an issue containing the offending code at https://github.com/colinhacks/zod.""
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      let finalValue = resolvedValue;
-
-      for (const effect of effects) {
-        if (effect.type === ""check"") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === ""mod"") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error(""Only Modders can contain mods"");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      return { success: true, data: finalValue };
-    };
-
-    return checker() as any;
-  }
+      return data;
+    })
+    .then((data) => {
+      return { success: true, data };
+    })
+    .catch((error) => {
+      if (error instanceof ZodError) return { success: false, error };
+      throw error;
+    });
+
+  // get value
+  // if error is not empty, return error
+  // run through effects
+  // return either success or failure payload
+
+  // const isSync = params.async === false || def.t === ZodTypes.promise;
+
+  return isSync ? finalPromise.getValueSync() : finalPromise.getValueAsync();
+
+  // if (isSync) {
+  //   const resolvedValue = PROMISE.getValueSync();
+
+  //   if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //     throw new Error(
+  //       ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
+  //     );
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     return { success: false, error: ERROR };
+  //     // throw ERROR;
+  //   }
+
+  //   let finalValue = resolvedValue;
+
+  //   for (const effect of effects) {
+  //     //
+  //     //
+  //     if (effect.type === ""check"") {
+  //       const checkResult = effect.check(finalValue, checkCtx);
+  //       //
+  //       if (checkResult instanceof Promise)
+  //         throw new Error(
+  //           ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+  //         );
+  //     } else if (effect.type === ""mod"") {
+  //       if (def.t !== ZodTypes.transformer)
+  //         throw new Error(""Only Modders can contain mods"");
+  //       finalValue = effect.mod(finalValue);
+  //       if (finalValue instanceof Promise) {
+  //         throw new Error(
+  //           `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+  //         );
+  //       }
+  //     } else {
+  //       throw new Error(`Invalid effect type.`);
+  //     }
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     // throw ERROR;
+  //     return { success: false, error: ERROR };
+  //   }
+
+  //   return { success: true, data: finalValue };
+  // } else {
+  //   // if (params.async == true) {
+  //   const checker = async () => {
+  //     const resolvedValue = await PROMISE.getValueAsync();
+
+  //     if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //       // let someError: boolean = false;
+
+  //       addIssue(params, data, {
+  //         code: ZodIssueCode.custom,
+  //         message: ""Invalid"",
+  //       });
+  //     }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     let finalValue = resolvedValue;
+
+  //     for (const effect of effects) {
+  //       if (effect.type === ""check"") {
+  //         await effect.check(finalValue, checkCtx);
+  //       } else if (effect.type === ""mod"") {
+  //         if (def.t !== ZodTypes.transformer)
+  //           throw new Error(""Only Modders can contain mods"");
+  //         finalValue = await effect.mod(finalValue);
+  //       }
+  //     }
+
+  //     // if (params.runAsyncValidationsInSeries) {
+  //     //   let someError = false;
+  //     //   await customChecks.reduce((previousPromise, check) => {
+  //     //     return previousPromise.then(async () => {
+  //     //       if (!someError) {
+  //     //         const len = ERROR.issues.length;
+  //     //         await check.check(resolvedValue, checkCtx);
+  //     //         if (len < ERROR.issues.length) someError = true;
+  //     //       }
+  //     //     });
+  //     //   }, Promise.resolve());
+  //     // } else {
+  //     //   await Promise.all(
+  //     //     customChecks.map(async (check) => {
+  //     //       await check.check(resolvedValue, checkCtx);
+  //     //     })
+  //     //   );
+  //     // }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     return { success: true, data: finalValue };
+  //   };
+
+  //   return checker() as any;
+  // }","+import { getParsedType, ZodParsedType } from ""./helpers/parseUtil.ts"";
-import { MakeErrorData, ZodError, ZodIssue, ZodIssueCode } from ""./ZodError.ts"";
-import { ZodParsedType } from ""./ZodParsedType.ts"";
+import { MakeErrorData, ZodError, ZodIssueCode } from ""./ZodError.ts"";
-export const getParsedType = (data: any): ZodParsedType => {
-  if (typeof data === ""string"") return ""string"";
-  if (typeof data === ""number"") {
-    if (Number.isNaN(data)) return ""nan"";
-    return ""number"";
-  }
-  if (typeof data === ""boolean"") return ""boolean"";
-  if (typeof data === ""bigint"") return ""bigint"";
-  if (typeof data === ""symbol"") return ""symbol"";
-  if (data instanceof Date) return ""date"";
-  if (typeof data === ""function"") return ""function"";
-  if (data === undefined) return ""undefined"";
-  if (typeof data === ""undefined"") return ""undefined"";
-  if (typeof data === ""object"") {
-    if (Array.isArray(data)) return ""array"";
-    if (data === null) return ""null"";
-    if (
-      data.then &&
-      typeof data.then === ""function"" &&
-      data.catch &&
-      typeof data.catch === ""function""
-    ) {
-      return ""promise"";
-    }
-    if (data instanceof Map) {
-      return ""map"";
-    }
-    if (data instanceof Set) {
-      return ""set"";
-    }
-    return ""object"";
-  }
-  return ""unknown"";
-};
-
-const makeError = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-): ZodIssue => {
+const addIssue = (params: ParseParams, data: any, errorData: MakeErrorData) => {
-  // params.error.addIssue(issue);
-  return issue;
+  params.error.addIssue(issue);
+  // return issue;
-  seen?: {
+  seen: {
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  error?: ZodError;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  error: ZodError;
+  async: boolean;
+  runAsyncValidationsInSeries: boolean;
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
+  baseParams: Partial<ParseParams> = {
+    seen: [],
+    errorMap: defaultErrorMap,
+    path: [],
+  }
-  const params: Required<ParseParams> = {
+  const params: ParseParams = {
-  (PROMISE as any)._default = true;
+  // (PROMISE as any)._default = true;
+  // console.log(`\n#########\nParsing ${def.t}`);
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.string,
-            received: parsedType,
-          })
-        );
+        // ERROR.addIssue(
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.string,
+          received: parsedType,
+        });
+        // );
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.number,
-            received: ZodParsedType.nan,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.number,
+          received: ZodParsedType.nan,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.bigint,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.bigint,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.boolean,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.boolean,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.undefined,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.undefined,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.null,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.null,
+          received: parsedType,
+        });
-      ERROR.addIssue(
-        makeError(params, data, {
-          code: ZodIssueCode.invalid_type,
-          expected: ZodParsedType.never,
-          received: parsedType,
-        })
-      );
+      addIssue(params, data, {
+        code: ZodIssueCode.invalid_type,
+        expected: ZodParsedType.never,
+        received: parsedType,
+      });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.void,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.void,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.nonempty_array_is_empty,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.nonempty_array_is_empty,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.map,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.map,
+          received: parsedType,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.set,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.set,
+          received: parsedType,
+        });
+
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-            ERROR.addIssue(
-              makeError(params, data, {
-                code: ZodIssueCode.unrecognized_keys,
-                keys: extraKeys,
-              })
-            );
+            addIssue(params, data, {
+              code: ZodIssueCode.unrecognized_keys,
+              keys: extraKeys,
+            });
-        })
+        }) as any
-              ERROR.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_union,
-                  unionErrors,
-                })
-              );
+              addIssue(params, data, {
+                code: ZodIssueCode.invalid_union,
+                unionErrors,
+              });
-                ERROR.addIssue(
-                  makeError(params, data, {
-                    code: ZodIssueCode.invalid_union,
-                    unionErrors,
-                  })
-                );
+                addIssue(params, data, {
+                  code: ZodIssueCode.invalid_union,
+                  unionErrors,
+                });
-        .then((unionResults: any[]) => {
+        .then((unionResults: any) => {
-          ERROR.addIssue(
-            makeError(params, data, {
-              code: ZodIssueCode.invalid_intersection_types,
-            })
-          );
+          addIssue(params, data, {
+            code: ZodIssueCode.invalid_intersection_types,
+          });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.array,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.array,
+          received: parsedType,
+        });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_big,
-            maximum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_big,
+          maximum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.too_small,
-            minimum: def.items.length,
-            inclusive: true,
-            type: ""array"",
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.too_small,
+          minimum: def.items.length,
+          inclusive: true,
+          type: ""array"",
+        });
-          // .catch((err) => {
-          //   if (err instanceof ZodError) {
-          //     ERROR.addIssues(err.issues);
-          //     return;
-          //   }
-          //   throw err;
-          // })
-          // .then((arg) => {
-          //   return arg;
-          // });
-        })
+        }) as any
-        ERROR.addIssue(
-          makeError(params, data, {
-            // code: ZodIssueCode.invalid_literal_value,
-            code: ZodIssueCode.invalid_type,
-            expected: def.value,
-            received: data,
-          })
-        );
+        addIssue(params, data, {
+          // code: ZodIssueCode.invalid_literal_value,
+          code: ZodIssueCode.invalid_type,
+          expected: def.value,
+          received: data,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: def.values,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: def.values,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_enum_value,
-            options: util.objectValues(nativeEnumValues),
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_enum_value,
+          options: util.objectValues(nativeEnumValues),
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.function,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.function,
+          received: parsedType,
+        });
-          //     makeError(params, data, {
+          //     addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_arguments,
-                  argumentsError: argsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_arguments,
+                argumentsError: argsError,
+              });
+
-          //       makeError(params, data, {
+          //       addIssue(params, data, {
-              newError.addIssue(
-                makeError(params, data, {
-                  code: ZodIssueCode.invalid_return_type,
-                  returnTypeError: returnsError,
-                })
-              );
+
+              addIssue({ ...params, error: newError }, data, {
+                code: ZodIssueCode.invalid_return_type,
+                returnTypeError: returnsError,
+              });
+
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.object,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.object,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.date,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.date,
+          received: parsedType,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_date,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_date,
+        });
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.invalid_type,
-            expected: ZodParsedType.promise,
-            received: parsedType,
-          })
-        );
+        addIssue(params, data, {
+          code: ZodIssueCode.invalid_type,
+          expected: ZodParsedType.promise,
+          received: parsedType,
+        });
+  const isSync = params.async === false || def.t === ZodTypes.promise;
+
-
-      ERROR.addIssue(makeError(params, data, arg));
+      addIssue(params, data, arg);
-  // const isSync = !params.async;
-
-  const isSync = params.async === false || def.t === ZodTypes.promise;
-
-  if (isSync) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      throw new Error(
-        ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
-      );
+  console.log(`Running ${effects.length} effects`);
+
+  let finalPromise = PROMISE.then((data) => {
+    // if (!params.error.isEmpty) {
+    if (data === INVALID) {
+      console.log(`errors already exist! throwing...`);
+      throw params.error;
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      return { success: false, error: ERROR };
-      // throw ERROR;
+    return data;
+  });
+
+  for (const effect of effects) {
+    if (effect.type === ""check"") {
+      finalPromise = finalPromise
+        .all((data) => {
+          console.log(`CHECK`);
+          return [
+            PseudoPromise.resolve(data),
+            PseudoPromise.resolve(data).then(() => {
+              const result = effect.check(data, checkCtx);
+
+              if (isSync && result instanceof Promise)
+                throw new Error(
+                  ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+                );
+              return result;
+            }),
+          ];
+        })
+        .then(([data, result]) => {
+          console.log(`after check`);
+          console.log([data, result]);
+          return data;
+        });
+    } else if (effect.type === ""mod"") {
+      finalPromise = finalPromise
+        .then((data) => {
+          if (def.t !== ZodTypes.transformer)
+            throw new Error(
+              ""Only transformers can contain transformation functions.""
+            );
+          const newData = effect.mod(data);
+
+          return newData;
+        })
+        .then((data) => {
+          if (isSync && data instanceof Promise) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return data;
+        });
+    } else {
+      throw new Error(`Invalid effect type.`);
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      //
-      //
-      if (effect.type === ""check"") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        //
-        if (checkResult instanceof Promise)
-          throw new Error(
-            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-          );
-      } else if (effect.type === ""mod"") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error(""Only Modders can contain mods"");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      // throw ERROR;
-      return { success: false, error: ERROR };
-    }
-
-    return { success: true, data: finalValue };
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-        ERROR.addIssue(
-          makeError(params, data, {
-            code: ZodIssueCode.custom,
-            message: ""Invalid"",
-          })
+  }
+
+  finalPromise = finalPromise
+    .then((data) => {
+      if (!params.error.isEmpty) throw params.error;
+      if (data === INVALID && params.error.isEmpty) {
+        throw new Error(
+          ""Internal Zod error: please file an issue containing the offending code at https://github.com/colinhacks/zod.""
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      let finalValue = resolvedValue;
-
-      for (const effect of effects) {
-        if (effect.type === ""check"") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === ""mod"") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error(""Only Modders can contain mods"");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      return { success: true, data: finalValue };
-    };
-
-    return checker() as any;
-  }
+      return data;
+    })
+    .then((data) => {
+      return { success: true, data };
+    })
+    .catch((error) => {
+      if (error instanceof ZodError) return { success: false, error };
+      throw error;
+    });
+
+  // get value
+  // if error is not empty, return error
+  // run through effects
+  // return either success or failure payload
+
+  // const isSync = params.async === false || def.t === ZodTypes.promise;
+
+  return isSync ? finalPromise.getValueSync() : finalPromise.getValueAsync();
+
+  // if (isSync) {
+  //   const resolvedValue = PROMISE.getValueSync();
+
+  //   if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //     throw new Error(
+  //       ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
+  //     );
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     return { success: false, error: ERROR };
+  //     // throw ERROR;
+  //   }
+
+  //   let finalValue = resolvedValue;
+
+  //   for (const effect of effects) {
+  //     //
+  //     //
+  //     if (effect.type === ""check"") {
+  //       const checkResult = effect.check(finalValue, checkCtx);
+  //       //
+  //       if (checkResult instanceof Promise)
+  //         throw new Error(
+  //           ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+  //         );
+  //     } else if (effect.type === ""mod"") {
+  //       if (def.t !== ZodTypes.transformer)
+  //         throw new Error(""Only Modders can contain mods"");
+  //       finalValue = effect.mod(finalValue);
+  //       if (finalValue instanceof Promise) {
+  //         throw new Error(
+  //           `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+  //         );
+  //       }
+  //     } else {
+  //       throw new Error(`Invalid effect type.`);
+  //     }
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     // throw ERROR;
+  //     return { success: false, error: ERROR };
+  //   }
+
+  //   return { success: true, data: finalValue };
+  // } else {
+  //   // if (params.async == true) {
+  //   const checker = async () => {
+  //     const resolvedValue = await PROMISE.getValueAsync();
+
+  //     if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //       // let someError: boolean = false;
+
+  //       addIssue(params, data, {
+  //         code: ZodIssueCode.custom,
+  //         message: ""Invalid"",
+  //       });
+  //     }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     let finalValue = resolvedValue;
+
+  //     for (const effect of effects) {
+  //       if (effect.type === ""check"") {
+  //         await effect.check(finalValue, checkCtx);
+  //       } else if (effect.type === ""mod"") {
+  //         if (def.t !== ZodTypes.transformer)
+  //           throw new Error(""Only Modders can contain mods"");
+  //         finalValue = await effect.mod(finalValue);
+  //       }
+  //     }
+
+  //     // if (params.runAsyncValidationsInSeries) {
+  //     //   let someError = false;
+  //     //   await customChecks.reduce((previousPromise, check) => {
+  //     //     return previousPromise.then(async () => {
+  //     //       if (!someError) {
+  //     //         const len = ERROR.issues.length;
+  //     //         await check.check(resolvedValue, checkCtx);
+  //     //         if (len < ERROR.issues.length) someError = true;
+  //     //       }
+  //     //     });
+  //     //   }, Promise.resolve());
+  //     // } else {
+  //     //   await Promise.all(
+  //     //     customChecks.map(async (check) => {
+  //     //       await check.check(resolvedValue, checkCtx);
+  //     //     })
+  //     //   );
+  //     // }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     return { success: true, data: finalValue };
+  //   };
+
+  //   return checker() as any;
+  // }"
colinhacks_zod,9056e04d53b39b67375f97adeb7a37228c752cb6,FMC,deno/lib/types/base.ts,"-import { ZodOptional, ZodOptionalType } from ""../index.ts"";
+import { ZodOptional, ZodOptionalType } from ""../index.ts"";
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodType      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+
-
-
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;","-import { ZodOptional, ZodOptionalType } from ""../index.ts"";
+import { defaultErrorMap } from ""../defaultErrorMap.ts"";
+import { ZodOptional, ZodOptionalType } from ""../index.ts"";
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodType      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+
-
-
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
-  _parseRaw: (
+  // _parseInternal
+
+  // _parse: (data: unknown, params: ParseParams) => PseudoPromise<Output> = (
+  //   data,
+  //   params
+  // ) => {
+  //   const def = this._def;
+
+  //   let PROMISE: PseudoPromise<any> = PseudoPromise.resolve(INVALID);
+  //   (PROMISE as any)._default = true;
+
+  //   params.seen = params.seen || [];
+
+  //   const ERROR = params.error;
+  //   const parsedType = getParsedType(data);
+  //   const promise = this;
+  //   return PROMISE;
+  // };
+
+  // _parseInternal: (
+  //   data: unknown,
+  //   params: ParseParams
+  // ) => ZodParserReturnType<Output> = (data, params) => {
+  //   const def = this._def;
+
+  //   let PROMISE: PseudoPromise<any> = PseudoPromise.resolve(INVALID);
+  //   (PROMISE as any)._default = true;
+
+  //   params.seen = params.seen || [];
+
+  //   const ERROR = params.error;
+  //   const parsedType = getParsedType(data);
+
+  //   const promise = this._parse(data, params);
+  // };
+
+  _parseInternal: (
-    params?: ParseParams
+    params: ParseParams
-    const result = parser(data, params);
-    return result;
-  };
-
-  parse: (data: unknown, params?: ParseParams) => Output = (data, params) => {
-    const result = this._parseRaw(data, params);
+    return parser(data, params);
+  };
+
+  _parseInternalOptionalParams: (
+    data: unknown,
+    params?: Partial<ParseParams>
+  ) => ZodParserReturnType<Output> = (data, params = {}) => {
+    const fullParams: ParseParams = {
+      seen: params.seen || [],
+      path: params.path || [],
+      error: params.error || new ZodError([]),
+      errorMap: params.errorMap || defaultErrorMap,
+      async: params.async ?? false,
+      runAsyncValidationsInSeries: params.runAsyncValidationsInSeries ?? false,
+    };
+
+    return this._parseInternal(data, fullParams);
+  };
+
+  parse: (data: unknown, params?: Partial<ParseParams>) => Output = (
+    data,
+    params
+  ) => {
+    const result = this._parseInternalOptionalParams(data, params);
-    params?: ParseParams
+    params?: Partial<ParseParams>
-    const result = this._parseRaw(data, params);
+    const result = this._parseInternalOptionalParams(data, params);
-    //   return this._parseRaw(data, params);
+    //   return this._parseInternalOptionalParams(data, params);
-  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
-    data,
-    params
-  ) => {
-    const result = await this._parseRaw(data, { ...params, async: true });
+  parseAsync: (
+    x: unknown,
+    params?: Partial<ParseParams>
+  ) => Promise<Output> = async (data, params) => {
+    const result = await this._parseInternalOptionalParams(data, {
+      ...params,
+      async: true,
+    });
-    params?: ParseParams
+    params?: Partial<ParseParams>
-    return await this._parseRaw(data, { ...params, async: true });
+    return await this._parseInternalOptionalParams(data, {
+      ...params,
+      async: true,
+    });
-  _parseWithInvalidFallback: (
-    x: unknown,
-    params: Required<ParseParams>
-  ) => Output = (x, params) => {
+  _parseWithInvalidFallback: (x: unknown, params: ParseParams) => Output = (
+    x,
+    params
+  ) => {","-import { ZodOptional, ZodOptionalType } from ""../index.ts"";
+import { defaultErrorMap } from ""../defaultErrorMap.ts"";
+import { ZodOptional, ZodOptionalType } from ""../index.ts"";
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+///////////////////////////////////////
+///////////////////////////////////////
+//////////                   //////////
+//////////      ZodType      //////////
+//////////                   //////////
+///////////////////////////////////////
+///////////////////////////////////////
+
-
-
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
-  _parseRaw: (
+  // _parseInternal
+
+  // _parse: (data: unknown, params: ParseParams) => PseudoPromise<Output> = (
+  //   data,
+  //   params
+  // ) => {
+  //   const def = this._def;
+
+  //   let PROMISE: PseudoPromise<any> = PseudoPromise.resolve(INVALID);
+  //   (PROMISE as any)._default = true;
+
+  //   params.seen = params.seen || [];
+
+  //   const ERROR = params.error;
+  //   const parsedType = getParsedType(data);
+  //   const promise = this;
+  //   return PROMISE;
+  // };
+
+  // _parseInternal: (
+  //   data: unknown,
+  //   params: ParseParams
+  // ) => ZodParserReturnType<Output> = (data, params) => {
+  //   const def = this._def;
+
+  //   let PROMISE: PseudoPromise<any> = PseudoPromise.resolve(INVALID);
+  //   (PROMISE as any)._default = true;
+
+  //   params.seen = params.seen || [];
+
+  //   const ERROR = params.error;
+  //   const parsedType = getParsedType(data);
+
+  //   const promise = this._parse(data, params);
+  // };
+
+  _parseInternal: (
-    params?: ParseParams
+    params: ParseParams
-    const result = parser(data, params);
-    return result;
-  };
-
-  parse: (data: unknown, params?: ParseParams) => Output = (data, params) => {
-    const result = this._parseRaw(data, params);
+    return parser(data, params);
+  };
+
+  _parseInternalOptionalParams: (
+    data: unknown,
+    params?: Partial<ParseParams>
+  ) => ZodParserReturnType<Output> = (data, params = {}) => {
+    const fullParams: ParseParams = {
+      seen: params.seen || [],
+      path: params.path || [],
+      error: params.error || new ZodError([]),
+      errorMap: params.errorMap || defaultErrorMap,
+      async: params.async ?? false,
+      runAsyncValidationsInSeries: params.runAsyncValidationsInSeries ?? false,
+    };
+
+    return this._parseInternal(data, fullParams);
+  };
+
+  parse: (data: unknown, params?: Partial<ParseParams>) => Output = (
+    data,
+    params
+  ) => {
+    const result = this._parseInternalOptionalParams(data, params);
-    params?: ParseParams
+    params?: Partial<ParseParams>
-    const result = this._parseRaw(data, params);
+    const result = this._parseInternalOptionalParams(data, params);
-    //   return this._parseRaw(data, params);
+    //   return this._parseInternalOptionalParams(data, params);
-  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
-    data,
-    params
-  ) => {
-    const result = await this._parseRaw(data, { ...params, async: true });
+  parseAsync: (
+    x: unknown,
+    params?: Partial<ParseParams>
+  ) => Promise<Output> = async (data, params) => {
+    const result = await this._parseInternalOptionalParams(data, {
+      ...params,
+      async: true,
+    });
-    params?: ParseParams
+    params?: Partial<ParseParams>
-    return await this._parseRaw(data, { ...params, async: true });
+    return await this._parseInternalOptionalParams(data, {
+      ...params,
+      async: true,
+    });
-  _parseWithInvalidFallback: (
-    x: unknown,
-    params: Required<ParseParams>
-  ) => Output = (x, params) => {
+  _parseWithInvalidFallback: (x: unknown, params: ParseParams) => Output = (
+    x,
+    params
+  ) => {"
colinhacks_zod,9056e04d53b39b67375f97adeb7a37228c752cb6,FMC,src/parser.ts,"-              addIssue(params, data, {
+              addIssue({ ...params, error: newError }, data, {","-const addIssue = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-) => {
+const addIssue = (params: ParseParams, data: any, errorData: MakeErrorData) => {
-  seen?: {
+  seen: {
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  error?: ZodError;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  error: ZodError;
+  async: boolean;
+  runAsyncValidationsInSeries: boolean;
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
+  baseParams: Partial<ParseParams> = {
+    seen: [],
+    errorMap: defaultErrorMap,
+    path: [],
+  }
-  const params: Required<ParseParams> = {
+  const params: ParseParams = {
-  (PROMISE as any)._default = true;
+  // (PROMISE as any)._default = true;
+  // console.log(`\n#########\nParsing ${def.t}`);
-        })
+        }) as any
-        })
+        }) as any
-        })
+        }) as any
-        })
+        }) as any
-        .then((unionResults: any[]) => {
+        .then((unionResults: any) => {
-        })
+        }) as any
-              addIssue(params, data, {
+              addIssue({ ...params, error: newError }, data, {
+  const isSync = params.async === false || def.t === ZodTypes.promise;
+
-
-  // const isSync = !params.async;
-
-  const isSync = params.async === false || def.t === ZodTypes.promise;
-
-  if (isSync) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      throw new Error(
-        ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
-      );
+  console.log(`Running ${effects.length} effects`);
+
+  let finalPromise = PROMISE.then((data) => {
+    // if (!params.error.isEmpty) {
+    if (data === INVALID) {
+      console.log(`errors already exist! throwing...`);
+      throw params.error;
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      return { success: false, error: ERROR };
-      // throw ERROR;
+    return data;
+  });
+
+  for (const effect of effects) {
+    if (effect.type === ""check"") {
+      finalPromise = finalPromise
+        .all((data) => {
+          console.log(`CHECK`);
+          return [
+            PseudoPromise.resolve(data),
+            PseudoPromise.resolve(data).then(() => {
+              const result = effect.check(data, checkCtx);
+
+              if (isSync && result instanceof Promise)
+                throw new Error(
+                  ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+                );
+              return result;
+            }),
+          ];
+        })
+        .then(([data, result]) => {
+          console.log(`after check`);
+          console.log([data, result]);
+          return data;
+        });
+    } else if (effect.type === ""mod"") {
+      finalPromise = finalPromise
+        .then((data) => {
+          if (def.t !== ZodTypes.transformer)
+            throw new Error(
+              ""Only transformers can contain transformation functions.""
+            );
+          const newData = effect.mod(data);
+
+          return newData;
+        })
+        .then((data) => {
+          if (isSync && data instanceof Promise) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return data;
+        });
+    } else {
+      throw new Error(`Invalid effect type.`);
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      //
-      //
-      if (effect.type === ""check"") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        //
-        if (checkResult instanceof Promise)
-          throw new Error(
-            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-          );
-      } else if (effect.type === ""mod"") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error(""Only Modders can contain mods"");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      // throw ERROR;
-      return { success: false, error: ERROR };
-    }
-
-    return { success: true, data: finalValue };
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-
-        addIssue(params, data, {
-          code: ZodIssueCode.custom,
-          message: ""Invalid"",
-        });
-      }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      let finalValue = resolvedValue;
-
-      for (const effect of effects) {
-        if (effect.type === ""check"") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === ""mod"") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error(""Only Modders can contain mods"");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      return { success: true, data: finalValue };
-    };
-
-    return checker() as any;
+
+  finalPromise = finalPromise
+    .then((data) => {
+      if (!params.error.isEmpty) throw params.error;
+      if (data === INVALID && params.error.isEmpty) {
+        throw new Error(
+          ""Internal Zod error: please file an issue containing the offending code at https://github.com/colinhacks/zod.""
+        );
+      }
+
+      return data;
+    })
+    .then((data) => {
+      return { success: true, data };
+    })
+    .catch((error) => {
+      if (error instanceof ZodError) return { success: false, error };
+      throw error;
+    });
+
+  // get value
+  // if error is not empty, return error
+  // run through effects
+  // return either success or failure payload
+
+  // const isSync = params.async === false || def.t === ZodTypes.promise;
+
+  return isSync ? finalPromise.getValueSync() : finalPromise.getValueAsync();
+
+  // if (isSync) {
+  //   const resolvedValue = PROMISE.getValueSync();
+
+  //   if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //     throw new Error(
+  //       ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
+  //     );
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     return { success: false, error: ERROR };
+  //     // throw ERROR;
+  //   }
+
+  //   let finalValue = resolvedValue;
+
+  //   for (const effect of effects) {
+  //     //
+  //     //
+  //     if (effect.type === ""check"") {
+  //       const checkResult = effect.check(finalValue, checkCtx);
+  //       //
+  //       if (checkResult instanceof Promise)
+  //         throw new Error(
+  //           ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+  //         );
+  //     } else if (effect.type === ""mod"") {
+  //       if (def.t !== ZodTypes.transformer)
+  //         throw new Error(""Only Modders can contain mods"");
+  //       finalValue = effect.mod(finalValue);
+  //       if (finalValue instanceof Promise) {
+  //         throw new Error(
+  //           `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+  //         );
+  //       }
+  //     } else {
+  //       throw new Error(`Invalid effect type.`);
+  //     }
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     // throw ERROR;
+  //     return { success: false, error: ERROR };
+  //   }
+
+  //   return { success: true, data: finalValue };
+  // } else {
+  //   // if (params.async == true) {
+  //   const checker = async () => {
+  //     const resolvedValue = await PROMISE.getValueAsync();
+
+  //     if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //       // let someError: boolean = false;
+
+  //       addIssue(params, data, {
+  //         code: ZodIssueCode.custom,
+  //         message: ""Invalid"",
+  //       });
+  //     }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     let finalValue = resolvedValue;
+
+  //     for (const effect of effects) {
+  //       if (effect.type === ""check"") {
+  //         await effect.check(finalValue, checkCtx);
+  //       } else if (effect.type === ""mod"") {
+  //         if (def.t !== ZodTypes.transformer)
+  //           throw new Error(""Only Modders can contain mods"");
+  //         finalValue = await effect.mod(finalValue);
+  //       }
+  //     }
+
+  //     // if (params.runAsyncValidationsInSeries) {
+  //     //   let someError = false;
+  //     //   await customChecks.reduce((previousPromise, check) => {
+  //     //     return previousPromise.then(async () => {
+  //     //       if (!someError) {
+  //     //         const len = ERROR.issues.length;
+  //     //         await check.check(resolvedValue, checkCtx);
+  //     //         if (len < ERROR.issues.length) someError = true;
+  //     //       }
+  //     //     });
+  //     //   }, Promise.resolve());
+  //     // } else {
+  //     //   await Promise.all(
+  //     //     customChecks.map(async (check) => {
+  //     //       await check.check(resolvedValue, checkCtx);
+  //     //     })
+  //     //   );
+  //     // }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     return { success: true, data: finalValue };
+  //   };
+
+  //   return checker() as any;
+  // }","-const addIssue = (
-  params: Required<ParseParams>,
-  data: any,
-  errorData: MakeErrorData
-) => {
+const addIssue = (params: ParseParams, data: any, errorData: MakeErrorData) => {
-  seen?: {
+  seen: {
-  path?: (string | number)[];
-  errorMap?: ZodErrorMap;
-  error?: ZodError;
-  async?: boolean;
-  runAsyncValidationsInSeries?: boolean;
+  path: (string | number)[];
+  errorMap: ZodErrorMap;
+  error: ZodError;
+  async: boolean;
+  runAsyncValidationsInSeries: boolean;
-  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] }
+  baseParams: Partial<ParseParams> = {
+    seen: [],
+    errorMap: defaultErrorMap,
+    path: [],
+  }
-  const params: Required<ParseParams> = {
+  const params: ParseParams = {
-  (PROMISE as any)._default = true;
+  // (PROMISE as any)._default = true;
+  // console.log(`\n#########\nParsing ${def.t}`);
-        })
+        }) as any
-        })
+        }) as any
-        })
+        }) as any
-        })
+        }) as any
-        .then((unionResults: any[]) => {
+        .then((unionResults: any) => {
-        })
+        }) as any
-              addIssue(params, data, {
+              addIssue({ ...params, error: newError }, data, {
+  const isSync = params.async === false || def.t === ZodTypes.promise;
+
-
-  // const isSync = !params.async;
-
-  const isSync = params.async === false || def.t === ZodTypes.promise;
-
-  if (isSync) {
-    const resolvedValue = PROMISE.getValueSync();
-
-    if (resolvedValue === INVALID && ERROR.isEmpty) {
-      throw new Error(
-        ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
-      );
+  console.log(`Running ${effects.length} effects`);
+
+  let finalPromise = PROMISE.then((data) => {
+    // if (!params.error.isEmpty) {
+    if (data === INVALID) {
+      console.log(`errors already exist! throwing...`);
+      throw params.error;
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      return { success: false, error: ERROR };
-      // throw ERROR;
+    return data;
+  });
+
+  for (const effect of effects) {
+    if (effect.type === ""check"") {
+      finalPromise = finalPromise
+        .all((data) => {
+          console.log(`CHECK`);
+          return [
+            PseudoPromise.resolve(data),
+            PseudoPromise.resolve(data).then(() => {
+              const result = effect.check(data, checkCtx);
+
+              if (isSync && result instanceof Promise)
+                throw new Error(
+                  ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+                );
+              return result;
+            }),
+          ];
+        })
+        .then(([data, result]) => {
+          console.log(`after check`);
+          console.log([data, result]);
+          return data;
+        });
+    } else if (effect.type === ""mod"") {
+      finalPromise = finalPromise
+        .then((data) => {
+          if (def.t !== ZodTypes.transformer)
+            throw new Error(
+              ""Only transformers can contain transformation functions.""
+            );
+          const newData = effect.mod(data);
+
+          return newData;
+        })
+        .then((data) => {
+          if (isSync && data instanceof Promise) {
+            throw new Error(
+              `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+            );
+          }
+          return data;
+        });
+    } else {
+      throw new Error(`Invalid effect type.`);
-
-    let finalValue = resolvedValue;
-
-    for (const effect of effects) {
-      //
-      //
-      if (effect.type === ""check"") {
-        const checkResult = effect.check(finalValue, checkCtx);
-        //
-        if (checkResult instanceof Promise)
-          throw new Error(
-            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
-          );
-      } else if (effect.type === ""mod"") {
-        if (def.t !== ZodTypes.transformer)
-          throw new Error(""Only Modders can contain mods"");
-        finalValue = effect.mod(finalValue);
-        if (finalValue instanceof Promise) {
-          throw new Error(
-            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
-          );
-        }
-      } else {
-        throw new Error(`Invalid effect type.`);
-      }
-    }
-
-    if (!ERROR.isEmpty) {
-      // THROW();
-      // throw ERROR;
-      return { success: false, error: ERROR };
-    }
-
-    return { success: true, data: finalValue };
-  } else {
-    // if (params.async == true) {
-    const checker = async () => {
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        // let someError: boolean = false;
-
-        addIssue(params, data, {
-          code: ZodIssueCode.custom,
-          message: ""Invalid"",
-        });
-      }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      let finalValue = resolvedValue;
-
-      for (const effect of effects) {
-        if (effect.type === ""check"") {
-          await effect.check(finalValue, checkCtx);
-        } else if (effect.type === ""mod"") {
-          if (def.t !== ZodTypes.transformer)
-            throw new Error(""Only Modders can contain mods"");
-          finalValue = await effect.mod(finalValue);
-        }
-      }
-
-      // if (params.runAsyncValidationsInSeries) {
-      //   let someError = false;
-      //   await customChecks.reduce((previousPromise, check) => {
-      //     return previousPromise.then(async () => {
-      //       if (!someError) {
-      //         const len = ERROR.issues.length;
-      //         await check.check(resolvedValue, checkCtx);
-      //         if (len < ERROR.issues.length) someError = true;
-      //       }
-      //     });
-      //   }, Promise.resolve());
-      // } else {
-      //   await Promise.all(
-      //     customChecks.map(async (check) => {
-      //       await check.check(resolvedValue, checkCtx);
-      //     })
-      //   );
-      // }
-
-      if (!ERROR.isEmpty) {
-        // THROW();
-        return { success: false, error: ERROR };
-      }
-
-      return { success: true, data: finalValue };
-    };
-
-    return checker() as any;
+
+  finalPromise = finalPromise
+    .then((data) => {
+      if (!params.error.isEmpty) throw params.error;
+      if (data === INVALID && params.error.isEmpty) {
+        throw new Error(
+          ""Internal Zod error: please file an issue containing the offending code at https://github.com/colinhacks/zod.""
+        );
+      }
+
+      return data;
+    })
+    .then((data) => {
+      return { success: true, data };
+    })
+    .catch((error) => {
+      if (error instanceof ZodError) return { success: false, error };
+      throw error;
+    });
+
+  // get value
+  // if error is not empty, return error
+  // run through effects
+  // return either success or failure payload
+
+  // const isSync = params.async === false || def.t === ZodTypes.promise;
+
+  return isSync ? finalPromise.getValueSync() : finalPromise.getValueAsync();
+
+  // if (isSync) {
+  //   const resolvedValue = PROMISE.getValueSync();
+
+  //   if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //     throw new Error(
+  //       ""Value is INVALID. This should never happen and means there is an error within Zod. Please file an issue at https://github.com/colinhacks/zod.""
+  //     );
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     return { success: false, error: ERROR };
+  //     // throw ERROR;
+  //   }
+
+  //   let finalValue = resolvedValue;
+
+  //   for (const effect of effects) {
+  //     //
+  //     //
+  //     if (effect.type === ""check"") {
+  //       const checkResult = effect.check(finalValue, checkCtx);
+  //       //
+  //       if (checkResult instanceof Promise)
+  //         throw new Error(
+  //           ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+  //         );
+  //     } else if (effect.type === ""mod"") {
+  //       if (def.t !== ZodTypes.transformer)
+  //         throw new Error(""Only Modders can contain mods"");
+  //       finalValue = effect.mod(finalValue);
+  //       if (finalValue instanceof Promise) {
+  //         throw new Error(
+  //           `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+  //         );
+  //       }
+  //     } else {
+  //       throw new Error(`Invalid effect type.`);
+  //     }
+  //   }
+
+  //   if (!ERROR.isEmpty) {
+  //     // THROW();
+  //     // throw ERROR;
+  //     return { success: false, error: ERROR };
+  //   }
+
+  //   return { success: true, data: finalValue };
+  // } else {
+  //   // if (params.async == true) {
+  //   const checker = async () => {
+  //     const resolvedValue = await PROMISE.getValueAsync();
+
+  //     if (resolvedValue === INVALID && ERROR.isEmpty) {
+  //       // let someError: boolean = false;
+
+  //       addIssue(params, data, {
+  //         code: ZodIssueCode.custom,
+  //         message: ""Invalid"",
+  //       });
+  //     }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     let finalValue = resolvedValue;
+
+  //     for (const effect of effects) {
+  //       if (effect.type === ""check"") {
+  //         await effect.check(finalValue, checkCtx);
+  //       } else if (effect.type === ""mod"") {
+  //         if (def.t !== ZodTypes.transformer)
+  //           throw new Error(""Only Modders can contain mods"");
+  //         finalValue = await effect.mod(finalValue);
+  //       }
+  //     }
+
+  //     // if (params.runAsyncValidationsInSeries) {
+  //     //   let someError = false;
+  //     //   await customChecks.reduce((previousPromise, check) => {
+  //     //     return previousPromise.then(async () => {
+  //     //       if (!someError) {
+  //     //         const len = ERROR.issues.length;
+  //     //         await check.check(resolvedValue, checkCtx);
+  //     //         if (len < ERROR.issues.length) someError = true;
+  //     //       }
+  //     //     });
+  //     //   }, Promise.resolve());
+  //     // } else {
+  //     //   await Promise.all(
+  //     //     customChecks.map(async (check) => {
+  //     //       await check.check(resolvedValue, checkCtx);
+  //     //     })
+  //     //   );
+  //     // }
+
+  //     if (!ERROR.isEmpty) {
+  //       // THROW();
+  //       return { success: false, error: ERROR };
+  //     }
+
+  //     return { success: true, data: finalValue };
+  //   };
+
+  //   return checker() as any;
+  // }"
colinhacks_zod,fed1a2a9a96c1d23a8e245bd89202a8155853660,FMC,src/playground.ts,"+
+interface RouteDefinition<I, O, P> {
+  path: string;
+  method?: string;
+  validate?: {
+    input?: z.ZodType<I>;
+    output?: z.ZodType<O>;
+    params?: z.ZodType<P>;
+  };
+  // resolve(ctx: P): Promise<O>;
+}
+
+const route = <T extends RouteDefinition<any, any, any>>(arg: T) => {
+  return arg;
+};
+
+const params = z.object({
+  id: z.transformer(z.string(), z.number(), (x) => Number(x)),
+});
+
+route({
+  path: ""adf"",
+  method: ""POST"",
+  validate: {
+    input: params,
+    output: params,
+    params: params,
+  },
+  // resolve:
+});","-import * as z from ""."";
-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);","-import * as z from ""."";
-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);"
colinhacks_zod,93561eb8990a76546d591d7b1201aa423e0ad591,cleared playground,deno/lib/playground.ts,"-// const asyncNumberToString = z
-//   .transformer(z.number())
-//   .transform(async (n) => String(n));
-// console.log(
-//   z
-//     .object({
-//       id: asyncNumberToString,
-//     })
-//     .parse({ id: 5 })
-// );
+const Schema = z.union([
+  z.object({
+    statusCode: z.literal(200),
+    body: z.object({
+      id: z.string(),
+    }),
+  }),
+  z.object({
+    statusCode: z.literal(403),
+    body: z.object({
+      message: z.string(),
+      reason: z.string().nullable(),
+    }),
+  }),
+]);
-const run = async () => {
-  const numToString = z.transformer(z.number()).transform(async (n) => {
-    const res = String(n);
-    return res;
-  });
-
-  console.log(typeof (await numToString.parseAsync(1234)));
-  const obj = z.object({
-    id: numToString,
-  });
-  const data = await obj.parseAsync({ id: 5 });
-  console.log(data);
-};
-run();
+(async () => {
+  const obj = {
+    statusCode: 200,
+    body: { id: ""f8a2ebc9-72ba-4f45-ad4d-16f956259ed3"" },
+  };
+  console.log(Schema.parse(obj)); // Works
+  console.log(await Schema.parseAsync(obj)); // Error
+})();","-import * as z from ""./index.ts"";
-
-// const asyncNumberToString = z
-//   .transformer(z.number())
-//   .transform(async (n) => String(n));
-// console.log(
-//   z
-//     .object({
-//       id: asyncNumberToString,
-//     })
-//     .parse({ id: 5 })
-// );
-
-const run = async () => {
-  const numToString = z.transformer(z.number()).transform(async (n) => {
-    const res = String(n);
-    return res;
-  });
-
-  console.log(typeof (await numToString.parseAsync(1234)));
-  const obj = z.object({
-    id: numToString,
-  });
-  const data = await obj.parseAsync({ id: 5 });
-  console.log(data);
-};
-run();","-import * as z from ""./index.ts"";
-
-// const asyncNumberToString = z
-//   .transformer(z.number())
-//   .transform(async (n) => String(n));
-// console.log(
-//   z
-//     .object({
-//       id: asyncNumberToString,
-//     })
-//     .parse({ id: 5 })
-// );
-
-const run = async () => {
-  const numToString = z.transformer(z.number()).transform(async (n) => {
-    const res = String(n);
-    return res;
-  });
-
-  console.log(typeof (await numToString.parseAsync(1234)));
-  const obj = z.object({
-    id: numToString,
-  });
-  const data = await obj.parseAsync({ id: 5 });
-  console.log(data);
-};
-run();"
colinhacks_zod,d26c8d54d50ed3201b8e4c61f2674055a7a6c05e,FMC,src/playground.ts,"-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);
+const Schema = z.union([
+  z.object({
+    statusCode: z.literal(200),
+    body: z.object({
+      id: z.string(),
+    }),
+  }),
+  z.object({
+    statusCode: z.literal(403),
+    body: z.object({
+      message: z.string(),
+      reason: z.string().nullable(),
+    }),
+  }),
+]);
+
+(async () => {
+  const obj = {
+    statusCode: 200,
+    body: { id: ""f8a2ebc9-72ba-4f45-ad4d-16f956259ed3"" },
+  };
+  console.log(Schema.parse(obj)); // Works
+  console.log(await Schema.parseAsync(obj)); // Error
+})();","-import * as z from ""."";
-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);","-import * as z from ""."";
-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,.eslintrc.js,"-    ""import/order"": 0, // turn off in favor of eslint-plugin-simple-import-sort
-    ""import/no-unresolved"": 0,
-    ""import/no-duplicates"": 1,
+    ""import/order"": ""off"", // turn off in favor of eslint-plugin-simple-import-sort
+    ""import/no-unresolved"": ""off"",
+    ""import/no-duplicates"": ""warn"",
-    ""sort-imports"": 0, // we use eslint-plugin-import instead
-    ""simple-import-sort/imports"": 1,
-    ""simple-import-sort/exports"": 1,
+    ""sort-imports"": ""off"", // we use eslint-plugin-import instead
+    ""simple-import-sort/imports"": ""warn"",
+    ""simple-import-sort/exports"": ""warn"",
-    ""@typescript-eslint/no-namespace"": 0,
-    ""@typescript-eslint/explicit-module-boundary-types"": 0,
-    ""@typescript-eslint/no-explicit-any"": 0,
-    ""@typescript-eslint/ban-types"": 0,
-    ""@typescript-eslint/no-unused-vars"": 0,
-    ""@typescript-eslint/no-empty-function"": 0,
-    ""@typescript-eslint/ban-ts-comment"": 0,
-    ""@typescript-eslint/no-non-null-assertion"": 0,
+    ""@typescript-eslint/no-namespace"": ""off"",
+    ""@typescript-eslint/explicit-module-boundary-types"": ""off"",
+    ""@typescript-eslint/no-explicit-any"": ""off"",
+    ""@typescript-eslint/ban-types"": ""off"",
+    ""@typescript-eslint/no-unused-vars"": ""off"",
+    ""@typescript-eslint/no-empty-function"": ""off"",
+    ""@typescript-eslint/ban-ts-comment"": ""off"",
+    ""@typescript-eslint/no-non-null-assertion"": ""off"",
-    ""no-case-declarations"": 0,
-    ""no-empty"": 0,
+    ""no-case-declarations"": ""off"",
+    ""no-empty"": ""off"",","-    ""simple-import-sort/imports"": 1,
-    ""simple-import-sort/exports"": 1,
+    ""simple-import-sort/imports"": 0,
+    ""simple-import-sort/exports"": 0,","-    ""import/order"": 0, // turn off in favor of eslint-plugin-simple-import-sort
-    ""import/no-unresolved"": 0,
-    ""import/no-duplicates"": 1,
+    ""import/order"": ""off"", // turn off in favor of eslint-plugin-simple-import-sort
+    ""import/no-unresolved"": ""off"",
+    ""import/no-duplicates"": ""warn"",
-    ""sort-imports"": 0, // we use eslint-plugin-import instead
-    ""simple-import-sort/imports"": 1,
-    ""simple-import-sort/exports"": 1,
+    ""sort-imports"": ""off"", // we use eslint-plugin-import instead
+    ""simple-import-sort/imports"": ""off"",
+    ""simple-import-sort/exports"": ""off"",
-    ""@typescript-eslint/no-namespace"": 0,
-    ""@typescript-eslint/explicit-module-boundary-types"": 0,
-    ""@typescript-eslint/no-explicit-any"": 0,
-    ""@typescript-eslint/ban-types"": 0,
-    ""@typescript-eslint/no-unused-vars"": 0,
-    ""@typescript-eslint/no-empty-function"": 0,
-    ""@typescript-eslint/ban-ts-comment"": 0,
-    ""@typescript-eslint/no-non-null-assertion"": 0,
+    ""@typescript-eslint/no-namespace"": ""off"",
+    ""@typescript-eslint/explicit-module-boundary-types"": ""off"",
+    ""@typescript-eslint/no-explicit-any"": ""off"",
+    ""@typescript-eslint/ban-types"": ""off"",
+    ""@typescript-eslint/no-unused-vars"": ""off"",
+    ""@typescript-eslint/no-empty-function"": ""off"",
+    ""@typescript-eslint/ban-ts-comment"": ""off"",
+    ""@typescript-eslint/no-non-null-assertion"": ""off"",
-    ""no-case-declarations"": 0,
-    ""no-empty"": 0,
+    ""no-case-declarations"": ""off"",
+    ""no-empty"": ""off"","
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,package.json,"-  ""version"": ""2.0.0-beta.29"",
+  ""version"": ""3.0.0-alpha.2"",
-    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""check:format"": ""prettier --check \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""fix:format"": ""prettier --write \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""check:lint"": ""eslint --ext .ts ./src"",
+    ""check"": ""yarn check:lint && yarn check:format"",
-    ""clean"": ""rm -rf lib/*"",
+    ""clean"": ""rm -rf lib/* deno/lib/*"",
+    ""build:deno"": ""node ./deno/build.mjs"",
+    ""build:esm"": ""tsc --p tsconfig.esm.json"",
-    ""buildallv2"": ""yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.7"",
+    ""buildallv3"": ""yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.8"",
-    ""@typescript-eslint/eslint-plugin"": ""^4.9.1"",
-    ""@typescript-eslint/parser"": ""^4.9.1"",
+    ""@typescript-eslint/eslint-plugin"": ""^4.11.1"",
+    ""@typescript-eslint/parser"": ""^4.11.1"",
-    ""eslint-config-prettier"": ""^7.0.0"",
+    ""eslint-config-prettier"": ""^7.1.0"",
-    ""eslint-plugin-simple-import-sort"": ""^6.0.1"",
+    ""eslint-plugin-simple-import-sort"": ""^7.0.0"",","+    ""dependency-cruiser"": ""^9.19.0"",","-  ""version"": ""2.0.0-beta.29"",
+  ""version"": ""3.0.0-alpha.2"",
-    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""check:format"": ""prettier --check \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""fix:format"": ""prettier --write \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""check:lint"": ""eslint --ext .ts ./src"",
+    ""check"": ""yarn check:lint && yarn check:format"",
-    ""clean"": ""rm -rf lib/*"",
+    ""clean"": ""rm -rf lib/* deno/lib/*"",
+    ""build:deno"": ""node ./deno/build.mjs"",
+    ""build:esm"": ""tsc --p tsconfig.esm.json"",
-    ""buildallv2"": ""yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.7"",
+    ""buildallv3"": ""yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.8"",
-    ""@typescript-eslint/eslint-plugin"": ""^4.9.1"",
-    ""@typescript-eslint/parser"": ""^4.9.1"",
+    ""@typescript-eslint/eslint-plugin"": ""^4.11.1"",
+    ""@typescript-eslint/parser"": ""^4.11.1"",
+    ""dependency-cruiser"": ""^9.19.0"",
-    ""eslint-config-prettier"": ""^7.0.0"",
+    ""eslint-config-prettier"": ""^7.1.0"",
-    ""eslint-plugin-simple-import-sort"": ""^6.0.1"",
+    ""eslint-plugin-simple-import-sort"": ""^7.0.0"","
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/__tests__/error.test.ts,"+// @ts-ignore TS6133
+import { expect, test } from ""@jest/globals"";
+
-test(""don't call refine after validation failed"", () => {
-  const asdf = z
-    .union([
-      z.number(),
-      z.string().transform(z.number(), (val) => {
-        return parseFloat(val);
-      }),
-    ])
-    .refine((v) => v >= 1);
+// test(""don't call refine after validation failed"", () => {
+//   const asdf = z
+//     .union([
+//       z.number(),
+//       z.string().transform(z.number(), (val) => {
+//         return parseFloat(val);
+//       }),
+//     ])
+//     .refine((v) => v >= 1);
-  expect(() => asdf.safeParse(""foo"")).not.toThrow();
-});
+//   expect(() => asdf.safeParse(""foo"")).not.toThrow();
+// });","-import { ZodParsedType } from ""../parser"";
+import { ZodParsedType } from ""../ZodParsedType"";","+// @ts-ignore TS6133
+import { expect, test } from ""@jest/globals"";
+
-import { ZodParsedType } from ""../parser"";
+import { ZodParsedType } from ""../ZodParsedType"";
-test(""don't call refine after validation failed"", () => {
-  const asdf = z
-    .union([
-      z.number(),
-      z.string().transform(z.number(), (val) => {
-        return parseFloat(val);
-      }),
-    ])
-    .refine((v) => v >= 1);
+// test(""don't call refine after validation failed"", () => {
+//   const asdf = z
+//     .union([
+//       z.number(),
+//       z.string().transform(z.number(), (val) => {
+//         return parseFloat(val);
+//       }),
+//     ])
+//     .refine((v) => v >= 1);
-  expect(() => asdf.safeParse(""foo"")).not.toThrow();
-});
+//   expect(() => asdf.safeParse(""foo"")).not.toThrow();
+// });"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/codegen.ts,"-      case ZodTypes.transformer:
-        return this.setType(id, this.generate(def.output).id);
+
+      case ZodTypes.transformer:
+        return this.setType(id, `${this.generate(def.schema).id}`);","-import { ZodDef } from ""."";
+
-import { ZodType, ZodTypes } from ""./types/base"";
+import { ZodDef, ZodType, ZodTypes } from ""."";
+// import { ZodTypes } from ""./ZodTypes"";","-import { ZodDef } from ""."";
+
-import { ZodType, ZodTypes } from ""./types/base"";
+import { ZodDef, ZodType, ZodTypes } from ""."";
+// import { ZodTypes } from ""./ZodTypes"";
-      case ZodTypes.transformer:
-        return this.setType(id, this.generate(def.output).id);
+
+      case ZodTypes.transformer:
+        return this.setType(id, `${this.generate(def.schema).id}`);"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/helpers/objectUtil.ts,"-      checks: [...(first._def.checks || []), ...(second._def.checks || [])],
+      effects: [...(first._def.effects || []), ...(second._def.effects || [])],","-import { ZodRawShape, ZodTypes } from ""../types/base"";
-import { ZodIntersection } from ""../types/intersection"";
-import { AnyZodObject, ZodObject } from ""../types/object"";
+// import { ZodRawShape } from ""../types/base"";
+// import { ZodRawShape } from ""../types/base"";
+import { ZodRawShape, ZodIntersection } from "".."";
+
+// import { mergeObjects as mergeObjectsBase } from ""../../types/object"";
+// import { mergeShapes as mergeShapesBase } from ""./merge"";
-  export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-    Second extends AnyZodObject
-  >(
-    second: Second
-  ): ZodObject<
-    First[""_shape""] & Second[""_shape""],
-    First[""_unknownKeys""],
-    First[""_catchall""]
-    // MergeObjectParams<First['_params'], Second['_params']>,
-    // First['_input'] & Second['_input'],
-    // First['_output'] & Second['_output']
-  > => {
-    const mergedShape = mergeShapes(first._def.shape(), second._def.shape());
-    const merged: any = new ZodObject({
-      t: ZodTypes.object,
-      checks: [...(first._def.checks || []), ...(second._def.checks || [])],
-      unknownKeys: first._def.unknownKeys,
-      catchall: first._def.catchall,
-      // params: {
-      //   strict: first.params.strict && second.params.strict,
-      // },
-      shape: () => mergedShape,
-    }) as any;
-    return merged;
-  };
+  // export const mergeObjects = mergeObjectsBase;
+  // export const mergeShapes = mergeShapesBase;","-import { ZodRawShape, ZodTypes } from ""../types/base"";
-import { ZodIntersection } from ""../types/intersection"";
-import { AnyZodObject, ZodObject } from ""../types/object"";
+// import { ZodRawShape } from ""../types/base"";
+// import { ZodRawShape } from ""../types/base"";
+import { ZodRawShape, ZodIntersection } from "".."";
+
+// import { mergeObjects as mergeObjectsBase } from ""../../types/object"";
+// import { mergeShapes as mergeShapesBase } from ""./merge"";
-  export const mergeObjects = <First extends AnyZodObject>(first: First) => <
-    Second extends AnyZodObject
-  >(
-    second: Second
-  ): ZodObject<
-    First[""_shape""] & Second[""_shape""],
-    First[""_unknownKeys""],
-    First[""_catchall""]
-    // MergeObjectParams<First['_params'], Second['_params']>,
-    // First['_input'] & Second['_input'],
-    // First['_output'] & Second['_output']
-  > => {
-    const mergedShape = mergeShapes(first._def.shape(), second._def.shape());
-    const merged: any = new ZodObject({
-      t: ZodTypes.object,
-      checks: [...(first._def.checks || []), ...(second._def.checks || [])],
-      unknownKeys: first._def.unknownKeys,
-      catchall: first._def.catchall,
-      // params: {
-      //   strict: first.params.strict && second.params.strict,
-      // },
-      shape: () => mergedShape,
-    }) as any;
-    return merged;
-  };
+  // export const mergeObjects = mergeObjectsBase;
+  // export const mergeShapes = mergeShapesBase;"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/index.ts,"-export { ZodTypeDef, ZodTypes };
+export { ZodTypes };
-  ZodErrorMap,
+};
+
+export type {
+  TypeOf as infer,
+  input,
+  output,
+  TypeOf,
+  ZodErrorMap,
+  ZodTypeDef,
-
-export { TypeOf as infer, input, output, TypeOf };","-import { ZodCodeGenerator } from ""./codegen"";
-import { ZodErrorMap } from ""./defaultErrorMap"";
-// export { ZodIssueCode } from './ZodError';
-import { ZodParsedType } from ""./parser"";
-import { ZodAny, ZodAnyDef } from ""./types/any"";
-import { ZodArray, ZodArrayDef } from ""./types/array"";
+  ZodType,
+  ZodTypeDef,
+  ZodTypeAny,
+  ZodRawShape,
-  ZodType,
-  ZodTypeAny,
-  ZodTypeDef,
-  ZodTypes,
+  RefinementCtx,
-import { ZodBigInt, ZodBigIntDef } from ""./types/bigint"";
-import { ZodBoolean, ZodBooleanDef } from ""./types/boolean"";
-import { ZodDate, ZodDateDef } from ""./types/date"";
-import { ZodEnum, ZodEnumDef } from ""./types/enum"";
-import { ZodFunction, ZodFunctionDef } from ""./types/function"";
-import { ZodIntersection, ZodIntersectionDef } from ""./types/intersection"";
-import { ZodLazy, ZodLazyDef } from ""./types/lazy"";
-import { ZodLiteral, ZodLiteralDef } from ""./types/literal"";
-import { ZodMap, ZodMapDef } from ""./types/map"";
-import { ZodNativeEnum, ZodNativeEnumDef } from ""./types/nativeEnum"";
-import { ZodNever, ZodNeverDef } from ""./types/never"";
-import { ZodNull, ZodNullDef } from ""./types/null"";
-import { ZodNullable, ZodNullableDef } from ""./types/nullable"";
-import { ZodNumber, ZodNumberDef } from ""./types/number"";
-import { ZodObject, ZodObjectDef } from ""./types/object"";
-import { ZodOptional, ZodOptionalDef } from ""./types/optional"";
-import { ZodPromise, ZodPromiseDef } from ""./types/promise"";
-import { ZodRecord, ZodRecordDef } from ""./types/record"";
-import { ZodString, ZodStringDef } from ""./types/string"";
-import { ZodTransformer, ZodTransformerDef } from ""./types/transformer"";
-import { ZodTuple, ZodTupleDef } from ""./types/tuple"";
-import { ZodUndefined, ZodUndefinedDef } from ""./types/undefined"";
-import { ZodUnion, ZodUnionDef } from ""./types/union"";
-import { ZodUnknown, ZodUnknownDef } from ""./types/unknown"";
-import { ZodVoid, ZodVoidDef } from ""./types/void"";
-export { ZodTypeDef, ZodTypes };
+import { ZodErrorMap } from ""./defaultErrorMap"";
+import { ZodAny } from ""./types/any"";
+import { ZodArray } from ""./types/array"";
+import { ZodBigInt } from ""./types/bigint"";
+import { ZodBoolean } from ""./types/boolean"";
+import { ZodDate } from ""./types/date"";
+import { ZodEnum } from ""./types/enum"";
+import { ZodFunction } from ""./types/function"";
+import { ZodIntersection } from ""./types/intersection"";
+import { ZodLazy } from ""./types/lazy"";
+import { ZodLiteral } from ""./types/literal"";
+import { ZodMap } from ""./types/map"";
+import { ZodNativeEnum } from ""./types/nativeEnum"";
+import { ZodNever } from ""./types/never"";
+import { ZodNull } from ""./types/null"";
+import { ZodNullable, ZodNullableType } from ""./types/nullable"";
+import { ZodNumber } from ""./types/number"";
+import { ZodObject } from ""./types/object"";
+import { ZodOptional, ZodOptionalType } from ""./types/optional"";
+import { ZodPromise } from ""./types/promise"";
+import { ZodRecord } from ""./types/record"";
+import { ZodString } from ""./types/string"";
+import { ZodTransformer } from ""./types/transformer"";
+import { ZodTuple } from ""./types/tuple"";
+import { ZodUndefined } from ""./types/undefined"";
+import { ZodUnion } from ""./types/union"";
+import { ZodUnknown } from ""./types/unknown"";
+import { ZodVoid } from ""./types/void"";
+import { ZodParsedType } from ""./ZodParsedType"";
+import { ZodTypes } from ""./ZodTypes"";
+import { ZodCodeGenerator } from ""./codegen"";
+
+// export { ZodTypeDef, ZodRawShape, ZodTypes };
-
+  ZodType,
+  ZodType as Schema,
+  ZodType as ZodSchema,
+  ZodTypeDef,
+  ZodRawShape,
+  RefinementCtx,
+  ZodTypes,
+  // ZodType,
+  ZodAny,
+  ZodArray,
+  ZodBigInt,
+  ZodBoolean,
+  ZodCodeGenerator,
+  ZodDate,
+  ZodEnum,
+  ZodErrorMap,
+  ZodFunction,
+  ZodIntersection,
+  ZodLazy,
+  ZodLiteral,
+  ZodNativeEnum,
+  ZodNever,
+  ZodNull,
+  ZodNullable,
+  ZodNullableType,
+  ZodNumber,
+  ZodObject,
+  ZodOptional,
+  ZodOptionalType,
+  ZodParsedType,
+  ZodPromise,
+  ZodRecord,
+  ZodString,
+  ZodTransformer,
+  ZodTuple,
+  ZodTypeAny,
+  ZodUndefined,
+  ZodUnion,
+  ZodUnknown,
+  ZodVoid,
+  TypeOf as infer,
+  input,
+  output,
+  TypeOf,
-export {
-  ZodType as Schema,
-  ZodAny,
-  ZodArray,
-  ZodBigInt,
-  ZodBoolean,
-  ZodCodeGenerator,
-  ZodDate,
-  ZodEnum,
-  ZodErrorMap,
-  ZodFunction,
-  ZodIntersection,
-  ZodLazy,
-  ZodLiteral,
-  ZodNativeEnum,
-  ZodNever,
-  ZodNull,
-  ZodNullable,
-  ZodNumber,
-  ZodObject,
-  ZodOptional,
-  ZodParsedType,
-  ZodPromise,
-  ZodRecord,
-  ZodType as ZodSchema,
-  ZodString,
-  ZodTransformer,
-  ZodTuple,
-  ZodType,
-  ZodTypeAny,
-  ZodUndefined,
-  ZodUnion,
-  ZodUnknown,
-  ZodVoid,
-};
-
-export { TypeOf as infer, input, output, TypeOf };
-
+export * from ""./ZodDef"";
-
-export type ZodDef =
-  | ZodStringDef
-  | ZodNumberDef
-  | ZodBigIntDef
-  | ZodBooleanDef
-  | ZodDateDef
-  | ZodUndefinedDef
-  | ZodNullDef
-  | ZodAnyDef
-  | ZodUnknownDef
-  | ZodNeverDef
-  | ZodVoidDef
-  | ZodArrayDef
-  | ZodObjectDef
-  | ZodUnionDef
-  | ZodIntersectionDef
-  | ZodTupleDef
-  | ZodRecordDef
-  | ZodMapDef
-  | ZodFunctionDef
-  | ZodLazyDef
-  | ZodLiteralDef
-  | ZodEnumDef
-  | ZodTransformerDef
-  | ZodNativeEnumDef
-  | ZodOptionalDef
-  | ZodNullableDef
-  | ZodPromiseDef;","-import { ZodCodeGenerator } from ""./codegen"";
-import { ZodErrorMap } from ""./defaultErrorMap"";
-// export { ZodIssueCode } from './ZodError';
-import { ZodParsedType } from ""./parser"";
-import { ZodAny, ZodAnyDef } from ""./types/any"";
-import { ZodArray, ZodArrayDef } from ""./types/array"";
+  ZodType,
+  ZodTypeDef,
+  ZodTypeAny,
+  ZodRawShape,
-  ZodType,
-  ZodTypeAny,
-  ZodTypeDef,
-  ZodTypes,
+  RefinementCtx,
-import { ZodBigInt, ZodBigIntDef } from ""./types/bigint"";
-import { ZodBoolean, ZodBooleanDef } from ""./types/boolean"";
-import { ZodDate, ZodDateDef } from ""./types/date"";
-import { ZodEnum, ZodEnumDef } from ""./types/enum"";
-import { ZodFunction, ZodFunctionDef } from ""./types/function"";
-import { ZodIntersection, ZodIntersectionDef } from ""./types/intersection"";
-import { ZodLazy, ZodLazyDef } from ""./types/lazy"";
-import { ZodLiteral, ZodLiteralDef } from ""./types/literal"";
-import { ZodMap, ZodMapDef } from ""./types/map"";
-import { ZodNativeEnum, ZodNativeEnumDef } from ""./types/nativeEnum"";
-import { ZodNever, ZodNeverDef } from ""./types/never"";
-import { ZodNull, ZodNullDef } from ""./types/null"";
-import { ZodNullable, ZodNullableDef } from ""./types/nullable"";
-import { ZodNumber, ZodNumberDef } from ""./types/number"";
-import { ZodObject, ZodObjectDef } from ""./types/object"";
-import { ZodOptional, ZodOptionalDef } from ""./types/optional"";
-import { ZodPromise, ZodPromiseDef } from ""./types/promise"";
-import { ZodRecord, ZodRecordDef } from ""./types/record"";
-import { ZodString, ZodStringDef } from ""./types/string"";
-import { ZodTransformer, ZodTransformerDef } from ""./types/transformer"";
-import { ZodTuple, ZodTupleDef } from ""./types/tuple"";
-import { ZodUndefined, ZodUndefinedDef } from ""./types/undefined"";
-import { ZodUnion, ZodUnionDef } from ""./types/union"";
-import { ZodUnknown, ZodUnknownDef } from ""./types/unknown"";
-import { ZodVoid, ZodVoidDef } from ""./types/void"";
-
-export { ZodTypeDef, ZodTypes };
+
+import { ZodErrorMap } from ""./defaultErrorMap"";
+import { ZodAny } from ""./types/any"";
+import { ZodArray } from ""./types/array"";
+import { ZodBigInt } from ""./types/bigint"";
+import { ZodBoolean } from ""./types/boolean"";
+import { ZodDate } from ""./types/date"";
+import { ZodEnum } from ""./types/enum"";
+import { ZodFunction } from ""./types/function"";
+import { ZodIntersection } from ""./types/intersection"";
+import { ZodLazy } from ""./types/lazy"";
+import { ZodLiteral } from ""./types/literal"";
+import { ZodMap } from ""./types/map"";
+import { ZodNativeEnum } from ""./types/nativeEnum"";
+import { ZodNever } from ""./types/never"";
+import { ZodNull } from ""./types/null"";
+import { ZodNullable, ZodNullableType } from ""./types/nullable"";
+import { ZodNumber } from ""./types/number"";
+import { ZodObject } from ""./types/object"";
+import { ZodOptional, ZodOptionalType } from ""./types/optional"";
+import { ZodPromise } from ""./types/promise"";
+import { ZodRecord } from ""./types/record"";
+import { ZodString } from ""./types/string"";
+import { ZodTransformer } from ""./types/transformer"";
+import { ZodTuple } from ""./types/tuple"";
+import { ZodUndefined } from ""./types/undefined"";
+import { ZodUnion } from ""./types/union"";
+import { ZodUnknown } from ""./types/unknown"";
+import { ZodVoid } from ""./types/void"";
+import { ZodParsedType } from ""./ZodParsedType"";
+import { ZodTypes } from ""./ZodTypes"";
+import { ZodCodeGenerator } from ""./codegen"";
+
+// export { ZodTypeDef, ZodRawShape, ZodTypes };
-
+export type {
+  ZodTypeDef,
+  ZodRawShape,
+  RefinementCtx,
+  ZodParsedType,
+  TypeOf as infer,
+  input,
+  output,
+  TypeOf,
+  ZodErrorMap,
+  ZodNullableType,
+  ZodOptionalType,
+  ZodTypeAny,
+};
+
+  ZodType,
+  ZodType as Schema,
+  ZodType as ZodSchema,
+  // ZodTypeDef,
+  // ZodRawShape,
+  // RefinementCtx,
+  ZodTypes,
+  // ZodType,
+  ZodAny,
+  ZodArray,
+  ZodBigInt,
+  ZodBoolean,
+  ZodCodeGenerator,
+  ZodDate,
+  ZodEnum,
+  ZodFunction,
+  ZodIntersection,
+  ZodLazy,
+  ZodLiteral,
+  ZodNativeEnum,
+  ZodNever,
+  ZodNull,
+  ZodNullable,
+  ZodNumber,
+  ZodObject,
+  ZodOptional,
+  // ZodParsedType,
+  ZodPromise,
+  ZodRecord,
+  ZodString,
+  ZodTransformer,
+  ZodTuple,
+  ZodUndefined,
+  ZodUnion,
+  ZodUnknown,
+  ZodVoid,
+  // TypeOf as infer,
+  // input,
+  // output,
+  // TypeOf,
+// export type {
+//   TypeOf as infer,
+//   input,
+//   output,
+//   TypeOf,
+//   ZodErrorMap,
+//   ZodType,
+//   ZodTypeAny,
+//   ZodTypeDef,
+//   ZodUndefined,
+//   ZodUnion,
+//   ZodUnknown,
+//   ZodVoid,
+// };
+
-export {
-  ZodType as Schema,
-  ZodAny,
-  ZodArray,
-  ZodBigInt,
-  ZodBoolean,
-  ZodCodeGenerator,
-  ZodDate,
-  ZodEnum,
-  ZodErrorMap,
-  ZodFunction,
-  ZodIntersection,
-  ZodLazy,
-  ZodLiteral,
-  ZodNativeEnum,
-  ZodNever,
-  ZodNull,
-  ZodNullable,
-  ZodNumber,
-  ZodObject,
-  ZodOptional,
-  ZodParsedType,
-  ZodPromise,
-  ZodRecord,
-  ZodType as ZodSchema,
-  ZodString,
-  ZodTransformer,
-  ZodTuple,
-  ZodType,
-  ZodTypeAny,
-  ZodUndefined,
-  ZodUnion,
-  ZodUnknown,
-  ZodVoid,
-};
-
-export { TypeOf as infer, input, output, TypeOf };
-
+export * from ""./ZodDef"";
-
-export type ZodDef =
-  | ZodStringDef
-  | ZodNumberDef
-  | ZodBigIntDef
-  | ZodBooleanDef
-  | ZodDateDef
-  | ZodUndefinedDef
-  | ZodNullDef
-  | ZodAnyDef
-  | ZodUnknownDef
-  | ZodNeverDef
-  | ZodVoidDef
-  | ZodArrayDef
-  | ZodObjectDef
-  | ZodUnionDef
-  | ZodIntersectionDef
-  | ZodTupleDef
-  | ZodRecordDef
-  | ZodMapDef
-  | ZodFunctionDef
-  | ZodLazyDef
-  | ZodLiteralDef
-  | ZodEnumDef
-  | ZodTransformerDef
-  | ZodNativeEnumDef
-  | ZodOptionalDef
-  | ZodNullableDef
-  | ZodPromiseDef;"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/isScalar.ts,"+
-      returnValue = isScalar(def.output);
+      returnValue = isScalar(def.schema);
-","-import { ZodDef } from ""."";
+import { ZodDef, ZodType, ZodTypes } from ""."";
-import { ZodType, ZodTypes } from ""./types/base"";
+
+// import { ZodTypes } from ""./ZodTypes"";","-import { ZodDef } from ""."";
+import { ZodDef, ZodType, ZodTypes } from ""."";
-import { ZodType, ZodTypes } from ""./types/base"";
+
+// import { ZodTypes } from ""./ZodTypes"";
+
-      returnValue = isScalar(def.output);
+      returnValue = isScalar(def.schema);
-"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/parser.ts,"+
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.input.parse(data, params);
-        })
-
-        .then((inputParseResult) => {
-          const transformed = def.transformer(inputParseResult);
-          if (transformed instanceof Promise && params.async === false) {
-            if (z.inputSchema(def.output)._def.t !== z.ZodTypes.promise) {
-              throw new Error(
-                ""You can't call .parse on a schema containing async transformations.""
-              );
-            }
-          }
-
-          return transformed;
-        })
-
-        .then((transformedResult) => {
-          return def.output.parse(transformedResult, params);
-        });
-
+      PROMISE = new PseudoPromise().then(() => {
+        return def.schema.parse(data, params);
+      });
-  const customChecks = def.checks || [];
+  const effects = def.effects || [];
-    for (const check of customChecks) {
-      const checkResult = check.check(resolvedValue, checkCtx);
-
-      if (checkResult instanceof Promise)
-        throw new Error(
-          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead.""
-        );
+    let finalValue = resolvedValue;
+
+    for (const effect of effects) {
+      // console.log(`running effect: `);
+      // console.log(effect);
+      if (effect.type === ""check"") {
+        const checkResult = effect.check(finalValue, checkCtx);
+        // console.log(`checkresult: ${checkResult}`);
+        if (checkResult instanceof Promise)
+          throw new Error(
+            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+          );
+      } else if (effect.type === ""mod"") {
+        if (def.t !== z.ZodTypes.transformer)
+          throw new Error(""Only Modders can contain mods"");
+        finalValue = effect.mod(finalValue);
+        if (finalValue instanceof Promise) {
+          throw new Error(
+            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+          );
+        }
+      } else {
+        throw new Error(`Invalid effect type.`);
+      }
-    return resolvedValue as any;
+    return finalValue as any;
-      if (params.runAsyncValidationsInSeries) {
-        let someError = false;
-        await customChecks.reduce((previousPromise, check) => {
-          return previousPromise.then(async () => {
-            if (!someError) {
-              const len = ERROR.issues.length;
-              await check.check(resolvedValue, checkCtx);
-              if (len < ERROR.issues.length) someError = true;
-            }
-          });
-        }, Promise.resolve());
-      } else {
-        await Promise.all(
-          customChecks.map(async (check) => {
-            await check.check(resolvedValue, checkCtx);
-          })
-        );
-      }
+      let finalValue = resolvedValue;
+      for (const effect of effects) {
+        if (effect.type === ""check"") {
+          await effect.check(finalValue, checkCtx);
+        } else if (effect.type === ""mod"") {
+          if (def.t !== z.ZodTypes.transformer)
+            throw new Error(""Only Modders can contain mods"");
+          finalValue = await effect.mod(finalValue);
+        }
+      }
+
+      // if (params.runAsyncValidationsInSeries) {
+      //   let someError = false;
+      //   await customChecks.reduce((previousPromise, check) => {
+      //     return previousPromise.then(async () => {
+      //       if (!someError) {
+      //         const len = ERROR.issues.length;
+      //         await check.check(resolvedValue, checkCtx);
+      //         if (len < ERROR.issues.length) someError = true;
+      //       }
+      //     });
+      //   }, Promise.resolve());
+      // } else {
+      //   await Promise.all(
+      //     customChecks.map(async (check) => {
+      //       await check.check(resolvedValue, checkCtx);
+      //     })
+      //   );
+      // }
-      return resolvedValue;
+      return finalValue;","-import { ZodDef, ZodNever, ZodPromise } from ""./index"";
-import * as z from ""./types/base"";
-import {
-  ZodError,
-  ZodIssue,
-  ZodIssueCode,
-  ZodIssueOptionalMessage,
-} from ""./ZodError"";
+// import { inputSchema } from ""../types/base/output-schema"";
+import { ZodType, RefinementCtx } from ""."";
+// type adsf = RefinementCtx
+// import { ZodNever } from ""../types/never"";
+// import { ZodPromise } from ""../types/promise"";
+import { ZodDef } from ""./ZodDef"";
+import { ZodError, ZodIssue, ZodIssueCode, MakeErrorData } from ""./ZodError"";
+import { ZodParsedType } from ""./ZodParsedType"";
+import { ZodTypes } from ""./ZodTypes"";
-export const ZodParsedType = util.arrayToEnum([
-  ""string"",
-  ""nan"",
-  ""number"",
-  ""integer"",
-  ""boolean"",
-  ""date"",
-  ""bigint"",
-  ""symbol"",
-  ""function"",
-  ""undefined"",
-  ""null"",
-  ""array"",
-  ""object"",
-  ""unknown"",
-  ""promise"",
-  ""void"",
-  ""never"",
-  ""map"",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
-
-type stripPath<T extends object> = T extends any
-  ? util.OmitKeys<T, ""path"">
-  : never;
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
-  path?: (string | number)[];
-};
-
-    schema: z.ZodType<any>;
+    schema: ZodType<any>;
-export const ZodParser = (schema: z.ZodType<any>) => (
+export const ZodParser = (schema: ZodType<any>) => (
-    case z.ZodTypes.string:
+    case ZodTypes.string:
-    case z.ZodTypes.number:
+    case ZodTypes.number:
-    case z.ZodTypes.bigint:
+    case ZodTypes.bigint:
-    case z.ZodTypes.boolean:
+    case ZodTypes.boolean:
-    case z.ZodTypes.undefined:
+    case ZodTypes.undefined:
-    case z.ZodTypes.null:
+    case ZodTypes.null:
-    case z.ZodTypes.any:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case z.ZodTypes.unknown:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case z.ZodTypes.never:
+    case ZodTypes.any:
+      PROMISE = PseudoPromise.resolve(data);
+      break;
+    case ZodTypes.unknown:
+      PROMISE = PseudoPromise.resolve(data);
+      break;
+    case ZodTypes.never:
-    case z.ZodTypes.void:
+    case ZodTypes.void:
-    case z.ZodTypes.array:
+    case ZodTypes.array:
-    case z.ZodTypes.map:
+    case ZodTypes.map:
-    case z.ZodTypes.object:
+    case ZodTypes.object:
-          : !(def.catchall instanceof ZodNever)
+          : !(def.catchall._def.t === ZodTypes.never)
-      if (def.catchall instanceof ZodNever) {
+      if (def.catchall._def.t === ZodTypes.never) {
-    case z.ZodTypes.union:
+    case ZodTypes.union:
-    case z.ZodTypes.intersection:
+    case ZodTypes.intersection:
-    case z.ZodTypes.optional:
+    case ZodTypes.optional:
-    case z.ZodTypes.nullable:
+    case ZodTypes.nullable:
-    case z.ZodTypes.tuple:
+    case ZodTypes.tuple:
-    case z.ZodTypes.lazy:
+    case ZodTypes.lazy:
-    case z.ZodTypes.literal:
+    case ZodTypes.literal:
-    case z.ZodTypes.enum:
+    case ZodTypes.enum:
-    case z.ZodTypes.nativeEnum:
+    case ZodTypes.nativeEnum:
-    case z.ZodTypes.function:
+    case ZodTypes.function:
-      const isAsyncFunction = def.returns instanceof ZodPromise;
+      const isAsyncFunction = def.returns._def.t === ZodTypes.promise;
-    case z.ZodTypes.record:
+    case ZodTypes.record:
-    case z.ZodTypes.date:
+    case ZodTypes.date:
-    case z.ZodTypes.promise:
+    case ZodTypes.promise:
-    case z.ZodTypes.transformer:
+    case ZodTypes.transformer:
-            if (z.inputSchema(def.output)._def.t !== z.ZodTypes.promise) {
+            if (def.output._def.t !== ZodTypes.promise) {
-  const checkCtx: z.RefinementCtx = {
+  const checkCtx: RefinementCtx = {","-import { ZodDef, ZodNever, ZodPromise } from ""./index"";
-import * as z from ""./types/base"";
-import {
-  ZodError,
-  ZodIssue,
-  ZodIssueCode,
-  ZodIssueOptionalMessage,
-} from ""./ZodError"";
+// import { inputSchema } from ""../types/base/output-schema"";
+import { ZodType, RefinementCtx } from ""."";
+// type adsf = RefinementCtx
+// import { ZodNever } from ""../types/never"";
+// import { ZodPromise } from ""../types/promise"";
+import { ZodDef } from ""./ZodDef"";
+import { ZodError, ZodIssue, ZodIssueCode, MakeErrorData } from ""./ZodError"";
+import { ZodParsedType } from ""./ZodParsedType"";
+import { ZodTypes } from ""./ZodTypes"";
-export const ZodParsedType = util.arrayToEnum([
-  ""string"",
-  ""nan"",
-  ""number"",
-  ""integer"",
-  ""boolean"",
-  ""date"",
-  ""bigint"",
-  ""symbol"",
-  ""function"",
-  ""undefined"",
-  ""null"",
-  ""array"",
-  ""object"",
-  ""unknown"",
-  ""promise"",
-  ""void"",
-  ""never"",
-  ""map"",
-]);
-
-export type ZodParsedType = keyof typeof ZodParsedType;
-
-type stripPath<T extends object> = T extends any
-  ? util.OmitKeys<T, ""path"">
-  : never;
-export type MakeErrorData = stripPath<ZodIssueOptionalMessage> & {
-  path?: (string | number)[];
-};
-
-    schema: z.ZodType<any>;
+    schema: ZodType<any>;
-export const ZodParser = (schema: z.ZodType<any>) => (
+export const ZodParser = (schema: ZodType<any>) => (
-    case z.ZodTypes.string:
+    case ZodTypes.string:
-    case z.ZodTypes.number:
+    case ZodTypes.number:
-    case z.ZodTypes.bigint:
+    case ZodTypes.bigint:
-    case z.ZodTypes.boolean:
+    case ZodTypes.boolean:
-    case z.ZodTypes.undefined:
+    case ZodTypes.undefined:
-    case z.ZodTypes.null:
+    case ZodTypes.null:
-    case z.ZodTypes.any:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case z.ZodTypes.unknown:
-      PROMISE = PseudoPromise.resolve(data);
-      break;
-    case z.ZodTypes.never:
+    case ZodTypes.any:
+      PROMISE = PseudoPromise.resolve(data);
+      break;
+    case ZodTypes.unknown:
+      PROMISE = PseudoPromise.resolve(data);
+      break;
+    case ZodTypes.never:
-    case z.ZodTypes.void:
+    case ZodTypes.void:
-    case z.ZodTypes.array:
+    case ZodTypes.array:
-    case z.ZodTypes.map:
+    case ZodTypes.map:
-    case z.ZodTypes.object:
+    case ZodTypes.object:
-          : !(def.catchall instanceof ZodNever)
+          : !(def.catchall._def.t === ZodTypes.never)
-      if (def.catchall instanceof ZodNever) {
+      if (def.catchall._def.t === ZodTypes.never) {
-    case z.ZodTypes.union:
+    case ZodTypes.union:
-    case z.ZodTypes.intersection:
+    case ZodTypes.intersection:
-    case z.ZodTypes.optional:
+    case ZodTypes.optional:
-    case z.ZodTypes.nullable:
+    case ZodTypes.nullable:
-    case z.ZodTypes.tuple:
+    case ZodTypes.tuple:
-    case z.ZodTypes.lazy:
+    case ZodTypes.lazy:
-    case z.ZodTypes.literal:
+    case ZodTypes.literal:
-    case z.ZodTypes.enum:
+    case ZodTypes.enum:
-    case z.ZodTypes.nativeEnum:
+    case ZodTypes.nativeEnum:
-    case z.ZodTypes.function:
+    case ZodTypes.function:
-      const isAsyncFunction = def.returns instanceof ZodPromise;
+      const isAsyncFunction = def.returns._def.t === ZodTypes.promise;
-    case z.ZodTypes.record:
+    case ZodTypes.record:
-    case z.ZodTypes.date:
+    case ZodTypes.date:
-    case z.ZodTypes.promise:
+    case ZodTypes.promise:
-    case z.ZodTypes.transformer:
-      PROMISE = new PseudoPromise()
-        .then(() => {
-          return def.input.parse(data, params);
-        })
-
-        .then((inputParseResult) => {
-          const transformed = def.transformer(inputParseResult);
-          if (transformed instanceof Promise && params.async === false) {
-            if (z.inputSchema(def.output)._def.t !== z.ZodTypes.promise) {
-              throw new Error(
-                ""You can't call .parse on a schema containing async transformations.""
-              );
-            }
-          }
-
-          return transformed;
-        })
-
-        .then((transformedResult) => {
-          return def.output.parse(transformedResult, params);
-        });
-
+
+    case ZodTypes.transformer:
+      PROMISE = new PseudoPromise().then(() => {
+        return def.schema.parse(data, params);
+      });
-  const customChecks = def.checks || [];
-
-  const checkCtx: z.RefinementCtx = {
+  const effects = def.effects || [];
+
+  const checkCtx: RefinementCtx = {
-    for (const check of customChecks) {
-      const checkResult = check.check(resolvedValue, checkCtx);
-
-      if (checkResult instanceof Promise)
-        throw new Error(
-          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead.""
-        );
+    let finalValue = resolvedValue;
+
+    for (const effect of effects) {
+      // console.log(`running effect: `);
+      // console.log(effect);
+      if (effect.type === ""check"") {
+        const checkResult = effect.check(finalValue, checkCtx);
+        // console.log(`checkresult: ${checkResult}`);
+        if (checkResult instanceof Promise)
+          throw new Error(
+            ""You can't use .parse() on a schema containing async refinements. Use .parseAsync instead.""
+          );
+      } else if (effect.type === ""mod"") {
+        if (def.t !== ZodTypes.transformer)
+          throw new Error(""Only Modders can contain mods"");
+        finalValue = effect.mod(finalValue);
+        if (finalValue instanceof Promise) {
+          throw new Error(
+            `You can't use .parse() on a schema containing async transformations. Use .parseAsync instead.`
+          );
+        }
+      } else {
+        throw new Error(`Invalid effect type.`);
+      }
-    return resolvedValue as any;
+    return finalValue as any;
-      if (params.runAsyncValidationsInSeries) {
-        let someError = false;
-        await customChecks.reduce((previousPromise, check) => {
-          return previousPromise.then(async () => {
-            if (!someError) {
-              const len = ERROR.issues.length;
-              await check.check(resolvedValue, checkCtx);
-              if (len < ERROR.issues.length) someError = true;
-            }
-          });
-        }, Promise.resolve());
-      } else {
-        await Promise.all(
-          customChecks.map(async (check) => {
-            await check.check(resolvedValue, checkCtx);
-          })
-        );
-      }
+      let finalValue = resolvedValue;
+      for (const effect of effects) {
+        if (effect.type === ""check"") {
+          await effect.check(finalValue, checkCtx);
+        } else if (effect.type === ""mod"") {
+          if (def.t !== ZodTypes.transformer)
+            throw new Error(""Only Modders can contain mods"");
+          finalValue = await effect.mod(finalValue);
+        }
+      }
+
+      // if (params.runAsyncValidationsInSeries) {
+      //   let someError = false;
+      //   await customChecks.reduce((previousPromise, check) => {
+      //     return previousPromise.then(async () => {
+      //       if (!someError) {
+      //         const len = ERROR.issues.length;
+      //         await check.check(resolvedValue, checkCtx);
+      //         if (len < ERROR.issues.length) someError = true;
+      //       }
+      //     });
+      //   }, Promise.resolve());
+      // } else {
+      //   await Promise.all(
+      //     customChecks.map(async (check) => {
+      //       await check.check(resolvedValue, checkCtx);
+      //     })
+      //   );
+      // }
-      return resolvedValue;
+      return finalValue;"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/playground.ts,"-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
+import { ZodIssueCode } from ""."";
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);
+// const asyncNumberToString = z
+//   .transformer(z.number())
+//   .transform(async (n) => String(n));
+// console.log(
+//   z
+//     .object({
+//       id: asyncNumberToString,
+//     })
+//     .parse({ id: 5 })
+// );
+
+const run = async () => {
+  const schema = z
+    .object({
+      start: z.number(),
+      end: z.number(),
+    })
+    .refinement(
+      ({ start, end }) => start <= end,
+      (arg) => ({
+        code: ZodIssueCode.custom,
+        path: [""end""],
+        message: `End must be greater than ${arg.start}`,
+      }) // It won't work :(
+    );
+
+  console.log(
+    schema.parse({
+      start: 5,
+      end: 3,
+    })
+  );
+};
+run();","+
+interface RouteDefinition<I, O, P> {
+  path: string;
+  method?: string;
+  validate?: {
+    input?: z.ZodType<I>;
+    output?: z.ZodType<O>;
+    params?: z.ZodType<P>;
+  };
+  // resolve(ctx: P): Promise<O>;
+}
+
+const route = <T extends RouteDefinition<any, any, any>>(arg: T) => {
+  return arg;
+};
+
+const params = z.object({
+  id: z.transformer(z.string(), z.number(), (x) => Number(x)),
+});
+
+route({
+  path: ""adf"",
+  method: ""POST"",
+  validate: {
+    input: params,
+    output: params,
+    params: params,
+  },
+  // resolve:
+});","-import * as z from ""."";
-const someSchema = z
-  .object({
-    name: z.string().nonempty(""name required.""),
-    lower_bound: z.number(),
-    upper_bound: z.number(),
-  })
-  .refine((val) => val.lower_bound < val.upper_bound, {
-    message: ""Upper bound must be greater than lower bound."",
-    path: [""lower_bound"", ""upper_bound""],
-  });
-
-console.log(
-  someSchema.safeParse({ name: """", lower_bound: 100, upper_bound: 0 })
-);"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/types/base.ts,"+  // ZodTransformer,
+  // transformer = ""transformer"",
-export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.input);
-  } else {
-    return schema;
-  }
-};
-
-export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.output);
-  } else {
-    return schema;
-  }
-};
+// export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
+//   if (schema instanceof ZodTransformer) {
+//     return inputSchema(schema._def.input);
+//   } else {
+//     return schema;
+//   }
+// };
+
+// export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
+//   if (schema instanceof ZodTransformer) {
+//     return inputSchema(schema._def.output);
+//   } else {
+//     return schema;
+//   }
+// };
+  type: ""check"";
+
+type Mod<T> = {
+  type: ""mod"";
+  mod: (arg: T) => any;
+  // refinementError: (arg: T) => MakeErrorData;
+};
+
+type Effect<T> = InternalCheck<T> | Mod<T>;
-  checks?: InternalCheck<any>[];
+  effects?: Effect<any>[];
+  // mods?: Mod<any>[];
-      checks: [...(this._def.checks || []), { check: refinement }],
+      effects: [
+        ...(this._def.effects || []),
+        { type: ""check"", check: refinement },
+      ],
-  transform<
-    This extends this,
-    U extends ZodType<any>,
-    Tx extends (arg: This[""_output""]) => U[""_input""] | Promise<U[""_input""]>
-  >(input: U, transformer: Tx): ZodTransformer<This, U>;
-  transform<
-    This extends this,
-    Tx extends (
-      arg: This[""_output""]
-    ) => This[""_output""] | Promise<This[""_output""]>
-  >(transformer: Tx): ZodTransformer<This, This>;
-  transform(input: any, transformer?: any) {
-    if (transformer) {
-      return ZodTransformer.create(this as any, input, transformer) as any;
-    }
-    return ZodTransformer.create(this as any, outputSchema(this), input) as any;
-  }
-
-  default<
-    T extends Input = Input,
-    Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
-  >(def: T): ZodTransformer<Opt, this>;
-  default<
-    T extends (arg: this) => Input,
-    Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
-  >(def: T): ZodTransformer<Opt, this>;
+  // transform<
+  //   This extends this,
+  //   U extends ZodType<any>,
+  //   Tx extends (arg: This[""_output""]) => U[""_input""] | Promise<U[""_input""]>
+  // >(input: U, transformer: Tx): ZodTransformer<This, U>;
+  // transform<
+  //   This extends this,
+  //   Tx extends (
+  //     arg: This[""_output""]
+  //   ) => This[""_input""] | Promise<This[""_input""]>
+  // >(transformer: Tx): ZodTransformer<This, This>;
+  // transform(input: any, transformer?: any) {
+  //   if (transformer) {
+  //     return ZodTransformer.create(this as any, input, transformer) as any;
+  //   }
+  //   return ZodTransformer.create(this as any, outputSchema(this), input) as any;
+  // }
+
+  // default<
+  //   T extends Input = Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
+  // default<
+  //   T extends (arg: this) => Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
+  // default(def: any) {
+  //   return ZodTransformer.create(this.optional(), this, (x: any) => {
+  //     return x === undefined
+  //       ? typeof def === ""function""
+  //         ? def(this)
+  //         : def
+  //       : x;
+  //   }) as any;
+  // }
+
+  // transform<This extends this, Out, U extends ZodType<any>>(
+  //   input: U,
+  //   transformer: (arg: Output) => Out | Promise<Out>
+  // ): This extends ZodTransformer<infer T, any>
+  //   ? ZodTransformer<T, Out>
+  //   : ZodTransformer<This, Out>;
+  // transform<Out, This extends this>(
+  //   transformer: (arg: Output) => Out | Promise<Out>
+  // ): This extends ZodTransformer<infer T, any>
+  //   ? ZodTransformer<T, Out>
+  //   : ZodTransformer<This, Out>;
+  transform: <Out, This extends this>(
+    transformer: (arg: Output) => Out | Promise<Out>
+  ) => This extends ZodTransformer<infer T, any>
+    ? ZodTransformer<T, Out>
+    : ZodTransformer<This, Out> = (mod) => {
+    // if(typeof first === ""function"")
+    // const mod = typeof first === ""function"" ? first : second;
+    // const newSchema = this.transform(txFunc);
+    // if (!second) return newSchema;
+    // if (typeof mod !== ""function"")
+    //   throw new Error(""Must provide a function to the .transform() method"");
+
+    let returnType;
+    if (this instanceof ZodTransformer) {
+      returnType = new (this as any).constructor({
+        ...this._def,
+        effects: [...(this._def.effects || []), { type: ""mod"", mod }],
+      }) as any;
+    } else {
+      returnType = new ZodTransformer({
+        // ...this._def,
+        t: ZodTypes.transformer,
+        schema: this,
+        effects: [{ type: ""mod"", mod }],
+      }) as any;
+    }
+    return returnType;
+  };
+
+  //   if (!second) {
+  //     return returnType;
+  //   } else {
+  //     return returnType.refine(
+  //       (val: any) => {
+  //         return first.parse(val);
+  //       },
+  //       { message: ""Parsing error!"" }
+  //     );
+  //   }
+  // };
+
+  prependMod = <Out>(
+    mod: (arg: Output) => Out | Promise<Out>
+  ): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects: [{ type: ""mod"", mod }, ...(this._def.effects || [])],
+    }) as any;
+  };
+
+  clearEffects = <Out>(): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects: [],
+    }) as any;
+  };
+
+  setEffects = <Out>(effects: Effect<any>[]): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects,
+    }) as any;
+  };
+
+  default<T extends Input, This extends this = this>(
+    def: T
+  ): ZodTransformer<ZodOptional<This>, Input>;
+  default<T extends (arg: this) => Input, This extends this = this>(
+    def: T
+  ): ZodTransformer<ZodOptional<This>, Input>;
+  // default<
+  //   T extends (arg: this) => Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
-    return ZodTransformer.create(this.optional(), this, (x: any) => {
-      return x === undefined
-        ? typeof def === ""function""
-          ? def(this)
-          : def
-        : x;
+    return this.optional().transform((val: any) => {
+      const defaultVal = typeof def === ""function"" ? def(this) : def;
+      return typeof val !== ""undefined"" ? val : defaultVal;","+import { ZodTypes } from ""../ZodTypes"";
+import { ParseParams, ZodParser } from ""../parser"";
-  ZodArray,
-  ZodNullable,
-  ZodOptional,
-  ZodTransformer,
-} from ""../index"";
-import { MakeErrorData, ParseParams, ZodParser } from ""../parser"";
-import { ZodNullableType } from ""./nullable"";
-import { ZodOptionalType } from ""./optional"";
-
-export enum ZodTypes {
-  string = ""string"",
-  number = ""number"",
-  bigint = ""bigint"",
-  boolean = ""boolean"",
-  date = ""date"",
-  undefined = ""undefined"",
-  null = ""null"",
-  array = ""array"",
-  object = ""object"",
-  union = ""union"",
-  intersection = ""intersection"",
-  tuple = ""tuple"",
-  record = ""record"",
-  map = ""map"",
-  function = ""function"",
-  lazy = ""lazy"",
-  literal = ""literal"",
-  enum = ""enum"",
-  nativeEnum = ""nativeEnum"",
-  promise = ""promise"",
-  any = ""any"",
-  unknown = ""unknown"",
-  never = ""never"",
-  void = ""void"",
-  transformer = ""transformer"",
-  optional = ""optional"",
-  nullable = ""nullable"",
-}
-
-export type ZodTypeAny = ZodType<any, any, any>;
-export type ZodRawShape = { [k: string]: ZodTypeAny };
-
-export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.input);
-  } else {
-    return schema;
-  }
-};
-
-export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.output);
-  } else {
-    return schema;
-  }
-};
+  MakeErrorData,
+} from ""../ZodError"";
+
+export type ZodRawShape = { [k: string]: ZodTypeAny };
+
+export type TypeOf<T extends ZodType<any>> = T[""_output""];
+export type input<T extends ZodType<any>> = T[""_input""];
+export type output<T extends ZodType<any>> = T[""_output""];
+export type infer<T extends ZodType<any>> = T[""_output""];
+
+export type ZodTypeAny = ZodType<any, any, any>;
+
+import {
+  ZodArray,
+  ZodNullable,
+  ZodNullableType,
+  ZodOptional,
+  ZodOptionalType,
+  ZodTransformer,
+} from ""../index"";
+// import { outputSchema } from ""../output-schema"";
+
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   path?: (string | number)[];
-//   // message?: string;
-//   // params?: {[k:string]:any}
-// } & util.Omit<CustomError, 'code' | 'path'>;
-
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
-// type Check<T> = {
-//   check: (arg: T) => any;
-//   refinementError: (arg: T) => CustomErrorParams;
-// };
+export function declareZodType() {}
-
-export type TypeOf<T extends ZodType<any>> = T[""_output""];
-export type input<T extends ZodType<any>> = T[""_input""];
-export type output<T extends ZodType<any>> = T[""_output""];
-export type infer<T extends ZodType<any>> = T[""_output""];
+  readonly _input!: Input;
-  readonly _input!: Input;
-    return ZodTransformer.create(this as any, outputSchema(this), input) as any;
+    return ZodTransformer.create(this as any, this, input) as any;","+import { ZodTypes } from ""../ZodTypes"";
+import { ParseParams, ZodParser } from ""../parser"";
-  ZodArray,
-  ZodNullable,
-  ZodOptional,
-  ZodTransformer,
-} from ""../index"";
-import { MakeErrorData, ParseParams, ZodParser } from ""../parser"";
-import { ZodNullableType } from ""./nullable"";
-import { ZodOptionalType } from ""./optional"";
-
-export enum ZodTypes {
-  string = ""string"",
-  number = ""number"",
-  bigint = ""bigint"",
-  boolean = ""boolean"",
-  date = ""date"",
-  undefined = ""undefined"",
-  null = ""null"",
-  array = ""array"",
-  object = ""object"",
-  union = ""union"",
-  intersection = ""intersection"",
-  tuple = ""tuple"",
-  record = ""record"",
-  map = ""map"",
-  function = ""function"",
-  lazy = ""lazy"",
-  literal = ""literal"",
-  enum = ""enum"",
-  nativeEnum = ""nativeEnum"",
-  promise = ""promise"",
-  any = ""any"",
-  unknown = ""unknown"",
-  never = ""never"",
-  void = ""void"",
-  transformer = ""transformer"",
-  optional = ""optional"",
-  nullable = ""nullable"",
-}
-
-export type ZodTypeAny = ZodType<any, any, any>;
-export type ZodRawShape = { [k: string]: ZodTypeAny };
-
-export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.input);
-  } else {
-    return schema;
-  }
-};
-
-export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
-  if (schema instanceof ZodTransformer) {
-    return inputSchema(schema._def.output);
-  } else {
-    return schema;
-  }
-};
+  MakeErrorData,
+} from ""../ZodError"";
+
+export type ZodRawShape = { [k: string]: ZodTypeAny };
+
+export type TypeOf<T extends ZodType<any>> = T[""_output""];
+export type input<T extends ZodType<any>> = T[""_input""];
+export type output<T extends ZodType<any>> = T[""_output""];
+export type infer<T extends ZodType<any>> = T[""_output""];
+
+export type ZodTypeAny = ZodType<any, any, any>;
+
+import {
+  ZodArray,
+  ZodNullable,
+  ZodNullableType,
+  ZodOptional,
+  ZodOptionalType,
+  ZodTransformer,
+} from ""../index"";
+// import { outputSchema } from ""../output-schema"";
+
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+  type: ""check"";
+
+type Mod<T> = {
+  type: ""mod"";
+  mod: (arg: T) => any;
+  // refinementError: (arg: T) => MakeErrorData;
+};
+
+type Effect<T> = InternalCheck<T> | Mod<T>;
-type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+// type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, ""code"">>;
+// export function declareZodType() {}
-  checks?: InternalCheck<any>[];
+  effects?: Effect<any>[];
+  // mods?: Mod<any>[];
-
-export type TypeOf<T extends ZodType<any>> = T[""_output""];
-export type input<T extends ZodType<any>> = T[""_input""];
-export type output<T extends ZodType<any>> = T[""_output""];
-export type infer<T extends ZodType<any>> = T[""_output""];
+  readonly _input!: Input;
-  readonly _input!: Input;
-      checks: [...(this._def.checks || []), { check: refinement }],
+      effects: [
+        ...(this._def.effects || []),
+        { type: ""check"", check: refinement },
+      ],
-  transform<
-    This extends this,
-    U extends ZodType<any>,
-    Tx extends (arg: This[""_output""]) => U[""_input""] | Promise<U[""_input""]>
-  >(input: U, transformer: Tx): ZodTransformer<This, U>;
-  transform<
-    This extends this,
-    Tx extends (
-      arg: This[""_output""]
-    ) => This[""_output""] | Promise<This[""_output""]>
-  >(transformer: Tx): ZodTransformer<This, This>;
-  transform(input: any, transformer?: any) {
-    if (transformer) {
-      return ZodTransformer.create(this as any, input, transformer) as any;
-    }
-    return ZodTransformer.create(this as any, outputSchema(this), input) as any;
-  }
-
-  default<
-    T extends Input = Input,
-    Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
-  >(def: T): ZodTransformer<Opt, this>;
-  default<
-    T extends (arg: this) => Input,
-    Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
-  >(def: T): ZodTransformer<Opt, this>;
+  // transform<
+  //   This extends this,
+  //   U extends ZodType<any>,
+  //   Tx extends (arg: This[""_output""]) => U[""_input""] | Promise<U[""_input""]>
+  // >(input: U, transformer: Tx): ZodTransformer<This, U>;
+  // transform<
+  //   This extends this,
+  //   Tx extends (
+  //     arg: This[""_output""]
+  //   ) => This[""_input""] | Promise<This[""_input""]>
+  // >(transformer: Tx): ZodTransformer<This, This>;
+  // transform(input: any, transformer?: any) {
+  //   if (transformer) {
+  //     return ZodTransformer.create(this as any, input, transformer) as any;
+  //   }
+  //   return ZodTransformer.create(this as any, outputSchema(this), input) as any;
+  // }
+
+  // default<
+  //   T extends Input = Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
+  // default<
+  //   T extends (arg: this) => Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
+  // default(def: any) {
+  //   return ZodTransformer.create(this.optional(), this, (x: any) => {
+  //     return x === undefined
+  //       ? typeof def === ""function""
+  //         ? def(this)
+  //         : def
+  //       : x;
+  //   }) as any;
+  // }
+
+  // transform<This extends this, Out, U extends ZodType<any>>(
+  //   input: U,
+  //   transformer: (arg: Output) => Out | Promise<Out>
+  // ): This extends ZodTransformer<infer T, any>
+  //   ? ZodTransformer<T, Out>
+  //   : ZodTransformer<This, Out>;
+  // transform<Out, This extends this>(
+  //   transformer: (arg: Output) => Out | Promise<Out>
+  // ): This extends ZodTransformer<infer T, any>
+  //   ? ZodTransformer<T, Out>
+  //   : ZodTransformer<This, Out>;
+  transform: <Out, This extends this>(
+    transformer: (arg: Output) => Out | Promise<Out>
+  ) => This extends ZodTransformer<infer T, any>
+    ? ZodTransformer<T, Out>
+    : ZodTransformer<This, Out> = (mod) => {
+    // if(typeof first === ""function"")
+    // const mod = typeof first === ""function"" ? first : second;
+    // const newSchema = this.transform(txFunc);
+    // if (!second) return newSchema;
+    // if (typeof mod !== ""function"")
+    //   throw new Error(""Must provide a function to the .transform() method"");
+
+    let returnType;
+    if (this instanceof ZodTransformer) {
+      returnType = new (this as any).constructor({
+        ...this._def,
+        effects: [...(this._def.effects || []), { type: ""mod"", mod }],
+      }) as any;
+    } else {
+      returnType = new ZodTransformer({
+        // ...this._def,
+        t: ZodTypes.transformer,
+        schema: this,
+        effects: [{ type: ""mod"", mod }],
+      }) as any;
+    }
+    return returnType;
+  };
+
+  //   if (!second) {
+  //     return returnType;
+  //   } else {
+  //     return returnType.refine(
+  //       (val: any) => {
+  //         return first.parse(val);
+  //       },
+  //       { message: ""Parsing error!"" }
+  //     );
+  //   }
+  // };
+
+  prependMod = <Out>(
+    mod: (arg: Output) => Out | Promise<Out>
+  ): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects: [{ type: ""mod"", mod }, ...(this._def.effects || [])],
+    }) as any;
+  };
+
+  clearEffects = <Out>(): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects: [],
+    }) as any;
+  };
+
+  setEffects = <Out>(effects: Effect<any>[]): ZodType<Out, Def, Input> => {
+    return new (this as any).constructor({
+      ...this._def,
+      effects,
+    }) as any;
+  };
+
+  default<T extends Input, This extends this = this>(
+    def: T
+  ): ZodTransformer<ZodOptional<This>, Input>;
+  default<T extends (arg: this) => Input, This extends this = this>(
+    def: T
+  ): ZodTransformer<ZodOptional<This>, Input>;
+  // default<
+  //   T extends (arg: this) => Input,
+  //   Opt extends ReturnType<this[""optional""]> = ReturnType<this[""optional""]>
+  // >(def: T): ZodTransformer<Opt, this>;
-    return ZodTransformer.create(this.optional(), this, (x: any) => {
-      return x === undefined
-        ? typeof def === ""function""
-          ? def(this)
-          : def
-        : x;
+    return this.optional().transform((val: any) => {
+      const defaultVal = typeof def === ""function"" ? def(this) : def;
+      return typeof val !== ""undefined"" ? val : defaultVal;"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/types/object.ts,"-  UnknownKeys extends UnknownKeysParam = ""passthrough"",
+  UnknownKeys extends UnknownKeysParam = ""strip"",","-import { ZodNever } from "".."";
+// import { mergeShapes } from ""../helpers/objectUtil/merge"";
-import * as z from ""./base"";
+import { ZodTypes } from ""../ZodTypes"";
+import { ZodRawShape, ZodType, ZodTypeDef, ZodTypeAny } from ""./base"";
+
+import { ZodNever } from ""./never"";
+
+export const mergeObjects = <First extends AnyZodObject>(first: First) => <
+  Second extends AnyZodObject
+>(
+  second: Second
+): ZodObject<
+  First[""_shape""] & Second[""_shape""],
+  First[""_unknownKeys""],
+  First[""_catchall""]
+  // MergeObjectParams<First['_params'], Second['_params']>,
+  // First['_input'] & Second['_input'],
+  // First['_output'] & Second['_output']
+> => {
+  const mergedShape = objectUtil.mergeShapes(
+    first._def.shape(),
+    second._def.shape()
+  );
+  const merged: any = new ZodObject({
+    t: ZodTypes.object,
+    checks: [...(first._def.checks || []), ...(second._def.checks || [])],
+    unknownKeys: first._def.unknownKeys,
+    catchall: first._def.catchall,
+    // params: {
+    //   strict: first.params.strict && second.params.strict,
+    // },
+    shape: () => mergedShape,
+  }) as any;
+  return merged;
+};
-  Augmentation extends z.ZodRawShape
+  Augmentation extends ZodRawShape
-  T extends z.ZodRawShape = z.ZodRawShape,
+  T extends ZodRawShape = ZodRawShape,
-  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  Catchall extends ZodTypeAny = ZodTypeAny
-> extends z.ZodTypeDef {
-  t: z.ZodTypes.object;
+> extends ZodTypeDef {
+  t: ZodTypes.object;
-  Shape extends z.ZodRawShape
-  // Catchall extends z.ZodTypeAny
+  Shape extends ZodRawShape
+  // Catchall extends ZodTypeAny
-  Shape extends z.ZodRawShape,
-  Catchall extends z.ZodTypeAny
-> = z.ZodTypeAny extends Catchall
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
-export type baseObjectInputType<
-  Shape extends z.ZodRawShape
-> = objectUtil.flatten<
+export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  Shape extends z.ZodRawShape,
-  Catchall extends z.ZodTypeAny
-> = z.ZodTypeAny extends Catchall
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
-// type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+// type makeRequired<T extends ZodType<any>> = T extends ZodUnion<infer U>
-//   T extends z.ZodRawShape,
+//   T extends ZodRawShape,
-export type AnyZodObject = ZodObject<any, any, any>;
-// export type AnyZodObject = ZodObject<
-// z.ZodRawShape,
-// UnknownKeysParam,
-// z.ZodTypeAny
-// >;
-  T extends z.ZodRawShape,
+  T extends ZodRawShape,
-  Catchall extends z.ZodTypeAny = z.ZodTypeAny,
+  Catchall extends ZodTypeAny = ZodTypeAny,
-> extends z.ZodType<
+> extends ZodType<
-  setKey = <Key extends string, Schema extends z.ZodTypeAny>(
+  setKey = <Key extends string, Schema extends ZodTypeAny>(
-  > = objectUtil.mergeObjects(this as any) as any;
-
-  catchall = <Index extends z.ZodTypeAny>(
+  > = mergeObjects(this as any) as any;
+
+  catchall = <Index extends ZodTypeAny>(
-  static create = <T extends z.ZodRawShape>(shape: T): ZodObject<T> => {
-    return new ZodObject({
-      t: z.ZodTypes.object,
+  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+    return new ZodObject({
+      t: ZodTypes.object,
-  static lazycreate = <T extends z.ZodRawShape>(
-    shape: () => T
-  ): ZodObject<T> => {
-    return new ZodObject({
-      t: z.ZodTypes.object,
+  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+    return new ZodObject({
+      t: ZodTypes.object,
+
+export type AnyZodObject = ZodObject<any, any, any>;","-import { ZodNever } from "".."";
+// import { mergeShapes } from ""../helpers/objectUtil/merge"";
-import * as z from ""./base"";
+import { ZodTypes } from ""../ZodTypes"";
+import { ZodRawShape, ZodType, ZodTypeDef, ZodTypeAny } from ""./base"";
+
+import { ZodNever } from ""./never"";
+
+export const mergeObjects = <First extends AnyZodObject>(first: First) => <
+  Second extends AnyZodObject
+>(
+  second: Second
+): ZodObject<
+  First[""_shape""] & Second[""_shape""],
+  First[""_unknownKeys""],
+  First[""_catchall""]
+  // MergeObjectParams<First['_params'], Second['_params']>,
+  // First['_input'] & Second['_input'],
+  // First['_output'] & Second['_output']
+> => {
+  const mergedShape = objectUtil.mergeShapes(
+    first._def.shape(),
+    second._def.shape()
+  );
+  const merged: any = new ZodObject({
+    t: ZodTypes.object,
+    effects: [...(first._def.effects || []), ...(second._def.effects || [])],
+    unknownKeys: first._def.unknownKeys,
+    catchall: first._def.catchall,
+    // params: {
+    //   strict: first.params.strict && second.params.strict,
+    // },
+    shape: () => mergedShape,
+  }) as any;
+  return merged;
+};
-  Augmentation extends z.ZodRawShape
+  Augmentation extends ZodRawShape
-  T extends z.ZodRawShape = z.ZodRawShape,
+  T extends ZodRawShape = ZodRawShape,
-  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  Catchall extends ZodTypeAny = ZodTypeAny
-> extends z.ZodTypeDef {
-  t: z.ZodTypes.object;
+> extends ZodTypeDef {
+  t: ZodTypes.object;
-  Shape extends z.ZodRawShape
-  // Catchall extends z.ZodTypeAny
+  Shape extends ZodRawShape
+  // Catchall extends ZodTypeAny
-  Shape extends z.ZodRawShape,
-  Catchall extends z.ZodTypeAny
-> = z.ZodTypeAny extends Catchall
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
-export type baseObjectInputType<
-  Shape extends z.ZodRawShape
-> = objectUtil.flatten<
+export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
-  Shape extends z.ZodRawShape,
-  Catchall extends z.ZodTypeAny
-> = z.ZodTypeAny extends Catchall
+  Shape extends ZodRawShape,
+  Catchall extends ZodTypeAny
+> = ZodTypeAny extends Catchall
-// type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+// type makeRequired<T extends ZodType<any>> = T extends ZodUnion<infer U>
-//   T extends z.ZodRawShape,
+//   T extends ZodRawShape,
-export type AnyZodObject = ZodObject<any, any, any>;
-// export type AnyZodObject = ZodObject<
-// z.ZodRawShape,
-// UnknownKeysParam,
-// z.ZodTypeAny
-// >;
-  T extends z.ZodRawShape,
-  UnknownKeys extends UnknownKeysParam = ""passthrough"",
-  Catchall extends z.ZodTypeAny = z.ZodTypeAny,
+  T extends ZodRawShape,
+  UnknownKeys extends UnknownKeysParam = ""strip"",
+  Catchall extends ZodTypeAny = ZodTypeAny,
-> extends z.ZodType<
+> extends ZodType<
-  setKey = <Key extends string, Schema extends z.ZodTypeAny>(
+  setKey = <Key extends string, Schema extends ZodTypeAny>(
-  > = objectUtil.mergeObjects(this as any) as any;
-
-  catchall = <Index extends z.ZodTypeAny>(
+  > = mergeObjects(this as any) as any;
+
+  catchall = <Index extends ZodTypeAny>(
-  static create = <T extends z.ZodRawShape>(shape: T): ZodObject<T> => {
-    return new ZodObject({
-      t: z.ZodTypes.object,
+  static create = <T extends ZodRawShape>(shape: T): ZodObject<T> => {
+    return new ZodObject({
+      t: ZodTypes.object,
-  static lazycreate = <T extends z.ZodRawShape>(
-    shape: () => T
-  ): ZodObject<T> => {
-    return new ZodObject({
-      t: z.ZodTypes.object,
+  static lazycreate = <T extends ZodRawShape>(shape: () => T): ZodObject<T> => {
+    return new ZodObject({
+      t: ZodTypes.object,
+
+export type AnyZodObject = ZodObject<any, any, any>;"
colinhacks_zod,f4c8d3f7bccc751cb2540dfb15be014e33c108c7,Merged o-alexandrov changes with jeremy banks,src/types/transformer.ts,"-export interface ZodTransformerDef<
-  T extends z.ZodTypeAny = z.ZodTypeAny,
-  U extends z.ZodTypeAny = z.ZodTypeAny
-> extends z.ZodTypeDef {
+export interface ZodTransformerDef<T extends z.ZodTypeAny = z.ZodTypeAny>
+  extends z.ZodTypeDef {
-  input: T;
-  output: U;
-  transformer: (arg: T[""_output""]) => U[""_input""];
+  schema: T;
+  // transforms: (arg: T[""_output""]) => U[""_input""];
-  U extends z.ZodTypeAny
-> extends z.ZodType<U[""_output""], ZodTransformerDef<T, U>, T[""_input""]> {
-  // readonly _input!: T['_input'];
-  // readonly _output!: U['_output'];
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  // inputSchema():T{
-  //   return this._def.input;
-  // }
-
-  // get output() {
-  //   return this._def.output;
-  // }
-  // set inputSchema(val) {
-  //   val;
-  // }
-  // get inputSchema() {
-  //   return this._def.output;
-  // }
-  // set outputSchema(val) {
-  //   val;
-  // }
-  // get outputSchema() {
-  //   return this._def.output;
-  // }
-
+  Output = T[""_type""]
+> extends z.ZodType<Output, ZodTransformerDef<T>, T[""_input""]> {
-    left: this._def.input.toJSON(),
-    right: this._def.output.toJSON(),
+    schema: this._def.schema.toJSON(),
-  // transformTo: <Out extends z.ZodTypeAny>(
-  //   output: Out,
-  //   transformer: (arg: U['_type']) => Out['_type'],
-  // ) => ZodTransformer<this, Out> = (output, transformer) => {
-  //   return ZodTransformer.create(this as any, output, transformer) as any;
-  // };
+  /** You can't use the .default method on transformers! */
+  default = ((..._args: any[]) => this) as never;
-  get output() {
-    return this._def.output;
-  }
+  // static create = <I extends z.ZodTypeAny, O extends z.ZodTypeAny, Out>(
+  static create = <I extends z.ZodTypeAny>(
+    schema: I
+    // outputSchema?: O,
+    // tx?: (arg: I[""_output""]) => Out | Promise<Out>
+  ): ZodTransformer<I, I[""_output""]> => {
+    // if (schema instanceof ZodTransformer) {
+    //   throw new Error(""Can't nest transformers inside each other."");
+    // }
+    const newTx = new ZodTransformer({
+      t: z.ZodTypes.transformer,
+      schema,
+    });
-  static create = <I extends z.ZodTypeAny, O extends z.ZodTypeAny>(
-    input: I,
-    output: O,
-    transformer: (arg: I[""_output""]) => O[""_input""] | Promise<O[""_input""]>
-  ): ZodTransformer<I, O> => {
-    return new ZodTransformer({
-      t: z.ZodTypes.transformer,
-      input,
-      output,
-      transformer,
-    });
+    // if (outputSchema && tx) {
+    //   console.warn(
+    //     `Calling z.transform() with three arguments is deprecated and not recommended.`
+    //   );
+    //   newTx = newTx.transform(tx).transform((val) => outputSchema.parse);
+    // }
+    return newTx;
-  static fromSchema = <I extends z.ZodTypeAny>(
-    input: I
-  ): ZodTransformer<I, I> => {
-    return new ZodTransformer({
-      t: z.ZodTypes.transformer,
-      input,
-      output: input,
-      transformer: (x) => x,
-    });
-  };
+  // mod: <NewOut>(
+  //   arg: (curr: Output) => NewOut | Promise<NewOut>
+  // ) => ZodTransformer<T, NewOut> = (arg) => {
+  //   return this.mod(arg);
+  // };","-import * as z from ""./base"";
+import { ZodTypes } from ""../ZodTypes"";
+import { ZodType, ZodTypeDef, ZodTypeAny } from ""./base"";
+
-  T extends z.ZodTypeAny = z.ZodTypeAny,
-  U extends z.ZodTypeAny = z.ZodTypeAny
-> extends z.ZodTypeDef {
-  t: z.ZodTypes.transformer;
+  T extends ZodTypeAny = ZodTypeAny,
+  U extends ZodTypeAny = ZodTypeAny
+> extends ZodTypeDef {
+  t: ZodTypes.transformer;
-  T extends z.ZodTypeAny,
-  U extends z.ZodTypeAny
-> extends z.ZodType<U[""_output""], ZodTransformerDef<T, U>, T[""_input""]> {
+  T extends ZodTypeAny,
+  U extends ZodTypeAny
+> extends ZodType<U[""_output""], ZodTransformerDef<T, U>, T[""_input""]> {
-  // transformTo: <Out extends z.ZodTypeAny>(
+  // transformTo: <Out extends ZodTypeAny>(
-  static create = <I extends z.ZodTypeAny, O extends z.ZodTypeAny>(
+  static create = <I extends ZodTypeAny, O extends ZodTypeAny>(
-      t: z.ZodTypes.transformer,
+      t: ZodTypes.transformer,
-  static fromSchema = <I extends z.ZodTypeAny>(
+  static fromSchema = <I extends ZodTypeAny>(
-      t: z.ZodTypes.transformer,
+      t: ZodTypes.transformer,","-import * as z from ""./base"";
+import { ZodTypes } from ""../ZodTypes"";
+import { ZodType, ZodTypeDef, ZodTypeAny } from ""./base"";
+
-export interface ZodTransformerDef<
-  T extends z.ZodTypeAny = z.ZodTypeAny,
-  U extends z.ZodTypeAny = z.ZodTypeAny
-> extends z.ZodTypeDef {
-  t: z.ZodTypes.transformer;
-  input: T;
-  output: U;
-  transformer: (arg: T[""_output""]) => U[""_input""];
+export interface ZodTransformerDef<T extends ZodTypeAny = ZodTypeAny>
+  extends ZodTypeDef {
+  t: ZodTypes.transformer;
+  schema: T;
+  // transforms: (arg: T[""_output""]) => U[""_input""];
-  T extends z.ZodTypeAny,
-  U extends z.ZodTypeAny
-> extends z.ZodType<U[""_output""], ZodTransformerDef<T, U>, T[""_input""]> {
-  // readonly _input!: T['_input'];
-  // readonly _output!: U['_output'];
-  // opt optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  // null nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
-  // inputSchema():T{
-  //   return this._def.input;
-  // }
-
-  // get output() {
-  //   return this._def.output;
-  // }
-  // set inputSchema(val) {
-  //   val;
-  // }
-  // get inputSchema() {
-  //   return this._def.output;
-  // }
-  // set outputSchema(val) {
-  //   val;
-  // }
-  // get outputSchema() {
-  //   return this._def.output;
-  // }
-
+  T extends ZodTypeAny,
+  Output = T[""_type""]
+> extends ZodType<Output, ZodTransformerDef<T>, T[""_input""]> {
-    left: this._def.input.toJSON(),
-    right: this._def.output.toJSON(),
+    schema: this._def.schema.toJSON(),
-  // transformTo: <Out extends z.ZodTypeAny>(
-  //   output: Out,
-  //   transformer: (arg: U['_type']) => Out['_type'],
-  // ) => ZodTransformer<this, Out> = (output, transformer) => {
-  //   return ZodTransformer.create(this as any, output, transformer) as any;
-  // };
+  /** You can't use the .default method on transformers! */
+  default = ((..._args: any[]) => this) as never;
-  get output() {
-    return this._def.output;
-  }
+  // static create = <I extends ZodTypeAny, O extends ZodTypeAny, Out>(
+  static create = <I extends ZodTypeAny>(
+    schema: I
+    // outputSchema?: O,
+    // tx?: (arg: I[""_output""]) => Out | Promise<Out>
+  ): ZodTransformer<I, I[""_output""]> => {
+    // if (schema instanceof ZodTransformer) {
+    //   throw new Error(""Can't nest transformers inside each other."");
+    // }
+    const newTx = new ZodTransformer({
+      t: ZodTypes.transformer,
+      schema,
+    });
-  static create = <I extends z.ZodTypeAny, O extends z.ZodTypeAny>(
-    input: I,
-    output: O,
-    transformer: (arg: I[""_output""]) => O[""_input""] | Promise<O[""_input""]>
-  ): ZodTransformer<I, O> => {
-    return new ZodTransformer({
-      t: z.ZodTypes.transformer,
-      input,
-      output,
-      transformer,
-    });
+    // if (outputSchema && tx) {
+    //   console.warn(
+    //     `Calling transform() with three arguments is deprecated and not recommended.`
+    //   );
+    //   newTx = newTx.transform(tx).transform((val) => outputSchema.parse);
+    // }
+    return newTx;
-  static fromSchema = <I extends z.ZodTypeAny>(
-    input: I
-  ): ZodTransformer<I, I> => {
-    return new ZodTransformer({
-      t: z.ZodTypes.transformer,
-      input,
-      output: input,
-      transformer: (x) => x,
-    });
-  };
+  // mod: <NewOut>(
+  //   arg: (curr: Output) => NewOut | Promise<NewOut>
+  // ) => ZodTransformer<T, NewOut> = (arg) => {
+  //   return this.mod(arg);
+  // };"
colinhacks_zod,95d61bbb68db2a4916b1b5106108aa68287bd34c,Merged isolatedModules,package.json,"-  ""version"": ""3.0.0-alpha.1"",
+  ""version"": ""3.0.0-alpha.2"",
+    ""build:esm"": ""tsc --p tsconfig.esm.json"",
-    ""typescript"": ""3.8""
+    ""typescript"": ""3.7""
-  }
+  },
+  ""dependencies"": {}","-    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""check:format"": ""prettier --check \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""fix:format"": ""prettier --write \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""check:lint"": ""eslint --ext .ts ./src"",
+    ""check"": ""yarn check:lint && yarn check:format"",
-    ""clean"": ""rm -rf lib/*"",
+    ""clean"": ""rm -rf lib/* deno/lib/*"",
+    ""build:deno"": ""node ./deno/build.mjs"",
-    ""buildallv2"": ""yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.7"",
+    ""buildallv3"": ""yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.8"",","-  ""version"": ""3.0.0-alpha.1"",
+  ""version"": ""3.0.0-alpha.2"",
-    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""check:format"": ""prettier --check \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""fix:format"": ""prettier --write \""src/**/*.ts\"" \""deno/lib/**/*.ts\"""",
+    ""check:lint"": ""eslint --ext .ts ./src"",
+    ""check"": ""yarn check:lint && yarn check:format"",
-    ""clean"": ""rm -rf lib/*"",
+    ""clean"": ""rm -rf lib/* deno/lib/*"",
+    ""build:deno"": ""node ./deno/build.mjs"",
+    ""build:esm"": ""tsc --p tsconfig.esm.json"",
-    ""buildallv2"": ""yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.7"",
+    ""buildallv3"": ""yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4.0 && yarn build && yarn add typescript@4.1 && yarn build && yarn add typescript@3.8"",
-    ""@typescript-eslint/eslint-plugin"": ""^4.9.1"",
-    ""@typescript-eslint/parser"": ""^4.9.1"",
+    ""@typescript-eslint/eslint-plugin"": ""^4.11.1"",
+    ""@typescript-eslint/parser"": ""^4.11.1"",
-    ""eslint-config-prettier"": ""^7.0.0"",
+    ""eslint-config-prettier"": ""^7.1.0"",
-    ""eslint-plugin-simple-import-sort"": ""^6.0.1"",
+    ""eslint-plugin-simple-import-sort"": ""^7.0.0"","
colinhacks_zod,95d61bbb68db2a4916b1b5106108aa68287bd34c,Merged isolatedModules,tsconfig.base.json,"-    ""lib"": [""es5"", ""es6"", ""es7"", ""esnext"", ""dom""],
+    ""lib"": [
+      ""es5"",
+      ""es6"",
+      ""es7"",
+      ""esnext"",
+      ""dom""
+    ],
-    ""downlevelIteration"": true
+    ""downlevelIteration"": true,
-  ""include"": [""./src/**/*"", ""./.eslintrc.js""]
+  ""include"": [
+    ""./src/**/*"",
+    ""./.eslintrc.js""
+  ]","-    ""downlevelIteration"": true
+    ""downlevelIteration"": true,
+    ""isolatedModules"": true","-    ""lib"": [""es5"", ""es6"", ""es7"", ""esnext"", ""dom""],
+    ""lib"": [
+      ""es5"",
+      ""es6"",
+      ""es7"",
+      ""esnext"",
+      ""dom""
+    ],
-    ""downlevelIteration"": true
+    ""downlevelIteration"": true,
+    ""isolatedModules"": true
-  ""include"": [""./src/**/*"", ""./.eslintrc.js""]
+  ""include"": [
+    ""./src/**/*"",
+    ""./.eslintrc.js""
+  ]"
colinhacks_zod,e2a64bb45469ecac9302e280347ba187e13cbe44,Merge pull request #261 from colinhacks/docs-backing  Added support backing information,package.json,"+    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""fix:lint"": ""eslint --fix --ext .ts ./src"",
+    ""fix"": ""yarn fix:lint && yarn fix:format"",
-    ""format"": ""prettier --write \""src/**/*.ts\"""",
+    ""@types/node"": ""^14.14.10"",
+    ""@typescript-eslint/eslint-plugin"": ""^4.9.1"",
+    ""@typescript-eslint/parser"": ""^4.9.1"",
+    ""eslint"": ""^7.15.0"",
+    ""eslint-config-prettier"": ""^7.0.0"",
+    ""eslint-plugin-import"": ""^2.22.1"",
+    ""eslint-plugin-simple-import-sort"": ""^6.0.1"",
-      ""prettier --write""
+      ""yarn fix:lint"",
+      ""yarn fix:format""","+  ""support"": {
+    ""backing"": {
+      ""npm-funding"": true
+    }
+  },","+  ""support"": {
+    ""backing"": {
+      ""npm-funding"": true
+    }
+  },
+    ""fix:format"": ""prettier --write \""src/**/*.ts\"""",
+    ""fix:lint"": ""eslint --fix --ext .ts ./src"",
+    ""fix"": ""yarn fix:lint && yarn fix:format"",
-    ""format"": ""prettier --write \""src/**/*.ts\"""",
+    ""@types/node"": ""^14.14.10"",
+    ""@typescript-eslint/eslint-plugin"": ""^4.9.1"",
+    ""@typescript-eslint/parser"": ""^4.9.1"",
+    ""eslint"": ""^7.15.0"",
+    ""eslint-config-prettier"": ""^7.0.0"",
+    ""eslint-plugin-import"": ""^2.22.1"",
+    ""eslint-plugin-simple-import-sort"": ""^6.0.1"",
-      ""prettier --write""
+      ""yarn fix:lint"",
+      ""yarn fix:format"""
colinhacks_zod,11fcf93ff3a95753d8947dab1a353b1749eac481,Merge branch 'chore/code-formatting-enhancements' of git://github.com/jameschensmith/zod into jameschensmith-chore/code-formatting-enhancements,package.json,"-  ""version"": ""2.0.0-beta.28"",
+  ""version"": ""2.0.0-beta.29"",
-    ""build"": ""yarn run clean && tsc --p tsconfig.json"",
+    ""build"": ""yarn run clean && tsc --p tsconfig.cjs.json"",
-    ""badge"": ""make-coverage-badge --report-path ./src/coverage/coverage-summary.json --output-path ./coverage.svg"",
+    ""badge"": ""make-coverage-badge --output-path ./coverage.svg"",
-    ""@types/jest"": ""^26.0.16"",
+    ""@types/jest"": ""^26.0.17"",
-    ""typescript"": ""4.0""
+    ""typescript"": ""3.8""","-    ""format"": ""prettier --write \""src/**/*.ts\"" \""src/**/*.js\"""",
+    ""format"": ""prettier --write \""src/**/*.ts\"""",
-    ""prettier"": ""^1.19.1"",
+    ""prettier"": ""^2.2.1"",","-  ""version"": ""2.0.0-beta.28"",
+  ""version"": ""2.0.0-beta.29"",
-    ""build"": ""yarn run clean && tsc --p tsconfig.json"",
+    ""build"": ""yarn run clean && tsc --p tsconfig.cjs.json"",
-    ""format"": ""prettier --write \""src/**/*.ts\"" \""src/**/*.js\"""",
+    ""format"": ""prettier --write \""src/**/*.ts\"""",
-    ""badge"": ""make-coverage-badge --report-path ./src/coverage/coverage-summary.json --output-path ./coverage.svg"",
+    ""badge"": ""make-coverage-badge --output-path ./coverage.svg"",
-    ""@types/jest"": ""^26.0.16"",
+    ""@types/jest"": ""^26.0.17"",
-    ""prettier"": ""^1.19.1"",
+    ""prettier"": ""^2.2.1"",
-    ""typescript"": ""4.0""
+    ""typescript"": ""3.8"""
colinhacks_zod,4cade2b16a83cbac85ed4abee6adf552779be6a4,Merge pull request #254 from jameschensmith/build/reduce-package-size  Reduce package size,package.json,"-  ""dependencies"": {},
+  ""funding"": ""https://github.com/sponsors/colinhacks"",
+    ""husky"": ""^4.3.4"",
+    ""lint-staged"": ""^10.5.3"",
+  },
+  ""husky"": {
+    ""hooks"": {
+      ""pre-commit"": ""lint-staged""
+    }
+  },
+  ""lint-staged"": {
+    ""*.ts"": [
+      ""prettier --write""
+    ]","-    ""lib""
+    ""/lib""","-    ""lib""
+    ""/lib""
-  ""dependencies"": {},
+  ""funding"": ""https://github.com/sponsors/colinhacks"",
+    ""husky"": ""^4.3.4"",
+    ""lint-staged"": ""^10.5.3"",
+  },
+  ""husky"": {
+    ""hooks"": {
+      ""pre-commit"": ""lint-staged""
+    }
+  },
+  ""lint-staged"": {
+    ""*.ts"": [
+      ""prettier --write""
+    ]"
colinhacks_zod,4de5a132ffeec88d87b7ac0a3ca44589e3d3429f,Merge pull request #253 from jameschensmith/build/deps/add-husky-and-lint-staged  Add husky & lint-staged,package.json,"-  ""dependencies"": {},
+  ""funding"": ""https://github.com/sponsors/colinhacks"",","+    ""husky"": ""^4.3.4"",
+    ""lint-staged"": ""^10.5.3"",
+  },
+  ""husky"": {
+    ""hooks"": {
+      ""pre-commit"": ""lint-staged""
+    }
+  },
+  ""lint-staged"": {
+    ""*.ts"": [
+      ""prettier --write""
+    ]","-  ""dependencies"": {},
+  ""funding"": ""https://github.com/sponsors/colinhacks"",
+    ""husky"": ""^4.3.4"",
+    ""lint-staged"": ""^10.5.3"",
+  },
+  ""husky"": {
+    ""hooks"": {
+      ""pre-commit"": ""lint-staged""
+    }
+  },
+  ""lint-staged"": {
+    ""*.ts"": [
+      ""prettier --write""
+    ]"
colinhacks_zod,ed9ca448a15c6b6925434cd8f2a0144e970a21ca,moved makeerror out of parser,src/parser.ts,"-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.bigint, received: parsedType }),","-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; error?: any; times: number }[];
+  }[];
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const makeError = (
+  params: Required<ParseParams>,
+  obj: any,
+  errorData: MakeErrorData,
+): ZodSuberror => {
+  const errorArg = {
+    ...errorData,
+    path: [...params.path, ...(errorData.path || [])],
+  };
+  const ctxArg = { data: obj };
+
+  const defaultError =
+    defaultErrorMap === params.errorMap
+      ? { message: `Invalid value.` }
+      : defaultErrorMap(errorArg, {
+          ...ctxArg,
+          defaultError: `Invalid value.`,
+        });
+  return {
+    ...errorData,
+    path: [...params.path, ...(errorData.path || [])],
+    message:
+      errorData.message ||
+      params.errorMap(errorArg, {
+        ...ctxArg,
+        defaultError: defaultError.message,
+      }).message,
+  };
+};
-  const makeError = (errorData: MakeErrorData): ZodSuberror => {
-    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-    const ctxArg = { data: obj };
-
-    const defaultError =
-      defaultErrorMap === params.errorMap
-        ? { message: `Invalid value.` }
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
-    return {
-      ...errorData,
-      path: [...params.path, ...(errorData.path || [])],
-      message:
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
-    };
-  };
-
-      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+      params.seen.push({
+        schema: schemaDef,
+        objects: [{ data: obj, error: undefined, times: 1 }],
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.nonempty_array_is_empty,
+          }),
+        );
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
+          const parsedItem = def.type.parse(item, {
+            ...params,
+            path: [...params.path, i],
+          });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+          error.addError(
+            makeError(params, obj, {
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          def
+            .shape()
+            [key].parse(obj[key], { ...params, path: [...params.path, key] });
-            makeError({
+            makeError(params, obj, {
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
+          makeError(params, obj, {
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
+          makeError(params, obj, {
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+          parsedTuple.push(
+            itemParser.parse(item, {
+              ...params,
+              path: [...params.path, index],
+            }),
+          );
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-              makeError({
+              makeError(params, obj, {
-              makeError({
+              makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+          def.valueType.parse(obj[key], {
+            ...params,
+            path: [...params.path, key],
+          });
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-      error.addError(makeError(noMethodCheck));
+      error.addError(makeError(params, obj, noMethodCheck));","-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; error?: any; times: number }[];
+  }[];
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const makeError = (
+  params: Required<ParseParams>,
+  obj: any,
+  errorData: MakeErrorData,
+): ZodSuberror => {
+  const errorArg = {
+    ...errorData,
+    path: [...params.path, ...(errorData.path || [])],
+  };
+  const ctxArg = { data: obj };
+
+  const defaultError =
+    defaultErrorMap === params.errorMap
+      ? { message: `Invalid value.` }
+      : defaultErrorMap(errorArg, {
+          ...ctxArg,
+          defaultError: `Invalid value.`,
+        });
+  return {
+    ...errorData,
+    path: [...params.path, ...(errorData.path || [])],
+    message:
+      errorData.message ||
+      params.errorMap(errorArg, {
+        ...ctxArg,
+        defaultError: defaultError.message,
+      }).message,
+  };
+};
-  const makeError = (errorData: MakeErrorData): ZodSuberror => {
-    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-    const ctxArg = { data: obj };
-
-    const defaultError =
-      defaultErrorMap === params.errorMap
-        ? { message: `Invalid value.` }
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
-    return {
-      ...errorData,
-      path: [...params.path, ...(errorData.path || [])],
-      message:
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
-    };
-  };
-
-      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+      params.seen.push({
+        schema: schemaDef,
+        objects: [{ data: obj, error: undefined, times: 1 }],
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.nonempty_array_is_empty,
+          }),
+        );
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
+          const parsedItem = def.type.parse(item, {
+            ...params,
+            path: [...params.path, i],
+          });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+          error.addError(
+            makeError(params, obj, {
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          def
+            .shape()
+            [key].parse(obj[key], { ...params, path: [...params.path, key] });
-            makeError({
+            makeError(params, obj, {
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
+          makeError(params, obj, {
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
+          makeError(params, obj, {
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+          parsedTuple.push(
+            itemParser.parse(item, {
+              ...params,
+              path: [...params.path, index],
+            }),
+          );
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
+        error.addError(
+          makeError(params, obj, {
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-              makeError({
+              makeError(params, obj, {
-              makeError({
+              makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+          def.valueType.parse(obj[key], {
+            ...params,
+            path: [...params.path, key],
+          });
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-          makeError({
+          makeError(params, obj, {
-      error.addError(makeError(noMethodCheck));
+      error.addError(makeError(params, obj, noMethodCheck));"
colinhacks_zod,b71f177059aec31eb2ba1a8307710d5fa22faa9e,Merge branch '175-esm-modules' of git://github.com/cbenz/zod into cbenz-175-esm-modules,package.json,"-  ""version"": ""2.0.0-beta.15"",
+  ""version"": ""2.0.0-beta.17"",","-  ""main"": ""./lib/src/index.js"",
-  ""types"": ""./lib/src/index.d.ts"",
+  ""main"": ""./lib/cjs/src/index.js"",
+  ""module"": ""./lib/esm/src/index.js"",
+  ""types"": ""./lib/esm/src/index.d.ts"",
-    ""build"": ""yarn run clean && tsc --p tsconfig.package.json"",
+    ""build"": ""yarn run clean && tsc --p tsconfig.package.json && tsc --p tsconfig.commonjs.json"",","-  ""version"": ""2.0.0-beta.15"",
+  ""version"": ""2.0.0-beta.17"",
-  ""main"": ""./lib/src/index.js"",
-  ""types"": ""./lib/src/index.d.ts"",
+  ""main"": ""./lib/cjs/src/index.js"",
+  ""module"": ""./lib/esm/src/index.js"",
+  ""types"": ""./lib/esm/src/index.d.ts"",
-    ""build"": ""yarn run clean && tsc --p tsconfig.package.json"",
+    ""build"": ""yarn run clean && tsc --p tsconfig.package.json && tsc --p tsconfig.commonjs.json"","
colinhacks_zod,1ccfcdfe2beaf4b65db9318b870568b116d79a1a,Merge branch 'support-map' of git://github.com/lo1tuma/zod into lo1tuma-support-map,src/parser.ts,"+  runAsyncValidationsInSeries?: boolean;
-    async: baseParams.async || false,
+    async: baseParams.async ?? false,
+    runAsyncValidationsInSeries:
+      baseParams.runAsyncValidationsInSeries ?? false,
-      }
-
-      PROMISE = PseudoPromise.object(objectPromises).then(resolvedObject => {
-        Object.assign(RESULT.output, resolvedObject);
-        return RESULT.output;
-      });
+      } else {
+        // run cathcall validation
+        for (const key of extraKeys) {
+          objectPromises[key] = new PseudoPromise().then(() => {
+            try {
+              const parsedValue = def.catchall.parse(data[key], {
+                ...params,
+                path: [...params.path, key],
+              });
+              return parsedValue;
+            } catch (err) {
+              if (err instanceof ZodError) {
+                const zerr: ZodError = err;
+                ERROR.addIssues(zerr.issues);
+                return INVALID;
+              } else {
+                throw err;
+              }
+            }
+          });
+        }
+      }
+
+      PROMISE = PseudoPromise.object(objectPromises)
+        .then(resolvedObject => {
+          Object.assign(RESULT.output, resolvedObject);
+          return RESULT.output;
+        })
+        .catch(err => {
+          if (err instanceof ZodError) {
+            ERROR.addIssues(err.issues);
+          }
+
+          return INVALID;
+        });
-  const checkCtx = {
+  const checkCtx: z.RefinementCtx = {
+    path: params.path,
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+
+      // if (resolvedValue !== INVALID) {
+      //   // let someError: boolean = false;
+
+      // }
+      if (resolvedValue !== INVALID) {
+        if (params.runAsyncValidationsInSeries) {
+          let someError = false;
+          await customChecks.reduce((previousPromise, check) => {
+            return previousPromise.then(async () => {
+              if (!someError) {
+                const len = ERROR.issues.length;
+                await check.check(resolvedValue, checkCtx);
+                if (len < ERROR.issues.length) someError = true;
+              }
+            });
+          }, Promise.resolve());
+        } else {
+          await Promise.all(
+            customChecks.map(async check => {
+              await check.check(resolvedValue, checkCtx);
+            }),
+          );
+        }
+      } else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }","+    if (data instanceof Map) {
+      return 'map';
+    }
+  'map',
-    const ctxArg = { data: data };
+    const ctxArg = { data };
+    case z.ZodTypes.map:
+      if (parsedType !== ZodParsedType.map) {
+        ERROR.addIssue(
+          makeError({
+            code: ZodIssueCode.invalid_type,
+            expected: ZodParsedType.map,
+            received: parsedType,
+          }),
+        );
+        THROW();
+      }
+      const dataMap: Map<unknown, unknown> = data;
+
+      PROMISE = PseudoPromise.all(
+        [...dataMap.entries()].map(([key, value], index) => {
+          const promises = [];
+
+          try {
+            promises.push(
+              PseudoPromise.resolve(
+                def.keyType.parse(key, {
+                  ...params,
+                  path: [...params.path, index, 'key'],
+                }),
+              ),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              ERROR.addIssues(zerr.issues);
+              promises.push(PseudoPromise.resolve(INVALID));
+            } else {
+              throw err;
+            }
+          }
+
+          try {
+            promises.push(
+              PseudoPromise.resolve(
+                def.valueType.parse(value, {
+                  ...params,
+                  path: [...params.path, index, 'value'],
+                }),
+              ),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              ERROR.addIssues(zerr.issues);
+              promises.push(PseudoPromise.resolve(INVALID));
+            } else {
+              throw err;
+            }
+          }
+
+          return PseudoPromise.all(promises);
+        }),
+      );
+      break;
-                  unionErrors: unionErrors,
+                  unionErrors,","+    if (data instanceof Map) {
+      return 'map';
+    }
+  'map',
+  runAsyncValidationsInSeries?: boolean;
-    async: baseParams.async || false,
+    async: baseParams.async ?? false,
+    runAsyncValidationsInSeries:
+      baseParams.runAsyncValidationsInSeries ?? false,
-    const ctxArg = { data: data };
+    const ctxArg = { data };
+    case z.ZodTypes.map:
+      if (parsedType !== ZodParsedType.map) {
+        ERROR.addIssue(
+          makeError({
+            code: ZodIssueCode.invalid_type,
+            expected: ZodParsedType.map,
+            received: parsedType,
+          }),
+        );
+        THROW();
+      }
+      const dataMap: Map<unknown, unknown> = data;
+
+      PROMISE = PseudoPromise.all(
+        [...dataMap.entries()].map(([key, value], index) => {
+          const promises = [];
+
+          try {
+            promises.push(
+              PseudoPromise.resolve(
+                def.keyType.parse(key, {
+                  ...params,
+                  path: [...params.path, index, 'key'],
+                }),
+              ),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              ERROR.addIssues(zerr.issues);
+              promises.push(PseudoPromise.resolve(INVALID));
+            } else {
+              throw err;
+            }
+          }
+
+          try {
+            promises.push(
+              PseudoPromise.resolve(
+                def.valueType.parse(value, {
+                  ...params,
+                  path: [...params.path, index, 'value'],
+                }),
+              ),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              ERROR.addIssues(zerr.issues);
+              promises.push(PseudoPromise.resolve(INVALID));
+            } else {
+              throw err;
+            }
+          }
+
+          return PseudoPromise.all(promises);
+        }),
+      );
+      break;
-      }
-
-      PROMISE = PseudoPromise.object(objectPromises).then(resolvedObject => {
-        Object.assign(RESULT.output, resolvedObject);
-        return RESULT.output;
-      });
+      } else {
+        // run cathcall validation
+        for (const key of extraKeys) {
+          objectPromises[key] = new PseudoPromise().then(() => {
+            try {
+              const parsedValue = def.catchall.parse(data[key], {
+                ...params,
+                path: [...params.path, key],
+              });
+              return parsedValue;
+            } catch (err) {
+              if (err instanceof ZodError) {
+                const zerr: ZodError = err;
+                ERROR.addIssues(zerr.issues);
+                return INVALID;
+              } else {
+                throw err;
+              }
+            }
+          });
+        }
+      }
+
+      PROMISE = PseudoPromise.object(objectPromises)
+        .then(resolvedObject => {
+          Object.assign(RESULT.output, resolvedObject);
+          return RESULT.output;
+        })
+        .catch(err => {
+          if (err instanceof ZodError) {
+            ERROR.addIssues(err.issues);
+          }
+
+          return INVALID;
+        });
-                  unionErrors: unionErrors,
+                  unionErrors,
-  const checkCtx = {
+  const checkCtx: z.RefinementCtx = {
+    path: params.path,
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+
+      // if (resolvedValue !== INVALID) {
+      //   // let someError: boolean = false;
+
+      // }
+      if (resolvedValue !== INVALID) {
+        if (params.runAsyncValidationsInSeries) {
+          let someError = false;
+          await customChecks.reduce((previousPromise, check) => {
+            return previousPromise.then(async () => {
+              if (!someError) {
+                const len = ERROR.issues.length;
+                await check.check(resolvedValue, checkCtx);
+                if (len < ERROR.issues.length) someError = true;
+              }
+            });
+          }, Promise.resolve());
+        } else {
+          await Promise.all(
+            customChecks.map(async check => {
+              await check.check(resolvedValue, checkCtx);
+            }),
+          );
+        }
+      } else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }"
colinhacks_zod,1ccfcdfe2beaf4b65db9318b870568b116d79a1a,Merge branch 'support-map' of git://github.com/lo1tuma/zod into lo1tuma-support-map,src/types/base.ts,"+import { util } from '../helpers/util';
+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
-  check: (arg: T, ctx: { addIssue: (arg: MakeErrorData) => void }) => any;
+  check: (arg: T, ctx: RefinementCtx) => any;
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
-    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData),
-            ? refinementData(val)
+            ? refinementData(val, ctx)","+  map = 'map',","+import { util } from '../helpers/util';
+  map = 'map',
+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
-  check: (arg: T, ctx: { addIssue: (arg: MakeErrorData) => void }) => any;
+  check: (arg: T, ctx: RefinementCtx) => any;
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
-    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData),
-            ? refinementData(val)
+            ? refinementData(val, ctx)"
colinhacks_zod,f50fb3fca9035ec34733d891b7d7afa3cbf8998e,FMC and added refinement path test,src/parser.ts,"-  const checkCtx = {
+  const checkCtx: z.RefinementCtx = {
+    path: params.path,","+  runAsyncValidationsInSeries?: boolean;
-    async: baseParams.async || false,
+    async: baseParams.async ?? false,
+    runAsyncValidationsInSeries:
+      baseParams.runAsyncValidationsInSeries ?? false,
-      PROMISE = PseudoPromise.object(objectPromises).then(resolvedObject => {
-        Object.assign(RESULT.output, resolvedObject);
-        return RESULT.output;
-      });
+      PROMISE = PseudoPromise.object(objectPromises)
+        .then(resolvedObject => {
+          Object.assign(RESULT.output, resolvedObject);
+          return RESULT.output;
+        })
+        .catch(err => {
+          if (err instanceof ZodError) {
+            ERROR.addIssues(err.issues);
+          }
+
+          return INVALID;
+        });
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+
+      // if (resolvedValue !== INVALID) {
+      //   // let someError: boolean = false;
+
+      // }
+      if (resolvedValue !== INVALID) {
+        if (params.runAsyncValidationsInSeries) {
+          let someError = false;
+          await customChecks.reduce((previousPromise, check) => {
+            return previousPromise.then(async () => {
+              if (!someError) {
+                const len = ERROR.issues.length;
+                await check.check(resolvedValue, checkCtx);
+                if (len < ERROR.issues.length) someError = true;
+              }
+            });
+          }, Promise.resolve());
+        } else {
+          await Promise.all(
+            customChecks.map(async check => {
+              await check.check(resolvedValue, checkCtx);
+            }),
+          );
+        }
+      } else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }","+  runAsyncValidationsInSeries?: boolean;
-    async: baseParams.async || false,
+    async: baseParams.async ?? false,
+    runAsyncValidationsInSeries:
+      baseParams.runAsyncValidationsInSeries ?? false,
-      PROMISE = PseudoPromise.object(objectPromises).then(resolvedObject => {
-        Object.assign(RESULT.output, resolvedObject);
-        return RESULT.output;
-      });
+      PROMISE = PseudoPromise.object(objectPromises)
+        .then(resolvedObject => {
+          Object.assign(RESULT.output, resolvedObject);
+          return RESULT.output;
+        })
+        .catch(err => {
+          if (err instanceof ZodError) {
+            ERROR.addIssues(err.issues);
+          }
+
+          return INVALID;
+        });
-  const checkCtx = {
+  const checkCtx: z.RefinementCtx = {
+    path: params.path,
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+
+      // if (resolvedValue !== INVALID) {
+      //   // let someError: boolean = false;
+
+      // }
+      if (resolvedValue !== INVALID) {
+        if (params.runAsyncValidationsInSeries) {
+          let someError = false;
+          await customChecks.reduce((previousPromise, check) => {
+            return previousPromise.then(async () => {
+              if (!someError) {
+                const len = ERROR.issues.length;
+                await check.check(resolvedValue, checkCtx);
+                if (len < ERROR.issues.length) someError = true;
+              }
+            });
+          }, Promise.resolve());
+        } else {
+          await Promise.all(
+            customChecks.map(async check => {
+              await check.check(resolvedValue, checkCtx);
+            }),
+          );
+        }
+      } else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }"
colinhacks_zod,f50fb3fca9035ec34733d891b7d7afa3cbf8998e,FMC and added refinement path test,src/playground.ts,"+import { ZodIssueCode } from './ZodError';
-  const data = z
-    .object({
-      foo: z
-        .boolean()
-        .nullable()
-        .default(true),
-      bar: z.boolean().default(true),
-    })
-    .parse({ foo: null });
+  const noNested = z.string()._refinement((_val, ctx) => {
+    if (ctx.path.length > 0) {
+      ctx.addIssue({
+        code: ZodIssueCode.custom,
+        message: `schema cannot be nested. path: ${ctx.path.join('.')}`,
+      });
+    }
+  });
-  console.log(data);
+  const data = z.object({
+    foo: noNested,
+  });
+
+  const t1 = await noNested.spa('asdf');
+  const t2 = await data.spa({ foo: 'asdf' });
+  console.log(t1);
+  console.log(t2);","-  const data = z
-    .object({
-      foo: z
-        .boolean()
-        .nullable()
-        .default(true),
-      bar: z.boolean().default(true),
-    })
-    .parse({ foo: null });
+  let count = 0;
-  console.log(data);
+  const base = z.object({
+    hello: z.string(),
+    foo: z
+      .number()
+      .refine(async () => {
+        count++;
+        return false;
+      })
+      .refine(async () => {
+        count++;
+        return false;
+      }),
+  });
+
+  const testval = { hello: 'bye', foo: 3 };
+  const result1 = await base.safeParseAsync(testval);
+  const result2 = await base.safeParseAsync(testval, {
+    runAsyncValidationsInSeries: true,
+  });
+
+  if (result1.success === false) {
+    console.log(`count: ${count}`);
+    console.log(`issues: ${result1.error.issues.length}`);
+    console.log(result1);
+  }
+
+  if (result2.success === false) {
+    console.log(`count: ${count}`);
+    console.log(`issues: ${result2.error.issues.length}`);
+    console.log(result2);
+  }
+","+import { ZodIssueCode } from './ZodError';
-  const data = z
-    .object({
-      foo: z
-        .boolean()
-        .nullable()
-        .default(true),
-      bar: z.boolean().default(true),
-    })
-    .parse({ foo: null });
+  const noNested = z.string()._refinement((_val, ctx) => {
+    if (ctx.path.length > 0) {
+      ctx.addIssue({
+        code: ZodIssueCode.custom,
+        message: `schema cannot be nested. path: ${ctx.path.join('.')}`,
+      });
+    }
+  });
-  console.log(data);
+  const data = z.object({
+    foo: noNested,
+  });
+
+  const t1 = await noNested.spa('asdf');
+  const t2 = await data.spa({ foo: 'asdf' });
+  console.log(t1);
+  console.log(t2);
+"
colinhacks_zod,f50fb3fca9035ec34733d891b7d7afa3cbf8998e,FMC and added refinement path test,src/types/base.ts,"+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
-  check: (arg: T, ctx: { addIssue: (arg: MakeErrorData) => void }) => any;
+  check: (arg: T, ctx: RefinementCtx) => any;
-    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData),
-            ? refinementData(val)
+            ? refinementData(val, ctx)","+import { util } from '../helpers/util';
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;","+import { util } from '../helpers/util';
+export type RefinementCtx = {
+  addIssue: (arg: MakeErrorData) => void;
+  path: (string | number)[];
+};
-  check: (arg: T, ctx: { addIssue: (arg: MakeErrorData) => void }) => any;
+  check: (arg: T, ctx: RefinementCtx) => any;
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
-    refinementData: MakeErrorData | ((arg: Output) => MakeErrorData),
+    refinementData:
+      | MakeErrorData
+      | ((arg: Output, ctx: RefinementCtx) => MakeErrorData),
-            ? refinementData(val)
+            ? refinementData(val, ctx)"
colinhacks_zod,fd151ec384ab7422cf58596ae50f8eaba22f5587,Merge branch 'pseudocatch' of git://github.com/ntilwalli/zod into ntilwalli-pseudocatch,src/parser.ts,"-          ? def.shape()[key]
+          ? shape[key]
-        objectPromises[key] = new PseudoPromise().then(() => {
-          try {
-            return keyValidator.parse(data[key], {
+        // check if schema and value are both optional
+
+        // const keyDataType = getParsedType(data[key]);
+        if (!Object.keys(data).includes(key)) {
+          try {
+            const output = keyValidator.parse(undefined, {
+            if (output === undefined) {
+              // schema is optional
+              // data is undefined
+              // don't explicity add undefined to outut
+              continue;
+            }
+          } catch (err) {}
+        }
+
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            const parsedValue = keyValidator.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+            return parsedValue;","-          ? def.shape()[key]
+          ? shape[key]
-        objectPromises[key] = new PseudoPromise().then(() => {
+        // check if schema and value are both optional
+
+        // const keyDataType = getParsedType(data[key]);
+        if (!Object.keys(data).includes(key)) {
-            return keyValidator.parse(data[key], {
+            const output = keyValidator.parse(undefined, {
+            if (output === undefined) {
+              // schema is optional
+              // data is undefined
+              // don't explicity add undefined to outut
+              continue;
+            }
+          } catch (err) {}
+        }
+
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            const parsedValue = keyValidator.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+            return parsedValue;
+      })
+      .catch(err => {
+        if (err instanceof ZodError) {
+          ERROR.addIssues(err.issues);
+        } 
+
+        return INVALID;
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+ 
+      if (resolvedValue !== INVALID) {
+        let someError: boolean = false;
+        await customChecks.reduce((previousPromise, check) => {
+          return previousPromise.then(async () => {
+            if (!someError) {
+              const len = ERROR.issues.length;
+              await check.check(resolvedValue, checkCtx);
+              if (len < ERROR.issues.length)
+                someError = true;
+            }
+          });
+        }, Promise.resolve());
+      }
+      // if (resolvedValue !== INVALID) {
+      //   await Promise.all(
+      //     customChecks.map(async check => {
+      //       await check.check(resolvedValue, checkCtx);
+      //         if (ERROR.issues.length > len) someError = true;
+      //       }
+      //       // if (!checkResult) {
+      //       //   const { check: checkMethod, ...noMethodCheck } = check;
+      //       //   ERROR.addIssue(makeError(noMethodCheck));
+      //       // } else {
+      //       // }
+      //     }),
+      //   );
+      // } 
+      else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }","-          ? def.shape()[key]
+          ? shape[key]
-        objectPromises[key] = new PseudoPromise().then(() => {
+        // check if schema and value are both optional
+
+        // const keyDataType = getParsedType(data[key]);
+        if (!Object.keys(data).includes(key)) {
-            return keyValidator.parse(data[key], {
+            const output = keyValidator.parse(undefined, {
+            if (output === undefined) {
+              // schema is optional
+              // data is undefined
+              // don't explicity add undefined to outut
+              continue;
+            }
+          } catch (err) {}
+        }
+
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            const parsedValue = keyValidator.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+            return parsedValue;
+      })
+      .catch(err => {
+        if (err instanceof ZodError) {
+          ERROR.addIssues(err.issues);
+        } 
+
+        return INVALID;
-      const resolvedValue = await PROMISE.getValueAsync();
-
-      await Promise.all(
-        customChecks.map(async check => {
-          await check.check(resolvedValue, checkCtx);
-          // if (!checkResult) {
-          //   const { check: checkMethod, ...noMethodCheck } = check;
-          //   ERROR.addIssue(makeError(noMethodCheck));
-          // } else {
-          // }
-        }),
-      );
-
-      if (resolvedValue === INVALID && ERROR.isEmpty) {
-        ERROR.addIssue(
-          makeError({
-            code: ZodIssueCode.custom,
-            message: 'Invalid',
-          }),
-        );
+      let resolvedValue = await PROMISE.getValueAsync();
+ 
+      if (resolvedValue !== INVALID) {
+        let someError: boolean = false;
+        await customChecks.reduce((previousPromise, check) => {
+          return previousPromise.then(async () => {
+            if (!someError) {
+              const len = ERROR.issues.length;
+              await check.check(resolvedValue, checkCtx);
+              if (len < ERROR.issues.length)
+                someError = true;
+            }
+          });
+        }, Promise.resolve());
+      }
+      // if (resolvedValue !== INVALID) {
+      //   await Promise.all(
+      //     customChecks.map(async check => {
+      //       await check.check(resolvedValue, checkCtx);
+      //         if (ERROR.issues.length > len) someError = true;
+      //       }
+      //       // if (!checkResult) {
+      //       //   const { check: checkMethod, ...noMethodCheck } = check;
+      //       //   ERROR.addIssue(makeError(noMethodCheck));
+      //       // } else {
+      //       // }
+      //     }),
+      //   );
+      // } 
+      else {
+        if (ERROR.isEmpty) {
+          ERROR.addIssue(
+            makeError({
+              code: ZodIssueCode.custom,
+              message: 'Invalid',
+            }),
+          );
+        }"
colinhacks_zod,fd151ec384ab7422cf58596ae50f8eaba22f5587,Merge branch 'pseudocatch' of git://github.com/ntilwalli/zod into ntilwalli-pseudocatch,src/types/base.ts,"-      return (x || def) as any;
+      return x === undefined ? def : x;","+import { util } from '../helpers/util';
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
-      return (x || def) as any;
+      return x === undefined ? def : x;","+import { util } from '../helpers/util';
-type CustomErrorParams = Partial<Omit<ZodCustomIssue, 'code'>>;
+type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, 'code'>>;
-      return (x || def) as any;
+      return x === undefined ? def : x;"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/codegen.ts,"-${this.seen.map(item => `type ${item.id} = Identity<${item.type}>;`).join('\n\n')}
+${this.seen
+  .map(item => `type ${item.id} = Identity<${item.type}>;`)
+  .join('\n\n')}
+      case z.ZodTypes.never:
+        return this.setType(id, `never`);
-        const baseStruct = `{\n${objectLines.map(line => `  ${line};`).join('\n')}\n}`;
+        const baseStruct = `{\n${objectLines
+          .map(line => `  ${line};`)
+          .join('\n')}\n}`;
-        const baseTuple = `[\n${tupleLines.map(line => `  ${line},`).join('\n')}\n]`;
+        const baseTuple = `[\n${tupleLines
+          .map(line => `  ${line},`)
+          .join('\n')}\n]`;
-        return this.setType(id, `${this.generate(def.left).id} & ${this.generate(def.right).id}`);
+        return this.setType(
+          id,
+          `${this.generate(def.left).id} & ${this.generate(def.right).id}`,
+        );
-        return this.setType(id, `{[k:string]: ${this.generate(def.valueType).id}}`);
+        return this.setType(
+          id,
+          `{[k:string]: ${this.generate(def.valueType).id}}`,
+        );
+      case z.ZodTypes.transformer:
+        return this.setType(
+          id,
+          `{[k:string]: ${this.generate(def.output).id}}`,
+        );","-  const def: z.ZodDef = schema._def;
-  if (def.t === z.ZodTypes.undefined) return true;
-  else if (def.t === z.ZodTypes.intersection) {
-    return isOptional(def.right) && isOptional(def.left);
-  } else if (def.t === z.ZodTypes.union) {
-    return def.options.map(isOptional).some(x => x === true);
-  }
-  return false;
+  // const def: z.ZodDef = schema._def;
+  // if (def.t === z.ZodTypes.undefined) return true;
+  // else if (def.t === z.ZodTypes.intersection) {
+  //   return isOptional(def.right) && isOptional(def.left);
+  // } else if (def.t === z.ZodTypes.union) {
+  //   return def.options.map(isOptional).some(x => x === true);
+  // }
+  // return false;
+
+  return schema.isOptional();
-${this.seen.map(item => `type ${item.id} = Identity<${item.type}>;`).join('\n\n')}
+${this.seen
+  .map(item => `type ${item.id} = Identity<${item.type}>;`)
+  .join('\n\n')}
-        const baseStruct = `{\n${objectLines.map(line => `  ${line};`).join('\n')}\n}`;
+        const baseStruct = `{\n${objectLines
+          .map(line => `  ${line};`)
+          .join('\n')}\n}`;
-        const baseTuple = `[\n${tupleLines.map(line => `  ${line},`).join('\n')}\n]`;
+        const baseTuple = `[\n${tupleLines
+          .map(line => `  ${line},`)
+          .join('\n')}\n]`;
-        return this.setType(id, `${this.generate(def.left).id} & ${this.generate(def.right).id}`);
+        return this.setType(
+          id,
+          `${this.generate(def.left).id} & ${this.generate(def.right).id}`,
+        );
-        return this.setType(id, `{[k:string]: ${this.generate(def.valueType).id}}`);
+        return this.setType(
+          id,
+          `{[k:string]: ${this.generate(def.valueType).id}}`,
+        );
+      case z.ZodTypes.optional:
+        return this.setType(id, `${this.generate(def.innerType).id}?`);","-  const def: z.ZodDef = schema._def;
-  if (def.t === z.ZodTypes.undefined) return true;
-  else if (def.t === z.ZodTypes.intersection) {
-    return isOptional(def.right) && isOptional(def.left);
-  } else if (def.t === z.ZodTypes.union) {
-    return def.options.map(isOptional).some(x => x === true);
-  }
-  return false;
+  // const def: z.ZodDef = schema._def;
+  // if (def.t === z.ZodTypes.undefined) return true;
+  // else if (def.t === z.ZodTypes.intersection) {
+  //   return isOptional(def.right) && isOptional(def.left);
+  // } else if (def.t === z.ZodTypes.union) {
+  //   return def.options.map(isOptional).some(x => x === true);
+  // }
+  // return false;
+
+  return schema.isOptional();
-${this.seen.map(item => `type ${item.id} = Identity<${item.type}>;`).join('\n\n')}
+${this.seen
+  .map(item => `type ${item.id} = Identity<${item.type}>;`)
+  .join('\n\n')}
+      case z.ZodTypes.never:
+        return this.setType(id, `never`);
-        const baseStruct = `{\n${objectLines.map(line => `  ${line};`).join('\n')}\n}`;
+        const baseStruct = `{\n${objectLines
+          .map(line => `  ${line};`)
+          .join('\n')}\n}`;
-        const baseTuple = `[\n${tupleLines.map(line => `  ${line},`).join('\n')}\n]`;
+        const baseTuple = `[\n${tupleLines
+          .map(line => `  ${line},`)
+          .join('\n')}\n]`;
-        return this.setType(id, `${this.generate(def.left).id} & ${this.generate(def.right).id}`);
+        return this.setType(
+          id,
+          `${this.generate(def.left).id} & ${this.generate(def.right).id}`,
+        );
-        return this.setType(id, `{[k:string]: ${this.generate(def.valueType).id}}`);
+        return this.setType(
+          id,
+          `{[k:string]: ${this.generate(def.valueType).id}}`,
+        );
+      case z.ZodTypes.transformer:
+        return this.setType(id, this.generate(def.output).id);
+      case z.ZodTypes.optional:
+        return this.setType(
+          id,
+          `${this.generate(def.innerType).id} | undefined`,
+        );
+      case z.ZodTypes.nullable:
+        return this.setType(id, `${this.generate(def.innerType).id} | null`);"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/helpers/partialUtil.ts,"+import { AnyZodObject } from '../types/object';
-    object: T extends z.ZodObject<infer Shape, infer Params>
-      ? z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>
+    object: T extends AnyZodObject
+      ? z.ZodObject<
+          { [k in keyof T['_shape']]: DeepPartial<T['_shape'][k]> },
+          T['_unknownKeys'],
+          T['_catchall']
+        >
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
+  }[T extends AnyZodObject ? 'object' : 'rest'];
-    object: T extends z.ZodObject<infer Shape, infer Params>
-      ? z.ZodUnion<[z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>, z.ZodUndefined]>
+    object: T extends z.ZodObject<
+      infer Shape,
+      infer UnknownKeys,
+      infer Catchall
+    >
+      ? z.ZodUnion<
+          [
+            z.ZodObject<
+              { [k in keyof Shape]: DeepPartial<Shape[k]> },
+              UnknownKeys,
+              Catchall
+            >,
+            z.ZodUndefined,
+          ]
+        >
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
+  }[T extends z.ZodObject<any, any, any> ? 'object' : 'rest'];","+    optional: T extends z.ZodOptional<z.ZodTypeAny> ? T : z.ZodOptional<T>;
-    rest: z.ZodUnion<[T, z.ZodUndefined]>;
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
+    rest: z.ZodOptional<T>;
+  }[T extends z.ZodObject<any>
+    ? 'object'
+    : T extends z.ZodOptional<any>
+    ? 'optional'
+    : 'rest'];
+    optional: T extends z.ZodOptional<z.ZodTypeAny> ? T : z.ZodOptional<T>;
-      ? z.ZodUnion<[z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>, z.ZodUndefined]>
+      ? z.ZodOptional<
+          z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>
+        >
-    rest: z.ZodUnion<[T, z.ZodUndefined]>;
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
+    rest: z.ZodOptional<T>;
+  }[T extends z.ZodObject<any>
+    ? 'object'
+    : T extends z.ZodOptional<any>
+    ? 'optional'
+    : 'rest'];","+import { AnyZodObject } from '../types/object';
+    // optional: T extends z.ZodOptional<z.ZodTypeAny> ? T : z.ZodOptional<T>;
+    // array: T extends z.ZodArray<infer Type> ? z.ZodArray<DeepPartial<Type>> : never;
+    object: T extends AnyZodObject
+      ? z.ZodObject<
+          { [k in keyof T['_shape']]: DeepPartial<T['_shape'][k]> },
+          T['_unknownKeys'],
+          T['_catchall']
+        >
+      : never;
+    rest: ReturnType<T['optional']>; //z.ZodOptional<T>;
+  }[T extends z.ZodObject<any>
+    ? 'object' // T extends z.ZodOptional<any> // ? 'optional' // :
+    : 'rest'];
+
+  export type DeepPartial<T extends z.ZodTypeAny> = {
+    // optional: T extends z.ZodOptional<z.ZodTypeAny> ? T : z.ZodOptional<T>;
-      ? z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>
+      ? z.ZodOptional<
+          z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>
+        >
-    rest: z.ZodUnion<[T, z.ZodUndefined]>;
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
-
-  export type DeepPartial<T extends z.ZodTypeAny> = {
-    // array: T extends z.ZodArray<infer Type> ? z.ZodArray<DeepPartial<Type>> : never;
-    object: T extends z.ZodObject<infer Shape, infer Params>
-      ? z.ZodUnion<[z.ZodObject<{ [k in keyof Shape]: DeepPartial<Shape[k]> }, Params>, z.ZodUndefined]>
-      : never;
-    rest: z.ZodUnion<[T, z.ZodUndefined]>;
-  }[T extends z.ZodObject<any> ? 'object' : 'rest'];
+    rest: ReturnType<T['optional']>;
+  }[T extends z.ZodObject<any>
+    ? 'object' // T extends z.ZodOptional<any> // ? 'optional' // :
+    : 'rest'];"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/index.ts,"+import { ZodNever, ZodNeverDef } from './types/never';
-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
-// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
-// ZodNonEmptyArrayIsEmptyError,
-// ZodUnrecognizedKeysError,
-// ZodInvalidUnionError,
-// ZodInvalidLiteralValueError,
-// ZodInvalidEnumValueError,
-// ZodInvalidArgumentsError,
-// ZodInvalidReturnTypeError,
-// ZodInvalidDateError,
-// ZodInvalidStringError,
-// ZodTooSmallError,
-// ZodTooBigError,
-// ZodCustomError } from './ZodError';
+import { ZodTransformer, ZodTransformerDef } from './types/transformer';
+import {
+  TypeOf,
+  input,
+  output,
+  ZodType,
+  ZodTypeAny,
+  ZodTypeDef,
+  ZodTypes,
+} from './types/base';
+
+// import { ZodError, ZodErrorCode } from './ZodError';
+
-
-
+  | ZodNeverDef
-  | ZodNativeEnumDef
-  | ZodPromiseDef;
+  | ZodPromiseDef
+  | ZodTransformerDef
+  | ZodNativeEnumDef;
+const neverType = ZodNever.create;
+const transformerType = ZodTransformer.create;
-export const custom = <T>(check: (data: unknown) => any, params?: Parameters<ZodAny['refine']>[1]): ZodType<T> =>
-  anyType().refine(check, params);
+export const custom = <T>(
+  check: (data: unknown) => any,
+  params?: Parameters<ZodAny['refine']>[1],
+): ZodType<T> => anyType().refine(check, params);
-  params: Parameters<ZodAny['refine']>[1] = { message: `Input not instance of ${cls.name}` },
+  params: Parameters<ZodAny['refine']>[1] = {
+    message: `Input not instance of ${cls.name}`,
+  },
+  neverType as never,
+  transformerType as transformer,
+  ZodNever,
+  ZodTransformer,
+export { TypeOf, TypeOf as infer, input, output };
+
-
-export { TypeOf, TypeOf as infer };","+import { ZodOptional, ZodOptionalDef } from ""./types/optional"";
+  | ZodOptionalDef
+const optionalType = ZodOptional.create;
+  optionalType as optional,
+  ZodOptional,","+import { ZodNever, ZodNeverDef } from './types/never';
-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
-// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
-// ZodNonEmptyArrayIsEmptyError,
-// ZodUnrecognizedKeysError,
-// ZodInvalidUnionError,
-// ZodInvalidLiteralValueError,
-// ZodInvalidEnumValueError,
-// ZodInvalidArgumentsError,
-// ZodInvalidReturnTypeError,
-// ZodInvalidDateError,
-// ZodInvalidStringError,
-// ZodTooSmallError,
-// ZodTooBigError,
-// ZodCustomError } from './ZodError';
+import { ZodTransformer, ZodTransformerDef } from './types/transformer';
+import { ZodOptional, ZodOptionalDef } from './types/optional';
+import { ZodNullable, ZodNullableDef } from './types/nullable';
+import {
+  TypeOf,
+  input,
+  output,
+  ZodType,
+  ZodTypeAny,
+  ZodTypeDef,
+  ZodTypes,
+} from './types/base';
+
+// import { ZodError, ZodErrorCode } from './ZodError';
+
-
-
+  | ZodNeverDef
+  | ZodTransformerDef
+  | ZodOptionalDef
+  | ZodNullableDef
+const neverType = ZodNever.create;
+const transformerType = ZodTransformer.create;
+const optionalType = ZodOptional.create;
+const nullableType = ZodNullable.create;
-export const custom = <T>(check: (data: unknown) => any, params?: Parameters<ZodAny['refine']>[1]): ZodType<T> =>
-  anyType().refine(check, params);
+export const custom = <T>(
+  check: (data: unknown) => any,
+  params?: Parameters<ZodAny['refine']>[1],
+): ZodType<T> => anyType().refine(check, params);
-  params: Parameters<ZodAny['refine']>[1] = { message: `Input not instance of ${cls.name}` },
+  params: Parameters<ZodAny['refine']>[1] = {
+    message: `Input not instance of ${cls.name}`,
+  },
+  neverType as never,
+  transformerType as transformer,
+  optionalType as optional,
+  nullableType as nullable,
+  ZodNever,
+  ZodTransformer,
+  ZodOptional,
+  ZodNullable,
+export { TypeOf, TypeOf as infer, input, output };
+
-
-export { TypeOf, TypeOf as infer };"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/isScalar.ts,"-export const isScalar = (schema: z.ZodType<any, any>, params: { root: boolean } = { root: true }): boolean => {
+export const isScalar = (
+  schema: z.ZodType<any, any>,
+  params: { root: boolean } = { root: true },
+): boolean => {
+      returnValue = false;
+      break;
+    case z.ZodTypes.never:
+    case z.ZodTypes.transformer:
+      returnValue = isScalar(def.output);
+      break;","-export const isScalar = (schema: z.ZodType<any, any>, params: { root: boolean } = { root: true }): boolean => {
+export const isScalar = (
+  schema: z.ZodType<any, any>,
+  params: { root: boolean } = { root: true },
+): boolean => {
-
+    case z.ZodTypes.optional:
+      returnValue = isScalar(def.innerType);
+      break;","-export const isScalar = (schema: z.ZodType<any, any>, params: { root: boolean } = { root: true }): boolean => {
+export const isScalar = (
+  schema: z.ZodType<any, any>,
+  params: { root: boolean } = { root: true },
+): boolean => {
+      returnValue = false;
+      break;
+    case z.ZodTypes.never:
+    case z.ZodTypes.transformer:
+      returnValue = isScalar(def.output);
+      break;
+    case z.ZodTypes.optional:
+      returnValue = isScalar(def.innerType);
+      break;
+    case z.ZodTypes.nullable:
+      returnValue = isScalar(def.innerType);
+      break;"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/parser.ts,"-import { ZodDef } from './index';
-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ZodDef, ZodNever } from '.';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: z.ZodType<any>;
+    objects: { data: any; error?: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
+  'never',
-export const find = (arr: any[], checker: (arg: any) => any) => {
-  for (const item of arr) {
-    if (checker(item)) return item;
-  }
-  return undefined;
+// conditional required to distribute union
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
-// conditional required to distribute union
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
-
-export const ZodParser = (schemaDef: z.ZodTypeDef) => (
-  obj: any,
+const INVALID = Symbol('invalid_data');
+
+export const ZodParser = (schema: z.ZodType<any>) => (
+  data: any,
+    async: baseParams.async || false,
-    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-    const ctxArg = { data: obj };
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
+    const ctxArg = { data: data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const def: ZodDef = schemaDef as any;
-
-  const parsedType = getParsedType(obj);
-
-  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
-  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
-
-  if (isNonprimitive) {
-    if (schemaSeen) {
-      const found = find(schemaSeen.objects, x => x.data === obj);
-
-      if (found) {
-        if (found.error) {
-          throw found.error;
-        }
-
-        found.times = found.times + 1;
-
-        if (found.times > 5 && isNonprimitive) {
-          return Symbol('recursion depth exceeded.');
-        } else if (found.times > 2) {
-        }
-      } else {
-        //
-        schemaSeen.objects.push(obj);
-      }
-    } else {
-      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+  const def: ZodDef = schema._def as any;
+
+  const finder = (arr: any[], checker: (arg: any) => any) => {
+    for (const item of arr) {
+      if (checker(item)) return item;
+    return undefined;
+  };
+
+  const defaultPromise = new PseudoPromise();
+  (defaultPromise as any)._default = true;
+  const RESULT: { data: any; promise: PseudoPromise<any> } = {
+    data,
+    promise: defaultPromise,
+  };
+  params.seen = params.seen || [];
+  params.seen.push({ schema, objects: [] });
+  const schemaSeen = finder(params.seen, x => x.schema === schema); // params.seen.find(x => x.schema === schemaDef)!;
+  const objectSeen = finder(schemaSeen.objects, arg => arg.data === data); //.find(x => x.data === data);
+
+  if (objectSeen && def.t !== z.ZodTypes.transformer) {
+    // return objectSeen.promise._cached.value; //.getValue();
+    // return data;
+  } else {
+    schemaSeen.objects.push(RESULT);
-  // const setError = (error: Error) => {
-  //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  //   if (schemaSeen) {
-  //     const found = schemaSeen.objects.find(x => x.data === obj);
-  //     if (found) {
-  //       found.error = error;
-  //     }
-  //   }
-  // };
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
+  // }
-  let returnValue: any = obj;
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  const parsedType = getParsedType(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
+    case z.ZodTypes.never:
+      error.addError(
+        makeError({
+          code: ZodErrorCode.invalid_type,
+          expected: ZodParsedType.never,
+          received: parsedType,
+        }),
+      );
+      RESULT.promise = PseudoPromise.resolve(INVALID);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        // setError(error);
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              error.addErrors(zerr.errors);
+              return PseudoPromise.resolve(INVALID);
+            }
+            throw err;
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      for (const key of shapeKeys) {
+        const keyValidator = shapeKeys.includes(key)
+          ? def.shape()[key]
+          : !(def.catchall instanceof ZodNever)
+          ? def.catchall
+          : undefined;
+
+        if (!keyValidator) continue;
+
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return keyValidator.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              error.addErrors(zerr.errors);
+              return INVALID;
+            } else {
+              throw err;
+            }
+          }
+        });
+      }
+
+      if (def.catchall instanceof ZodNever) {
+        if (def.unknownKeys === 'allow') {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
+        } else if (def.unknownKeys === 'strict') {
+          if (extraKeys.length > 0) {
+            error.addError(
+              makeError({
+                code: ZodErrorCode.unrecognized_keys,
+                keys: extraKeys,
+              }),
+            );
+          }
+        } else if (def.unknownKeys === 'strip') {
+          // do nothing
+        } else {
+          util.assertNever(def.unknownKeys);
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              unionErrors.push(err);
+              return PseudoPromise.resolve(INVALID);
+            }
+            throw err;
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return finder(unionResults, (val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              if (err instanceof ZodError) {
+                error.addErrors(err.errors);
+                return INVALID;
+              }
+              throw err;
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-            options: util.getValues(def.values),
-          }),
-        );
-      }
+            options: Object.values(def.values),
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+
+        .then(inputParseResult => {
+          try {
+            const transformed = def.transformer(inputParseResult);
+            if (transformed instanceof Promise && params.async === false) {
+              if (z.inputSchema(def.output)._def.t !== z.ZodTypes.promise) {
+                throw new Error(
+                  ""You can't call .parse on a schema containing async transformations."",
+                );
+              }
+            }
+            return transformed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  const customChecks = def.checks || [];
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
-    }
+  if ((RESULT.promise as any)._default === true) {
+    throw new Error('Result is not materialized.');
-    // setError(error);
-  return returnValue as any;
+  const customChecks = def.checks || [];
+
+  if (params.async === false) {
+    const resolvedValue = RESULT.promise.getValueSync();
+
+    // const SYNC_ERROR =
+    // ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    // if (resolvedValue instanceof Promise) {
+
+    //   if (def.t !== z.ZodTypes.promise) {
+    //     throw new Error(SYNC_ERROR);
+    //   }
+    // }
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    // if (resolvedValue === INVALID) {
+    //   throw new ZodError([]).addError(
+    //     makeError({
+    //       code: ZodErrorCode.custom_error,
+    //       message: 'Invalid',
+    //     }),
+    //   );
+    // }
+    return resolvedValue as any;
+  } else {
+    // if (params.async == true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  }","-import { ZodDef } from './index';
-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ZodDef, ZodUndefined } from './index';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; error?: any; times: number }[];
+  }[];
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
-    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+      params.seen.push({
+        schema: schemaDef,
+        objects: [{ data: obj, error: undefined, times: 1 }],
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
+          const parsedItem = def.type.parse(item, {
+            ...params,
+            path: [...params.path, i],
+          });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+          error.addError(
+            makeError({
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          def
+            .shape()
+            [key].parse(obj[key], { ...params, path: [...params.path, key] });
+    case z.ZodTypes.optional:
+      try {
+        ZodUndefined.create().parse(obj, params);
+        break;
+      } catch {}
+
+      try {
+        def.innerType.parse(obj, params);
+        break;
+      } catch (err) {
+        const zerr: ZodError = err;
+        error.addErrors(zerr.errors);
+      }
+      break;
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+          parsedTuple.push(
+            itemParser.parse(item, {
+              ...params,
+              path: [...params.path, index],
+            }),
+          );
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+          def.valueType.parse(obj[key], {
+            ...params,
+            path: [...params.path, key],
+          });","-import { ZodDef } from './index';
-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ZodDef, ZodNever } from './index';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: z.ZodType<any>;
+    objects: { data: any; error?: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
+  'never',
-export const find = (arr: any[], checker: (arg: any) => any) => {
-  for (const item of arr) {
-    if (checker(item)) return item;
-  }
-  return undefined;
+// conditional required to distribute union
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
-// conditional required to distribute union
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
-
-export const ZodParser = (schemaDef: z.ZodTypeDef) => (
-  obj: any,
+const INVALID = Symbol('invalid_data');
+
+export const ZodParser = (schema: z.ZodType<any>) => (
+  data: any,
+    async: baseParams.async || false,
-    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-    const ctxArg = { data: obj };
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
+    const ctxArg = { data: data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const def: ZodDef = schemaDef as any;
-
-  const parsedType = getParsedType(obj);
-
-  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
-  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
-
-  if (isNonprimitive) {
-    if (schemaSeen) {
-      const found = find(schemaSeen.objects, x => x.data === obj);
-
-      if (found) {
-        if (found.error) {
-          throw found.error;
-        }
-
-        found.times = found.times + 1;
-
-        if (found.times > 5 && isNonprimitive) {
-          return Symbol('recursion depth exceeded.');
-        } else if (found.times > 2) {
-        }
-      } else {
-        //
-        schemaSeen.objects.push(obj);
-      }
+  const def: ZodDef = schema._def as any;
+
+  const finder = (arr: any[], checker: (arg: any) => any) => {
+    for (const item of arr) {
+      if (checker(item)) return item;
+    }
+    return undefined;
+  };
+
+  const defaultPromise = new PseudoPromise();
+  (defaultPromise as any)._default = true;
+  const RESULT: { data: any; promise: PseudoPromise<any> } = {
+    data,
+    promise: defaultPromise,
+  };
+  params.seen = params.seen || [];
+  params.seen.push({ schema, objects: [] });
+  const schemaSeen = finder(params.seen, x => x.schema === schema); // params.seen.find(x => x.schema === schemaDef)!;
+  if (schemaSeen) {
+    const objectSeen = finder(schemaSeen.objects, arg => arg.data === data); //.find(x => x.data === data);
+
+    if (objectSeen && def.t !== z.ZodTypes.transformer) {
+      // return objectSeen.promise._cached.value; //.getValue();
+      // return data;
-      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+      schemaSeen.objects.push(RESULT);
-  // const setError = (error: Error) => {
-  //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  //   if (schemaSeen) {
-  //     const found = schemaSeen.objects.find(x => x.data === obj);
-  //     if (found) {
-  //       found.error = error;
-  //     }
-  //   }
-  // };
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
+  // }
-  let returnValue: any = obj;
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  const parsedType = getParsedType(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
+    case z.ZodTypes.never:
+      error.addError(
+        makeError({
+          code: ZodErrorCode.invalid_type,
+          expected: ZodParsedType.never,
+          received: parsedType,
+        }),
+      );
+      RESULT.promise = PseudoPromise.resolve(INVALID);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        // setError(error);
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              error.addErrors(zerr.errors);
+              return PseudoPromise.resolve(INVALID);
+            }
+            throw err;
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      for (const key of shapeKeys) {
+        const keyValidator = shapeKeys.includes(key)
+          ? def.shape()[key]
+          : !(def.catchall instanceof ZodNever)
+          ? def.catchall
+          : undefined;
+
+        if (!keyValidator) continue;
+
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return keyValidator.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            if (err instanceof ZodError) {
+              const zerr: ZodError = err;
+              error.addErrors(zerr.errors);
+              return INVALID;
+            } else {
+              throw err;
+            }
+          }
+        });
+      }
+
+      if (def.catchall instanceof ZodNever) {
+        if (def.unknownKeys === 'allow') {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
+        } else if (def.unknownKeys === 'strict') {
+          if (extraKeys.length > 0) {
+            error.addError(
+              makeError({
+                code: ZodErrorCode.unrecognized_keys,
+                keys: extraKeys,
+              }),
+            );
+          }
+        } else if (def.unknownKeys === 'strip') {
+          // do nothing
+        } else {
+          util.assertNever(def.unknownKeys);
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              unionErrors.push(err);
+              return PseudoPromise.resolve(INVALID);
+            }
+            throw err;
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return finder(unionResults, (val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      break;
-
+      });
+
+      break;
+
+    case z.ZodTypes.optional:
+      if (parsedType === ZodParsedType.undefined) {
+        RESULT.promise = PseudoPromise.resolve(undefined);
+        break;
+      }
+
+      RESULT.promise = new PseudoPromise().then(() => {
+        try {
+          return def.innerType.parse(data, params);
+        } catch (err) {
+          if (err instanceof ZodError) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+          throw err;
+        }
+      });
+      break;
+    case z.ZodTypes.nullable:
+      if (parsedType === ZodParsedType.null) {
+        RESULT.promise = PseudoPromise.resolve(null);
+        break;
+      }
+
+      RESULT.promise = new PseudoPromise().then(() => {
+        try {
+          return def.innerType.parse(data, params);
+        } catch (err) {
+          if (err instanceof ZodError) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+          throw err;
+        }
+      });
+      break;
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              if (err instanceof ZodError) {
+                error.addErrors(err.errors);
+                return INVALID;
+              }
+              throw err;
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-            options: util.getValues(def.values),
-          }),
-        );
-      }
+            options: Object.values(def.values),
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+
+        .then(inputParseResult => {
+          try {
+            const transformed = def.transformer(inputParseResult);
+            if (transformed instanceof Promise && params.async === false) {
+              if (z.inputSchema(def.output)._def.t !== z.ZodTypes.promise) {
+                throw new Error(
+                  ""You can't call .parse on a schema containing async transformations."",
+                );
+              }
+            }
+            return transformed;
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+              return INVALID;
+            }
+            throw err;
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  const customChecks = def.checks || [];
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
-    }
+  if ((RESULT.promise as any)._default === true) {
+    throw new Error('Result is not materialized.');
-    // setError(error);
-  return returnValue as any;
+  const customChecks = def.checks || [];
+
+  if (params.async === false) {
+    const resolvedValue = RESULT.promise.getValueSync();
+
+    // const SYNC_ERROR =
+    // ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    // if (resolvedValue instanceof Promise) {
+
+    //   if (def.t !== z.ZodTypes.promise) {
+    //     throw new Error(SYNC_ERROR);
+    //   }
+    // }
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    // if (resolvedValue === INVALID) {
+    //   throw new ZodError([]).addError(
+    //     makeError({
+    //       code: ZodErrorCode.custom_error,
+    //       message: 'Invalid',
+    //     }),
+    //   );
+    // }
+    return resolvedValue as any;
+  } else {
+    // if (params.async == true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  }"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/switcher.ts,"+      break;
+    case z.ZodTypes.never:
+    case z.ZodTypes.transformer:
+      break;","+    case z.ZodTypes.optional:
+      break;","+      break;
+    case z.ZodTypes.never:
+    case z.ZodTypes.transformer:
+      break;
+    case z.ZodTypes.optional:
+      break;
+    case z.ZodTypes.nullable:
+      break;"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/types/base.ts,"-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '../index';
+import {
+  ZodErrorCode,
+  ZodArray,
+  ZodUnion,
+  ZodNull,
+  ZodUndefined,
+  ZodTransformer,
+} from '../index';
+import { ZodError } from '../ZodError';
+  never = 'never',
+  transformer = 'transformer',
+
+export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
+  if (schema instanceof ZodTransformer) {
+    return inputSchema(schema._def.input);
+  } else {
+    return schema;
+  }
+};
+
+export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
+  if (schema instanceof ZodTransformer) {
+    return inputSchema(schema._def.output);
+  } else {
+    return schema;
+  }
+};
-export type TypeOf<T extends { _type: any }> = T['_type'];
-export type Infer<T extends { _type: any }> = T['_type'];
-
-export abstract class ZodType<Type, Def extends ZodTypeDef = ZodTypeDef> {
-  readonly _type!: Type;
+export type TypeOf<T extends ZodType<any>> = T['_output'];
+export type input<T extends ZodType<any>> = T['_input'];
+export type output<T extends ZodType<any>> = T['_output'];
+export type infer<T extends ZodType<any>> = T['_output'];
+
+export abstract class ZodType<
+  Output,
+  Def extends ZodTypeDef = ZodTypeDef,
+  Input = Output
+> {
+  readonly _type!: Output;
+  readonly _output!: Output;
-
-  parse: (x: Type | unknown, params?: ParseParams) => Type;
+  readonly _input!: Input;
+
+  // get inputSchema(): ZodTypeAny = this;
+  // outputSchema: ZodTypeAny = this;
+  //  = ()=>{
+  //   return this;
+  // }
+  //  outputSchema = () => {
+  //    return this;
+  //  };
+
+  parse: (x: unknown, params?: ParseParams) => Output;
-    x: Type | unknown,
+    x: unknown,
-  ) => { success: true; data: Type } | { success: false; error: ZodError } = (data, params) => {
+  ) => { success: true; data: Output } | { success: false; error: ZodError } = (
+    data,
+    params,
+  ) => {
-      return {
-        success: true,
-        data: parsed,
-      };
+      return { success: true, data: parsed };
-        return {
-          success: false,
-          error: err,
-        };
+        return { success: false, error: err };
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = (value, params) => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value, params);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
+  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
+    value,
+    params,
+  ) => {
+    return await this.parse(value, { ...params, async: true });
+  };
+
+  safeParseAsync: (
+    x: unknown,
+    params?: ParseParams,
+  ) => Promise<
+    { success: true; data: Output } | { success: false; error: ZodError }
+  > = async (data, params) => {
+    try {
+      const parsed = await this.parseAsync(data, params);
+      return { success: true, data: parsed };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return { success: false, error: err };
-    });
-  };
-
-  is(u: Type): u is Type {
+      throw err;
+    }
+  };
+
+  is(u: Input): u is Input {
-  check(u: Type | unknown): u is Type {
+  check(u: unknown): u is Input {
-  refine = <Func extends (arg: Type) => any>(
+  refine = <Func extends (arg: Output) => any>(
-    message: string | util.Omit<Check<Type>, 'check'> = 'Invalid value.',
+    message: string | util.Omit<Check<Output>, 'check'> = 'Invalid value.',
-  refinement = (refinement: Check<Type>) => {
-    return this._refinement({ code: ZodErrorCode.custom_error, ...refinement });
-  };
-
-  protected _refinement: (refinement: InternalCheck<Type>) => this = refinement => {
+  refinement = (refinement: Check<Output>) => {
+    return this._refinement({
+      code: ZodErrorCode.custom_error,
+      ...refinement,
+    });
+  };
+
+  protected _refinement: (
+    refinement: InternalCheck<Output>,
+  ) => this = refinement => {
-    this.parse = ZodParser(def);
+    this.parse = ZodParser(this);
-  optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
+  optional: () => ZodUnion<[this, ZodUndefined]> = () =>
+    ZodUnion.create([this, ZodUndefined.create()]);
+  nullable: () => ZodUnion<[this, ZodNull]> = () =>
+    ZodUnion.create([this, ZodNull.create()]);
+  // pre: <T extends string>(
+  //   input: T,
+  //   transformer: (arg: T) => Type,
+  // ) => any = (input, transformer) => 'adsf';
+
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+  // };
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+
+  //  push(...items: T[]): number;
+  //  push(this: BetterArrayClass<T>, value: T): this;
+
+  transform<
+    This extends this,
+    U extends ZodType<any>,
+    Tx extends (arg: This['_output']) => U['_input'] | Promise<U['_input']>
+  >(input: U, transformer: Tx): ZodTransformer<This, U>;
+  transform<
+    This extends this,
+    Tx extends (
+      arg: This['_output'],
+    ) => This['_input'] | Promise<This['_input']>
+  >(transformer: Tx): ZodTransformer<This, This>;
+  transform(input: any, transformer?: any) {
+    if (transformer) {
+      return ZodTransformer.create(this as any, input, transformer) as any;
+    }
+    return ZodTransformer.create(this as any, this, input) as any;
+  }
+
+  default: <
+    T extends Output = Output,
+    Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>
+  >(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };
+
+  //  codec = (): ZodCodec<this, this> => {
+  //    return ZodCodec.create(this, this, x => x);
+  //  };
+
+  //  transform: <U extends ZodType<any>, Tx extends (arg: Type) => U['_type']>(
+  //    x: U,s
+  //    transformer: Tx,
+  //  ) => ZodCodec<this, U> = (input, transformer) => {
+  //    return ZodCodec.create(input, this, transformer);
+  //  };
+","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '../index';
+import {
+  ZodErrorCode,
+  ZodArray,
+  ZodUnion,
+  ZodNull,
+  ZodError,
+  ZodOptional,
+} from '../index';
+import { ZodOptionalType } from './optional';
+  optional = 'optional',
-  ) => { success: true; data: Type } | { success: false; error: ZodError } = (data, params) => {
+  ) => { success: true; data: Type } | { success: false; error: ZodError } = (
+    data,
+    params,
+  ) => {
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = (value, params) => {
+  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = (
+    value,
+    params,
+  ) => {
-    return this._refinement({ code: ZodErrorCode.custom_error, ...refinement });
+    return this._refinement({
+      code: ZodErrorCode.custom_error,
+      ...refinement,
+    });
-  protected _refinement: (refinement: InternalCheck<Type>) => this = refinement => {
+  protected _refinement: (
+    refinement: InternalCheck<Type>,
+  ) => this = refinement => {
-  optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
+  optional: () => ZodOptionalType<this> = () => ZodOptional.create(this);
+  nullable: () => ZodUnion<[this, ZodNull]> = () =>
+    ZodUnion.create([this, ZodNull.create()]);
+
+  isOptional: () => boolean = () => this.safeParse(undefined).success;
+  isNullable: () => boolean = () => this.safeParse(null).success;","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '../index';
+import {
+  ZodErrorCode,
+  ZodArray,
+  ZodUnion,
+  ZodUndefined,
+  ZodTransformer,
+  ZodError,
+  ZodOptional,
+  ZodNullable,
+} from '../index';
+
+import { ZodOptionalType } from './optional';
+import { ZodNullableType } from './nullable';
+  never = 'never',
+  transformer = 'transformer',
+  optional = 'optional',
+  nullable = 'nullable',
+
+export const inputSchema = (schema: ZodType<any>): ZodType<any> => {
+  if (schema instanceof ZodTransformer) {
+    return inputSchema(schema._def.input);
+  } else {
+    return schema;
+  }
+};
+
+export const outputSchema = (schema: ZodType<any>): ZodType<any> => {
+  if (schema instanceof ZodTransformer) {
+    return inputSchema(schema._def.output);
+  } else {
+    return schema;
+  }
+};
-export type TypeOf<T extends { _type: any }> = T['_type'];
-export type Infer<T extends { _type: any }> = T['_type'];
-
-export abstract class ZodType<Type, Def extends ZodTypeDef = ZodTypeDef> {
-  readonly _type!: Type;
+export type TypeOf<T extends ZodType<any>> = T['_output'];
+export type input<T extends ZodType<any>> = T['_input'];
+export type output<T extends ZodType<any>> = T['_output'];
+export type infer<T extends ZodType<any>> = T['_output'];
+
+export abstract class ZodType<
+  Output,
+  Def extends ZodTypeDef = ZodTypeDef,
+  Input = Output
+> {
+  readonly _type!: Output;
+  readonly _output!: Output;
-
-  parse: (x: Type | unknown, params?: ParseParams) => Type;
+  readonly _input!: Input;
+
+  // get inputSchema(): ZodTypeAny = this;
+  // outputSchema: ZodTypeAny = this;
+  //  = ()=>{
+  //   return this;
+  // }
+  //  outputSchema = () => {
+  //    return this;
+  //  };
+
+  parse: (x: unknown, params?: ParseParams) => Output;
-    x: Type | unknown,
+    x: unknown,
-  ) => { success: true; data: Type } | { success: false; error: ZodError } = (data, params) => {
+  ) => { success: true; data: Output } | { success: false; error: ZodError } = (
+    data,
+    params,
+  ) => {
-      return {
-        success: true,
-        data: parsed,
-      };
+      return { success: true, data: parsed };
-        return {
-          success: false,
-          error: err,
-        };
+        return { success: false, error: err };
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = (value, params) => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value, params);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
+  parseAsync: (x: unknown, params?: ParseParams) => Promise<Output> = async (
+    value,
+    params,
+  ) => {
+    return await this.parse(value, { ...params, async: true });
+  };
+
+  safeParseAsync: (
+    x: unknown,
+    params?: ParseParams,
+  ) => Promise<
+    { success: true; data: Output } | { success: false; error: ZodError }
+  > = async (data, params) => {
+    try {
+      const parsed = await this.parseAsync(data, params);
+      return { success: true, data: parsed };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return { success: false, error: err };
-    });
-  };
-
-  is(u: Type): u is Type {
+      throw err;
+    }
+  };
+
+  is(u: Input): u is Input {
-  check(u: Type | unknown): u is Type {
+  check(u: unknown): u is Input {
-  refine = <Func extends (arg: Type) => any>(
+  refine = <Func extends (arg: Output) => any>(
-    message: string | util.Omit<Check<Type>, 'check'> = 'Invalid value.',
+    message: string | util.Omit<Check<Output>, 'check'> = 'Invalid value.',
-  refinement = (refinement: Check<Type>) => {
-    return this._refinement({ code: ZodErrorCode.custom_error, ...refinement });
-  };
-
-  protected _refinement: (refinement: InternalCheck<Type>) => this = refinement => {
+  refinement = (refinement: Check<Output>) => {
+    return this._refinement({
+      code: ZodErrorCode.custom_error,
+      ...refinement,
+    });
+  };
+
+  protected _refinement: (
+    refinement: InternalCheck<Output>,
+  ) => this = refinement => {
-    this.parse = ZodParser(def);
+    this.parse = ZodParser(this);
-  optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
+  optional: () => ZodOptionalType<this> = () => ZodOptional.create(this);
+  nullable: () => ZodNullableType<this> = () => {
+    return ZodNullable.create(this) as any;
+  };
+  //  nullable: () => ZodUnion<[this, ZodNull]> = () =>
+  //    ZodUnion.create([this, ZodNull.create()]);
+  // pre: <T extends string>(
+  //   input: T,
+  //   transformer: (arg: T) => Type,
+  // ) => any = (input, transformer) => 'adsf';
+
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+  // };
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+
+  //  push(...items: T[]): number;
+  //  push(this: BetterArrayClass<T>, value: T): this;
+
+  transform<
+    This extends this,
+    U extends ZodType<any>,
+    Tx extends (arg: This['_output']) => U['_input'] | Promise<U['_input']>
+  >(input: U, transformer: Tx): ZodTransformer<This, U>;
+  transform<
+    This extends this,
+    Tx extends (
+      arg: This['_output'],
+    ) => This['_input'] | Promise<This['_input']>
+  >(transformer: Tx): ZodTransformer<This, This>;
+  transform(input: any, transformer?: any) {
+    if (transformer) {
+      return ZodTransformer.create(this as any, input, transformer) as any;
+    }
+    return ZodTransformer.create(this as any, this, input) as any;
+  }
+
+  default: <
+    T extends Output = Output,
+    Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>
+  >(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };
+
+  //  codec = (): ZodCodec<this, this> => {
+  //    return ZodCodec.create(this, this, x => x);
+  //  };
+
+  //  transform: <U extends ZodType<any>, Tx extends (arg: Type) => U['_type']>(
+  //    x: U,s
+  //    transformer: Tx,
+  //  ) => ZodCodec<this, U> = (input, transformer) => {
+  //    return ZodCodec.create(input, this, transformer);
+  //  };
+
+
+  isOptional: () => boolean = () => this.safeParse(undefined).success;
+  isNullable: () => boolean = () => this.safeParse(null).success;"
colinhacks_zod,f498e6425636e1bd0cf3998e364d8f1730f56f7e,merged top-level optional class. added nullable class.,src/types/object.ts,"-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+import { ZodNever } from '..';
+
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-  Def['params']
+  Def['unknownKeys'],
+  Def['catchall']
+type UnknownKeysParam = 'allow' | 'strict' | 'strip';
+
-  Params extends ZodObjectParams = ZodObjectParams
+  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
+  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  // Params extends ZodObjectParams = ZodObjectParams
-  params: Params;
+  catchall: Catchall;
+  unknownKeys: UnknownKeys;
+  // params: Params;
+
+export type baseObjectOutputType<
+  Shape extends z.ZodRawShape
+  // Catchall extends z.ZodTypeAny
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]['_output'];
+    }
+  > //{ [k: string]: Catchall['_output'] }
+>;
+
+export type objectOutputType<
+  Shape extends z.ZodRawShape,
+  Catchall extends z.ZodTypeAny
+> = z.ZodTypeAny extends Catchall
+  ? baseObjectOutputType<Shape>
+  : objectUtil.flatten<
+      baseObjectOutputType<Shape> & { [k: string]: Catchall['_output'] }
+    >;
+
+export type baseObjectInputType<
+  Shape extends z.ZodRawShape
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]['_input'];
+    }
+  >
+>;
+
+export type objectInputType<
+  Shape extends z.ZodRawShape,
+  Catchall extends z.ZodTypeAny
+> = z.ZodTypeAny extends Catchall
+  ? baseObjectInputType<Shape>
+  : objectUtil.flatten<
+      baseObjectInputType<Shape> & { [k: string]: Catchall['_input'] }
+    >;
-interface ZodObjectParams {
-  strict: boolean;
-}
+// interface ZodObjectParams {
+//   strict: boolean;
+// }
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
-  { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
->;
-
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
-  ? objectUtil.ObjectType<T>
-  : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
-
+// type SetKey<
+//   Target extends object,
+//   Key extends string,
+//   Value extends any
+// > = objectUtil.Flatten<
+//   { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
+// >;
+
+// type makeKeysRequired<T extends ZodObject<any, any, any>> = T extends ZodObject<
+//   infer U,
+//   infer P,
+//   infer C
+// >
+//   ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P, C>
+//   : never;
+
+// type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+//   ? U extends [infer Y, ZodUndefined]
+//     ? Y
+//     : U extends [ZodUndefined, infer Z]
+//     ? Z
+//     : T
+//   : T;
+
+// type ZodObjectType<
+//   T extends z.ZodRawShape,
+//   Params extends ZodObjectParams
+// > = Params['strict'] extends true
+//   ? objectUtil.ObjectType<T>
+//   : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
+
+export type AnyZodObject = ZodObject<any, any, any>;
+// export type AnyZodObject = ZodObject<
+// z.ZodRawShape,
+// UnknownKeysParam,
+// z.ZodTypeAny
+// >;
-  Params extends ZodObjectParams = { strict: true },
-  Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
-> extends z.ZodType<Type, ZodObjectDef<T, Params>> {
+  UnknownKeys extends UnknownKeysParam = 'allow',
+  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  // Params extends ZodObjectParams = { strict: true },
+  // Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
+  // Input extends objectUtil.objectInputType<T> = objectUtil.objectInputType<T>,
+  // Output extends objectUtil.objectOutputType<T> = objectUtil.objectOutputType<T>
+> extends z.ZodType<
+  //  objectUtil.objectOutputType<T, UnknownKeys, Catchall>,
+  objectOutputType<T, Catchall>,
+  ZodObjectDef<T, UnknownKeys, Catchall>,
+  objectInputType<T, Catchall>
+> {
-  readonly _params!: Params;
+  readonly _unknownKeys!: UnknownKeys;
+  readonly _catchall!: Catchall;
-  get params() {
-    return this._def.params;
-  }
+  // get params() {
+  //   return this._def.params;
+  // }
+
+  //  get t() {
+  //    return this;
+  //  }
-  nonstrict = (): ZodObject<T, SetKey<Params, 'strict', false>> =>
+  strict = (): ZodObject<T, 'strict', Catchall> =>
-      shape: this._def.shape,
-
-      t: z.ZodTypes.object,
-      params: {
-        ...this._params,
-        strict: false,
-      },
-    }) as any;
+      ...this._def,
+      unknownKeys: 'strict',
+    });
+
+  stripUnknown = (): ZodObject<T, 'strip', Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: 'strip',
+    });
+
+  allowUnknown = (): ZodObject<T, 'allow', Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: 'allow',
+    });
+
+  nonstrict = this.allowUnknown;
-  augment = AugmentFactory<ZodObjectDef<T, Params>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, Params>>(this._def);
+  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
-    other: ZodObject<MergeShape, MergeParams>,
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  merge: <Incoming extends AnyZodObject>(
+    other: Incoming,
+  ) => ZodObject<
+    T & Incoming['_shape'],
+    UnknownKeys,
+    Catchall
+    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
+  > = objectUtil.mergeObjects(this as any);
+
+  catchall = <Index extends z.ZodTypeAny>(
+    index: Index,
+  ): ZodObject<
+    T,
+    UnknownKeys,
+    Index
+    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
+  > => {
+    return new ZodObject({
+      ...this._def,
+      catchall: index,
+    });
+  };
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    UnknownKeys,
+    Catchall
+  > => {
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    UnknownKeys,
+    Catchall
+  > => {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
+  partial = (): ZodObject<
+    { [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> },
+    UnknownKeys,
+    Catchall
+  > => {
+  // require: <This extends this>() => makeKeysRequired<This> = () => {
+  //   const newShape: any = {};
+  //   for (const key in this.shape) {
+  //     const val = this.shape[key];
+  //     console.log(`key ${key}:`);
+  //     console.log(val);
+  //     if (val instanceof ZodUnion) {
+  //       console.log(`${key} is union!`);
+  //       const options = (val as ZodUnion<any>)._def.options;
+  //       if (options.length === 2) {
+  //         console.log(`found ${options.length} options`);
+  //         // .length === 2;
+  //         if (options[0] instanceof ZodUndefined) {
+  //           newShape[key] = options[1];
+  //         } else if (options[1] instanceof ZodUndefined) {
+  //           newShape[key] = options[0];
+  //         }
+  //       } else {
+  //         newShape[key] = val;
+  //       }
+  //     } else {
+  //       newShape[key] = val;
+  //     }
+  //   }
+  //   return new ZodObject({
+  //     ...this._def,
+  //     shape: () => newShape,
+  //   }) as any;
+  // };
+
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
-    Params
+    objectUtil.NoNever<
+      {
+        [k in keyof T]: [T[k]['_output']] extends [Scalars] ? T[k] : never;
+      }
+    >,
+    UnknownKeys,
+    Catchall
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
-    Params
+    objectUtil.NoNever<
+      {
+        [k in keyof T]: [T[k]['_output']] extends [Scalars] ? never : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+
-
-      params: {
-        strict: true,
-      },
-    });
-  };
-
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+      unknownKeys: 'allow',
+      catchall: ZodNever.create(),
+      //  params: {
+      //    strict: true,
+      //  },
+    }) as any;
+  };
+
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {
-
-      params: {
-        strict: true,
-      },
-    });
+      unknownKeys: 'allow',
+      catchall: ZodNever.create(),
+    }) as any;","-import { ZodUndefined } from './undefined';
+// import { ZodUndefined } from './undefined';
-import { ZodUnion } from './union';
+// import { ZodUnion } from './union';
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
+type SetKey<
+  Target extends object,
+  Key extends string,
+  Value extends any
+> = objectUtil.Flatten<
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
+type ZodObjectType<
+  T extends z.ZodRawShape,
+  Params extends ZodObjectParams
+> = Params['strict'] extends true
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
+  merge: <
+    MergeShape extends z.ZodRawShape,
+    MergeParams extends ZodObjectParams
+  >(
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  ) => ZodObject<
+    T & MergeShape,
+    objectUtil.MergeObjectParams<Params, MergeParams>
+  > = objectUtil.mergeObjects(this as any);
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    Params
+  > => {
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    Params
+  > => {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
-    const newShape: any = {};
-    for (const key in this.shape) {
-      newShape[key] = this.shape[key].optional();
+  partial = (): ZodObject<
+    { [k in keyof T]: ReturnType<T[k]['optional']> },
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const fieldSchema = this.shape[key];
+      newShape[key] = fieldSchema.isOptional()
+        ? fieldSchema
+        : fieldSchema.optional();
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }
+    >,
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }
+    >,
-        newShape[key] = fieldSchema.deepPartial().optional();
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : (fieldSchema.deepPartial() as any).optional();
-        newShape[key] = this.shape[key].optional();
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : fieldSchema.optional();
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {","-import { ZodUndefined } from './undefined';
+// import { ZodUndefined } from './undefined';
-import { ZodUnion } from './union';
+// import { ZodUnion } from './union';
-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+import { ZodNever } from '..';
+
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-  Def['params']
+  Def['unknownKeys'],
+  Def['catchall']
+type UnknownKeysParam = 'allow' | 'strict' | 'strip';
+
-  Params extends ZodObjectParams = ZodObjectParams
+  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
+  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  // Params extends ZodObjectParams = ZodObjectParams
-  params: Params;
+  catchall: Catchall;
+  unknownKeys: UnknownKeys;
+  // params: Params;
+
+export type baseObjectOutputType<
+  Shape extends z.ZodRawShape
+  // Catchall extends z.ZodTypeAny
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]['_output'];
+    }
+  > //{ [k: string]: Catchall['_output'] }
+>;
+
+export type objectOutputType<
+  Shape extends z.ZodRawShape,
+  Catchall extends z.ZodTypeAny
+> = z.ZodTypeAny extends Catchall
+  ? baseObjectOutputType<Shape>
+  : objectUtil.flatten<
+      baseObjectOutputType<Shape> & { [k: string]: Catchall['_output'] }
+    >;
+
+export type baseObjectInputType<
+  Shape extends z.ZodRawShape
+> = objectUtil.flatten<
+  objectUtil.addQuestionMarks<
+    {
+      [k in keyof Shape]: Shape[k]['_input'];
+    }
+  >
+>;
+
+export type objectInputType<
+  Shape extends z.ZodRawShape,
+  Catchall extends z.ZodTypeAny
+> = z.ZodTypeAny extends Catchall
+  ? baseObjectInputType<Shape>
+  : objectUtil.flatten<
+      baseObjectInputType<Shape> & { [k: string]: Catchall['_input'] }
+    >;
-interface ZodObjectParams {
-  strict: boolean;
-}
+// interface ZodObjectParams {
+//   strict: boolean;
+// }
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
-  { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
->;
-
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
-  ? objectUtil.ObjectType<T>
-  : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
-
+// type SetKey<
+//   Target extends object,
+//   Key extends string,
+//   Value extends any
+// > = objectUtil.Flatten<
+//   { [k in Exclude<keyof Target, Key>]: Target[k] } & { [k in Key]: Value }
+// >;
+
+// type makeKeysRequired<T extends ZodObject<any, any, any>> = T extends ZodObject<
+//   infer U,
+//   infer P,
+//   infer C
+// >
+//   ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P, C>
+//   : never;
+
+// type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+//   ? U extends [infer Y, ZodUndefined]
+//     ? Y
+//     : U extends [ZodUndefined, infer Z]
+//     ? Z
+//     : T
+//   : T;
+
+// type ZodObjectType<
+//   T extends z.ZodRawShape,
+//   Params extends ZodObjectParams
+// > = Params['strict'] extends true
+//   ? objectUtil.ObjectType<T>
+//   : objectUtil.Flatten<objectUtil.ObjectType<T> & { [k: string]: any }>;
+
+export type AnyZodObject = ZodObject<any, any, any>;
+// export type AnyZodObject = ZodObject<
+// z.ZodRawShape,
+// UnknownKeysParam,
+// z.ZodTypeAny
+// >;
-  Params extends ZodObjectParams = { strict: true },
-  Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
-> extends z.ZodType<Type, ZodObjectDef<T, Params>> {
+  UnknownKeys extends UnknownKeysParam = 'allow',
+  Catchall extends z.ZodTypeAny = z.ZodTypeAny
+  // Params extends ZodObjectParams = { strict: true },
+  // Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>
+  // Input extends objectUtil.objectInputType<T> = objectUtil.objectInputType<T>,
+  // Output extends objectUtil.objectOutputType<T> = objectUtil.objectOutputType<T>
+> extends z.ZodType<
+  //  objectUtil.objectOutputType<T, UnknownKeys, Catchall>,
+  objectOutputType<T, Catchall>,
+  ZodObjectDef<T, UnknownKeys, Catchall>,
+  objectInputType<T, Catchall>
+> {
-  readonly _params!: Params;
+  readonly _unknownKeys!: UnknownKeys;
+  readonly _catchall!: Catchall;
-  get params() {
-    return this._def.params;
-  }
+  // get params() {
+  //   return this._def.params;
+  // }
+
+  //  get t() {
+  //    return this;
+  //  }
-  nonstrict = (): ZodObject<T, SetKey<Params, 'strict', false>> =>
+  strict = (): ZodObject<T, 'strict', Catchall> =>
-      shape: this._def.shape,
-
-      t: z.ZodTypes.object,
-      params: {
-        ...this._params,
-        strict: false,
-      },
-    }) as any;
+      ...this._def,
+      unknownKeys: 'strict',
+    });
+
+  stripUnknown = (): ZodObject<T, 'strip', Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: 'strip',
+    });
+
+  allowUnknown = (): ZodObject<T, 'allow', Catchall> =>
+    new ZodObject({
+      ...this._def,
+      unknownKeys: 'allow',
+    });
+
+  nonstrict = this.allowUnknown;
-  augment = AugmentFactory<ZodObjectDef<T, Params>>(this._def);
-  extend = AugmentFactory<ZodObjectDef<T, Params>>(this._def);
+  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
+  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
-    other: ZodObject<MergeShape, MergeParams>,
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  merge: <Incoming extends AnyZodObject>(
+    other: Incoming,
+  ) => ZodObject<
+    T & Incoming['_shape'],
+    UnknownKeys,
+    Catchall
+    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
+  > = objectUtil.mergeObjects(this as any);
+
+  catchall = <Index extends z.ZodTypeAny>(
+    index: Index,
+  ): ZodObject<
+    T,
+    UnknownKeys,
+    Index
+    // objectUtil.MergeObjectParams<Params, MergeUnknownKeys>
+  > => {
+    return new ZodObject({
+      ...this._def,
+      catchall: index,
+    });
+  };
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    UnknownKeys,
+    Catchall
+  > => {
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    UnknownKeys,
+    Catchall
+  > => {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
+  partial = (): ZodObject<
+    { [k in keyof T]: ReturnType<T[k]['optional']> },
+    UnknownKeys,
+    Catchall
+  > => {
-      newShape[key] = this.shape[key].optional();
+      const fieldSchema = this.shape[key];
+      newShape[key] = fieldSchema.isOptional()
+        ? fieldSchema
+        : fieldSchema.optional();
+  // require: <This extends this>() => makeKeysRequired<This> = () => {
+  //   const newShape: any = {};
+  //   for (const key in this.shape) {
+  //     const val = this.shape[key];
+  //     console.log(`key ${key}:`);
+  //     console.log(val);
+  //     if (val instanceof ZodUnion) {
+  //       console.log(`${key} is union!`);
+  //       const options = (val as ZodUnion<any>)._def.options;
+  //       if (options.length === 2) {
+  //         console.log(`found ${options.length} options`);
+  //         // .length === 2;
+  //         if (options[0] instanceof ZodUndefined) {
+  //           newShape[key] = options[1];
+  //         } else if (options[1] instanceof ZodUndefined) {
+  //           newShape[key] = options[0];
+  //         }
+  //       } else {
+  //         newShape[key] = val;
+  //       }
+  //     } else {
+  //       newShape[key] = val;
+  //     }
+  //   }
+  //   return new ZodObject({
+  //     ...this._def,
+  //     shape: () => newShape,
+  //   }) as any;
+  // };
+
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
-    Params
+    objectUtil.NoNever<
+      {
+        [k in keyof T]: [T[k]['_output']] extends [Scalars] ? T[k] : never;
+      }
+    >,
+    UnknownKeys,
+    Catchall
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
-    Params
+    objectUtil.NoNever<
+      {
+        [k in keyof T]: [T[k]['_output']] extends [Scalars] ? never : T[k];
+      }
+    >,
+    UnknownKeys,
+    Catchall
-        newShape[key] = fieldSchema.deepPartial().optional();
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : (fieldSchema.deepPartial() as any).optional();
-        newShape[key] = this.shape[key].optional();
+        newShape[key] = fieldSchema.isOptional()
+          ? fieldSchema
+          : fieldSchema.optional();
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+
-
-      params: {
-        strict: true,
-      },
-    });
-  };
-
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+      unknownKeys: 'allow',
+      catchall: ZodNever.create(),
+      //  params: {
+      //    strict: true,
+      //  },
+    }) as any;
+  };
+
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {
-
-      params: {
-        strict: true,
-      },
-    });
+      unknownKeys: 'allow',
+      catchall: ZodNever.create(),
+    }) as any;"
colinhacks_zod,a6f9fcd7ef950fdc06c9f7fbfec6dd0a1bd69fe9,Merge branch 'first-class-optionals' of git://github.com/sylvanaar/zod into sylvanaar-first-class-optionals,src/parser.ts,-  //       //,"+
+const UNDEFINED = () => require(""./types/undefined"").ZodUndefined.create();
+
+      case z.ZodTypes.optional:
+        try {
+          UNDEFINED().parse(obj, params);
+          break;
+        } catch {}
+
+        try {
+          def.realType.parse(obj, params);
+          break;
+        } catch (err) {
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);          
+        }
+        break;","+
+const UNDEFINED = () => require(""./types/undefined"").ZodUndefined.create();
+
-  //       //
+      case z.ZodTypes.optional:
+        try {
+          UNDEFINED().parse(obj, params);
+          break;
+        } catch {}
+
+        try {
+          def.realType.parse(obj, params);
+          break;
+        } catch (err) {
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);          
+        }
+        break;"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/ZodError.ts,"+  'invalid_intersection_types',
+export interface ZodInvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+}
+
+  | ZodInvalidIntersectionTypesError
-    const errorMessage: string[] = [`${this.errors.length} validation issue(s)`, ''];
+    const errorMessage: string[] = [
+      `${this.errors.length} validation issue(s)`,
+      '',
+    ];
-      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('./index')}`);
+      errorMessage.push(
+        `  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join(
+          './index',
+        )}`,
+      );
-  flatten = (): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  flatten = (): {
+    formErrors: string[];
+    fieldErrors: { [k: string]: string[] };
+  } => {","-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-    const errorMessage: string[] = [`${this.errors.length} validation issue(s)`, ''];
+    const errorMessage: string[] = [
+      `${this.errors.length} validation issue(s)`,
+      '',
+    ];
-      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('./index')}`);
+      errorMessage.push(
+        `  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join(
+          '.',
+        )}`,
+      );
-  flatten = (): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  flatten = (): {
+    formErrors: string[];
+    fieldErrors: { [k: string]: string[] };
+  } => {","+  'invalid_intersection_types',
+}
+
+export interface ZodInvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+  | ZodInvalidIntersectionTypesError
-    Object.setPrototypeOf(this, actualProto);
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(this, actualProto);
+    } else {
+      (this as any).__proto__ = actualProto;
+    }
-    const errorMessage: string[] = [`${this.errors.length} validation issue(s)`, ''];
+    const errorMessage: string[] = [
+      `${this.errors.length} validation issue(s)`,
+      '',
+    ];
-      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('./index')}`);
+      errorMessage.push(
+        `  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join(
+<<<<<<< HEAD
+          './index',
+=======
+          '.',
+>>>>>>> dev
+        )}`,
+      );
-  flatten = (): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  flatten = (): {
+    formErrors: string[];
+    fieldErrors: { [k: string]: string[] };
+  } => {"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/__tests__/error.test.ts,"-test('union smart errors', () => {
+test('union smart errors', async () => {
-  z.union([z.string(), z.number().int()])
+  await z
+    .union([z.string(), z.number().int()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type));
-  z.union([z.string(), z.number()])
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type);
+    });
+  await z
+    .union([z.string(), z.number()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union);
+    });","+    console.log(zerr);
-  expect.assertions(2);
-  z.union([z.string(), z.number().int()])
-    .parseAsync(3.2)
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type));
-  z.union([z.string(), z.number()])
-    .parseAsync(false)
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+  // expect.assertions(2);
+
+  const p1 = z.union([z.string(), z.number().refine(x => x > 0)]).safeParse(-3.2);
+
+  if (p1.success === true) throw new Error();
+  console.log(JSON.stringify(p1.error, null, 2));
+  expect(p1.success).toBe(false);
+  expect(p1.error.errors[0].code).toEqual(ZodErrorCode.custom_error);
+
+  const p2 = z.union([z.string(), z.number()]).safeParse(false);
+  // .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+  if (p2.success === true) throw new Error();
+  expect(p2.success).toBe(false);
+  expect(p2.error.errors[0].code).toEqual(ZodErrorCode.invalid_union);
+
+test('custom path in custom error map', () => {
+  const schema = z.object({
+    items: z.array(z.string()).refine(data => data.length > 3, {
+      path: ['items-too-few'],
+    }),
+  });
+
+  expect.assertions(1);
+  const errorMap: z.ZodErrorMap = error => {
+    expect(error.path.length).toBe(2);
+    return { message: 'doesnt matter' };
+  };
+  schema.safeParse({ items: ['first'] }, { errorMap });
+});","+    console.log(zerr);
-  expect.assertions(2);
-  z.union([z.string(), z.number().int()])
-    .parseAsync(3.2)
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type));
-  z.union([z.string(), z.number()])
-    .parseAsync(false)
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+  // expect.assertions(2);
+
+  const p1 = z
+    .union([z.string(), z.number().refine(x => x > 0)])
+    .safeParse(-3.2);
+
+  if (p1.success === true) throw new Error();
+  console.log(JSON.stringify(p1.error, null, 2));
+  expect(p1.success).toBe(false);
+  expect(p1.error.errors[0].code).toEqual(ZodErrorCode.custom_error);
+
+  const p2 = z.union([z.string(), z.number()]).safeParse(false);
+  // .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+  if (p2.success === true) throw new Error();
+  expect(p2.success).toBe(false);
+  expect(p2.error.errors[0].code).toEqual(ZodErrorCode.invalid_union);
+
+test('custom path in custom error map', () => {
+  const schema = z.object({
+    items: z.array(z.string()).refine(data => data.length > 3, {
+      path: ['items-too-few'],
+    }),
+  });
+
+  expect.assertions(1);
+  const errorMap: z.ZodErrorMap = error => {
+    expect(error.path.length).toBe(2);
+    return { message: 'doesnt matter' };
+  };
+  schema.safeParse({ items: ['first'] }, { errorMap });
+});"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/parser.ts,"-import { ZodDef } from './index';
-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ZodDef } from '.';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const INVALID = Symbol('invalid_data');
-  obj: any,
+  data: any,
+    async: baseParams.async || false,
-    const ctxArg = { data: obj };
+    const ctxArg = { data: data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const parsedType = getParsedType(obj);
-
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  const isPrimitive = typeof obj !== 'object' || obj === null;
-
-  if (schemaSeen) {
-    const found = schemaSeen.objects.find(x => x.data === obj);
-
-    if (found) {
-      if (found.error) {
-        throw found.error;
-      }
-
-      found.times = found.times + 1;
-
-      if (found.times > 2 && !isPrimitive) {
-        return Symbol('recursion depth exceeded.');
-      } else if (found.times > 2) {
-      }
-    } else {
-      //
-      schemaSeen.objects.push(obj);
+  const finder = (arr: any[], checker: (arg: any) => any) => {
+    for (const item of arr) {
+      if (checker(item)) return item;
+    return undefined;
+  };
+
+  const defaultPromise = new PseudoPromise();
+  (defaultPromise as any)._default = true;
+  const RESULT: { data: any; promise: PseudoPromise<any> } = {
+    data,
+    promise: defaultPromise,
+  }; // = defaultReturnValue;
+  params.seen = params.seen || [];
+  params.seen.push({ schema: schemaDef, objects: [] });
+  const schemaSeen = finder(params.seen, x => x.schema === schemaDef); // params.seen.find(x => x.schema === schemaDef)!;
+
+  const objectSeen = finder(schemaSeen.objects, arg => arg.data === data); //.find(x => x.data === data);
+
+  if (objectSeen && def.t !== z.ZodTypes.transformer) {
+    // return objectSeen.promise._cached.value; //.getValue();
+    // return data;
-    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+    schemaSeen.objects.push(RESULT);
-  // const setError = (error: Error) => {
-  //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  //   if (schemaSeen) {
-  //     const found = schemaSeen.objects.find(x => x.data === obj);
-  //     if (found) {
-  //       found.error = error;
-  //     }
-  //   }
-  // };
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
+  // }
-  let returnValue: any = obj;
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  const parsedType = getParsedType(data);
+  console.log(`\nPARSING ${def.t}`);
+  console.log(data);
+  console.log(parsedType);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        // setError(error);
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return PseudoPromise.resolve(INVALID);
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
+        } else {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      for (const key of shapeKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.shape()[key].parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return INVALID;
+          }
+        });
+        // try {
+        //   parsedobject[key] = PseudoPromise.resolve(
+        //     def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] }),
+        //   );
+        // } catch (err) {
+        //   const zerr: ZodError = err;
+        //   error.addErrors(zerr.errors);
+        // }
+      }
+
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            unionErrors.push(err);
+            return PseudoPromise.resolve(INVALID);
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return finder(unionResults, (val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              error.addErrors(err.errors);
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      console.log(`${parsedType} vs ${ZodParsedType.promise}`);
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        })
+        // .then(() => {
+        //   try {
+        //     return def.input.parse(data, params);
+        //   } catch (err) {
+        //     error.addErrors(err.errors);
+        //   }
+        // })
+        .then(inputParseResult => {
+          try {
+            return def.transformer(inputParseResult);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+
+  if (params.async === true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  } else {
+    const SYNC_ERROR =
+      ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    const resolvedValue = RESULT.promise.getValueSync();
+    console.log(`sync parse resolved value:`);
+    console.log(resolvedValue);
+    if (resolvedValue instanceof Promise) {
+      console.log(`found promise in sync parse.`);
+      console.log(def.t);
+
+      if (def.t === z.ZodTypes.transformer) {
+        console.log(def.output._def.t);
+        if (def.output._def.t !== z.ZodTypes.promise) {
+          throw new Error(SYNC_ERROR);
+        }
+      } else if (def.t !== z.ZodTypes.promise) {
+        throw new Error(SYNC_ERROR);
+      } else {
+        //
+      }
+      //  console.log(def.t);
+      // throw new Error(
+      //   ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."",
+      // );
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    if (resolvedValue === INVALID) {
+      throw new ZodError([]).addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          message: 'Invalid',
+        }),
+      );
+    }
+    return resolvedValue as any;
-
-  if (!error.isEmpty) {
-    // setError(error);
-    throw error;
-  }
-
-  return returnValue as any;","+export const find = (arr: any[], checker: (arg: any) => any) => {
+  for (const item of arr) {
+    if (checker(item)) return item;
+  }
+  return undefined;
+};
+
-    const errorArg = { ...errorData, path: params.path };
+    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  const isPrimitive = typeof obj !== 'object' || obj === null;
-
-  if (schemaSeen) {
-    const found = schemaSeen.objects.find(x => x.data === obj);
-
-    if (found) {
-      if (found.error) {
-        throw found.error;
-      }
-
-      found.times = found.times + 1;
-
-      if (found.times > 2 && !isPrimitive) {
-        return Symbol('recursion depth exceeded.');
-      } else if (found.times > 2) {
+  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
+  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
+
+  if (isNonprimitive) {
+    if (schemaSeen) {
+      const found = find(schemaSeen.objects, x => x.data === obj);
+
+      if (found) {
+        if (found.error) {
+          throw found.error;
+        }
+
+        found.times = found.times + 1;
+
+        if (found.times > 5 && isNonprimitive) {
+          return Symbol('recursion depth exceeded.');
+        } else if (found.times > 2) {
+        }
+      } else {
+        //
+        schemaSeen.objects.push(obj);
-      //
-      schemaSeen.objects.push(obj);
+      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-  } else {
-    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-            options: Object.values(def.values),
+            options: util.getValues(def.values),","-import { ZodDef } from './index';
-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ZodDef } from '.';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
+export const find = (arr: any[], checker: (arg: any) => any) => {
+  for (const item of arr) {
+    if (checker(item)) return item;
+  }
+  return undefined;
+};
+
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const INVALID = Symbol('invalid_data');
-  obj: any,
+  data: any,
+    async: baseParams.async || false,
-    const errorArg = { ...errorData, path: params.path };
-    const ctxArg = { data: obj };
+    const errorArg = {
+      ...errorData,
+      path: [...params.path, ...(errorData.path || [])],
+    };
+    const ctxArg = { data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const parsedType = getParsedType(obj);
-
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  const isPrimitive = typeof obj !== 'object' || obj === null;
-
-  if (schemaSeen) {
-    const found = schemaSeen.objects.find(x => x.data === obj);
-
-    if (found) {
-      if (found.error) {
-        throw found.error;
-      }
-
-      found.times = found.times + 1;
-
-      if (found.times > 2 && !isPrimitive) {
-        return Symbol('recursion depth exceeded.');
-      } else if (found.times > 2) {
+  const parsedType = getParsedType(data);
+
+  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
+  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
+
+  if (isNonprimitive) {
+    if (schemaSeen) {
+      const found = find(schemaSeen.objects, x => x.data === data);
+
+      if (found) {
+        if (found.error) {
+          throw found.error;
+        }
+
+        found.times = found.times + 1;
+
+        if (found.times > 5 && isNonprimitive) {
+          return Symbol('recursion depth exceeded.');
+        } else if (found.times > 2) {
+        }
+      } else {
+        //
+        schemaSeen.objects.push(data);
-      //
-      schemaSeen.objects.push(obj);
+      params.seen.push({
+        schema: schemaDef,
+        objects: [{ data: data, error: undefined, times: 1 }],
+      });
-  } else {
-    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-  // const setError = (error: Error) => {
-  //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  //   if (schemaSeen) {
-  //     const found = schemaSeen.objects.find(x => x.data === obj);
-  //     if (found) {
-  //       found.error = error;
-  //     }
-  //   }
-  // };
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
+  // }
-  let returnValue: any = obj;
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  // const parsedType = getParsedType(data);
+  console.log(`\nPARSING ${def.t}`);
+  console.log(data);
+  console.log(parsedType);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        // setError(error);
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return PseudoPromise.resolve(INVALID);
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
+        } else {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      for (const key of shapeKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.shape()[key].parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return INVALID;
+          }
+        });
+        // try {
+        //   parsedobject[key] = PseudoPromise.resolve(
+        //     def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] }),
+        //   );
+        // } catch (err) {
+        //   const zerr: ZodError = err;
+        //   error.addErrors(zerr.errors);
+        // }
+      }
+
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            unionErrors.push(err);
+            return PseudoPromise.resolve(INVALID);
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return finder(unionResults, (val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        // setError(error);
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              error.addErrors(err.errors);
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
-            options: Object.values(def.values),
+            options: util.getValues(def.values),
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      console.log(`${parsedType} vs ${ZodParsedType.promise}`);
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        })
+        // .then(() => {
+        //   try {
+        //     return def.input.parse(data, params);
+        //   } catch (err) {
+        //     error.addErrors(err.errors);
+        //   }
+        // })
+        .then(inputParseResult => {
+          try {
+            return def.transformer(inputParseResult);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+
+  if (params.async === true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  } else {
+    const SYNC_ERROR =
+      ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    const resolvedValue = RESULT.promise.getValueSync();
+    console.log(`sync parse resolved value:`);
+    console.log(resolvedValue);
+    if (resolvedValue instanceof Promise) {
+      console.log(`found promise in sync parse.`);
+      console.log(def.t);
+
+      if (def.t === z.ZodTypes.transformer) {
+        console.log(def.output._def.t);
+        if (def.output._def.t !== z.ZodTypes.promise) {
+          throw new Error(SYNC_ERROR);
+        }
+      } else if (def.t !== z.ZodTypes.promise) {
+        throw new Error(SYNC_ERROR);
+      } else {
+        //
+      }
+      //  console.log(def.t);
+      // throw new Error(
+      //   ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."",
+      // );
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    if (resolvedValue === INVALID) {
+      throw new ZodError([]).addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          message: 'Invalid',
+        }),
+      );
+    }
+    return resolvedValue as any;
-
-  if (!error.isEmpty) {
-    // setError(error);
-    throw error;
-  }
-
-  return returnValue as any;"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/playground.ts,"-// import * as z from '.';
-
-// try {
-//   z.string().parse(1345);
-// } catch (err) {
-//   console.log(err.message);
-//   console.log(err.flatten());
-// }","-// import * as z from '.';
+import * as z from '.';
-// try {
-//   z.string().parse(1345);
-// } catch (err) {
-//   console.log(err.message);
-//   console.log(err.flatten());
-// }
+const userUpdateSchema = z.object({
+  password: z
+    .string()
+    .min(6)
+    .optional(),
+});
+
+console.log(userUpdateSchema.parse({}));","-// import * as z from '.';
+<<<<<<< HEAD
+=======
+import * as z from '.';
-// try {
-//   z.string().parse(1345);
-// } catch (err) {
-//   console.log(err.message);
-//   console.log(err.flatten());
-// }
+const userUpdateSchema = z.object({
+  password: z
+    .string()
+    .min(6)
+    .optional(),
+});
+
+console.log(userUpdateSchema.parse({}));
+>>>>>>> dev"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/types/object.ts,"-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
+type SetKey<
+  Target extends object,
+  Key extends string,
+  Value extends any
+> = objectUtil.Flatten<
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<
+  infer U,
+  infer P
+>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+type ZodObjectType<
+  T extends z.ZodRawShape,
+  Params extends ZodObjectParams
+> = Params['strict'] extends true
+  get t() {
+    return this;
+  }
+
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
+  merge: <
+    MergeShape extends z.ZodRawShape,
+    MergeParams extends ZodObjectParams
+  >(
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  ) => ZodObject<
+    T & MergeShape,
+    objectUtil.MergeObjectParams<Params, MergeParams>
+  > = objectUtil.mergeObjects(this as any);
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    Params
+  > => {
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    Params
+  > => {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
+  partial = (): ZodObject<
+    { [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> },
+    Params
+  > => {
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }
+    >,
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }
+    >,
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {","-      if (!Object.keys(mask).includes(key)) {
+      if (Object.keys(mask).indexOf(key) === -1) {","-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
+type SetKey<
+  Target extends object,
+  Key extends string,
+  Value extends any
+> = objectUtil.Flatten<
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<
+  infer U,
+  infer P
+>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+type ZodObjectType<
+  T extends z.ZodRawShape,
+  Params extends ZodObjectParams
+> = Params['strict'] extends true
+  get t() {
+    return this;
+  }
+
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
+  merge: <
+    MergeShape extends z.ZodRawShape,
+    MergeParams extends ZodObjectParams
+  >(
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  ) => ZodObject<
+    T & MergeShape,
+    objectUtil.MergeObjectParams<Params, MergeParams>
+  > = objectUtil.mergeObjects(this as any);
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    Params
+  > => {
-  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    Params
+  > => {
-      if (!Object.keys(mask).includes(key)) {
+      if (Object.keys(mask).indexOf(key) === -1) {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
+  partial = (): ZodObject<
+    { [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> },
+    Params
+  > => {
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }
+    >,
-    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }
+    >,
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {"
colinhacks_zod,202fb5c00a933e6a533b61b687f2fa4e43177912,trying to fix merge conflicts,src/types/union.ts,"-  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]] = [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+  T extends [z.ZodTypeAny, ...z.ZodTypeAny[]] = [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
-export class ZodUnion<T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]> extends z.ZodType<
+export class ZodUnion<T extends [z.ZodTypeAny, ...z.ZodTypeAny[]]> extends z.ZodType<
+  get options(): T {
+    return this._def.options;
+  }
-  static create = <T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T): ZodUnion<T> => {
+  static create = <T extends [z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T): ZodUnion<T> => {","-  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]] = [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]] = [
+    z.ZodTypeAny,
+    z.ZodTypeAny,
+    ...z.ZodTypeAny[],
+  ]
-export class ZodUnion<T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]> extends z.ZodType<
-  T[number]['_type'],
-  ZodUnionDef<T>
-> {
+export class ZodUnion<
+  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+> extends z.ZodType<T[number]['_type'], ZodUnionDef<T>> {
-  toJSON = () => ({
+  toJSON = (): object => ({
-  static create = <T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T): ZodUnion<T> => {
+  static create = <T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(
+    types: T,
+  ): ZodUnion<T> => {","-  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]] = [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+<<<<<<< HEAD
+  T extends [z.ZodTypeAny, ...z.ZodTypeAny[]] = [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+=======
+  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]] = [
+    z.ZodTypeAny,
+    z.ZodTypeAny,
+    ...z.ZodTypeAny[],
+  ]
+>>>>>>> dev
-export class ZodUnion<T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]> extends z.ZodType<
+<<<<<<< HEAD
+export class ZodUnion<T extends [z.ZodTypeAny, ...z.ZodTypeAny[]]> extends z.ZodType<
+  get options(): T {
+    return this._def.options;
+  }
+=======
+export class ZodUnion<
+  T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
+> extends z.ZodType<T[number]['_type'], ZodUnionDef<T>> {
+>>>>>>> dev
-  toJSON = () => ({
+  toJSON = (): object => ({
-  static create = <T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T): ZodUnion<T> => {
+<<<<<<< HEAD
+  static create = <T extends [z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T): ZodUnion<T> => {
+=======
+  static create = <T extends [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(
+    types: T,
+  ): ZodUnion<T> => {
+>>>>>>> dev"
colinhacks_zod,0cd69b6303d231580a75544d1b7378bf785b3414,Merge branch 'master' into dev,src/helpers/util.ts,"-  export type AssertEqual<T, Expected> = T extends Expected ? (Expected extends T ? true : false) : false;
+  export type AssertEqual<T, Expected> = T extends Expected
+    ? Expected extends T
+      ? true
+      : false
+    : false;
-  export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
+  export type MakePartial<T, K extends keyof T> = Omit<T, K> &
+    Partial<Pick<T, K>>;
-  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(items: U): { [k in U[number]]: k } => {
+  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(
+    items: U,
+  ): { [k in U[number]]: k } => {
-    const validKeys = Object.keys(obj).filter((k: any) => typeof obj[obj[k]] !== 'number');
+    const validKeys = Object.keys(obj).filter(
+      (k: any) => typeof obj[obj[k]] !== 'number',
+    );
+
+  export const objectValues = (obj: any) => {
+    return Object.keys(obj).map(function(e) {
+      return obj[e];
+    });
+  };","-    return Object.values(filtered);
+    return getValues(filtered);
+  };
+
+  export const getValues = (obj: any) => {
+    return Object.keys(obj).map(function(e) {
+      return obj[e];
+    });","-  export type AssertEqual<T, Expected> = T extends Expected ? (Expected extends T ? true : false) : false;
+  export type AssertEqual<T, Expected> = T extends Expected
+    ? Expected extends T
+      ? true
+      : false
+    : false;
-  export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
+  export type MakePartial<T, K extends keyof T> = Omit<T, K> &
+    Partial<Pick<T, K>>;
-  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(items: U): { [k in U[number]]: k } => {
+  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(
+    items: U,
+  ): { [k in U[number]]: k } => {
-    const validKeys = Object.keys(obj).filter((k: any) => typeof obj[obj[k]] !== 'number');
+    const validKeys = Object.keys(obj).filter(
+      (k: any) => typeof obj[obj[k]] !== 'number',
+    );
-    return Object.values(filtered);
+    return getValues(filtered);
+  };
+
+  export const getValues = (obj: any) => {
+    return Object.keys(obj).map(function(e) {
+      return obj[e];
+    });
+  };
+
+  export const objectValues = (obj: any) => {
+    return Object.keys(obj).map(function(e) {
+      return obj[e];
+    });"
colinhacks_zod,0cd69b6303d231580a75544d1b7378bf785b3414,Merge branch 'master' into dev,src/parser.ts,-  //       //,"+export const find = (arr: any[], checker: (arg: any) => any) => {
+  for (const item of arr) {
+    if (checker(item)) return item;
+  }
+  return undefined;
+};
+
-    const errorArg = { ...errorData, path: params.path };
+    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  const isPrimitive = typeof obj !== 'object' || obj === null;
-
-  if (schemaSeen) {
-    const found = schemaSeen.objects.find(x => x.data === obj);
-
-    if (found) {
-      if (found.error) {
-        throw found.error;
-      }
-
-      found.times = found.times + 1;
-
-      if (found.times > 2 && !isPrimitive) {
-        return Symbol('recursion depth exceeded.');
-      } else if (found.times > 2) {
+  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
+  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
+
+  if (isNonprimitive) {
+    if (schemaSeen) {
+      const found = find(schemaSeen.objects, x => x.data === obj);
+
+      if (found) {
+        if (found.error) {
+          throw found.error;
+        }
+
+        found.times = found.times + 1;
+
+        if (found.times > 5 && isNonprimitive) {
+          return Symbol('recursion depth exceeded.');
+        } else if (found.times > 2) {
+        }
+      } else {
+        //
+        schemaSeen.objects.push(obj);
-      //
-      schemaSeen.objects.push(obj);
+      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-  } else {
-    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-            options: Object.values(def.values),
+            options: util.getValues(def.values),","+export const find = (arr: any[], checker: (arg: any) => any) => {
+  for (const item of arr) {
+    if (checker(item)) return item;
+  }
+  return undefined;
+};
+
-    const errorArg = { ...errorData, path: params.path };
+    const errorArg = { ...errorData, path: [...params.path, ...(errorData.path || [])] };
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  const isPrimitive = typeof obj !== 'object' || obj === null;
-
-  if (schemaSeen) {
-    const found = schemaSeen.objects.find(x => x.data === obj);
-
-    if (found) {
-      if (found.error) {
-        throw found.error;
-      }
-
-      found.times = found.times + 1;
-
-      if (found.times > 2 && !isPrimitive) {
-        return Symbol('recursion depth exceeded.');
-      } else if (found.times > 2) {
+  const schemaSeen = find(params.seen, x => x.schema === schemaDef);
+  const isNonprimitive = ['array', 'object'].indexOf(parsedType) !== -1;
+
+  if (isNonprimitive) {
+    if (schemaSeen) {
+      const found = find(schemaSeen.objects, x => x.data === obj);
+
+      if (found) {
+        if (found.error) {
+          throw found.error;
+        }
+
+        found.times = found.times + 1;
+
+        if (found.times > 5 && isNonprimitive) {
+          return Symbol('recursion depth exceeded.');
+        } else if (found.times > 2) {
+        }
+      } else {
+        //
+        schemaSeen.objects.push(obj);
-      //
-      schemaSeen.objects.push(obj);
+      params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-  } else {
-    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
-  //       //
-            options: Object.values(def.values),
+            options: util.getValues(def.values),"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,package.json,"-  ""version"": ""1.10.1"",
+  ""version"": ""1.11.0-alpha.6"",","-  ""version"": ""1.10.1"",
+  ""version"": ""1.11.0"",
+    ""buildall"": ""yarn add typescript@3.4 && yarn build && yarn add typescript@3.5 && yarn build && yarn add typescript@3.6 && yarn build && yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4 && yarn build && yarn add typescript@3.3 && yarn build"",","-  ""version"": ""1.10.1"",
+  ""version"": ""1.11.0"",
+    ""buildall"": ""yarn add typescript@3.4 && yarn build && yarn add typescript@3.5 && yarn build && yarn add typescript@3.6 && yarn build && yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4 && yarn build && yarn add typescript@3.3 && yarn build"","
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/ZodError.ts,"+  'invalid_intersection_types',
+
+const flatten = (err: ZodError): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  const fieldErrors: any = {};
+  const formErrors: string[] = [];
+  for (const sub of err.errors) {
+    if (sub.path.length > 0) {
+      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
+      fieldErrors[sub.path[0]].push(sub.message);
+    } else {
+      formErrors.push(sub.message);
+    }
+  }
+  return {
+    formErrors,
+    fieldErrors,
+  };
+};
+interface InvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+}
+
+  | InvalidIntersectionTypesError
-  get formErrors(): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } {
-    const fieldErrors: any = {};
-    const formErrors: string[] = [];
-    for (const sub of this.errors) {
-      if (sub.path.length > 0) {
-        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
-        fieldErrors[sub.path[0]].push(sub.message);
-      } else {
-        formErrors.push(sub.message);
-      }
-    }
-    return { formErrors, fieldErrors };
+  get formErrors() {
+    return flatten(this);
+
+  flatten = () => flatten(this);","-  code: ZodErrorCode;
+  // code: ZodErrorCode;
-interface InvalidTypeError extends ZodSuberrorBase {
+export interface ZodInvalidTypeError extends ZodSuberrorBase {
-interface NonEmptyArrayIsEmptyError extends ZodSuberrorBase {
+export interface ZodNonEmptyArrayIsEmptyError extends ZodSuberrorBase {
-interface UnrecognizedKeysError extends ZodSuberrorBase {
+export interface ZodUnrecognizedKeysError extends ZodSuberrorBase {
-interface InvalidUnionError extends ZodSuberrorBase {
+export interface ZodInvalidUnionError extends ZodSuberrorBase {
-interface InvalidLiteralValueError extends ZodSuberrorBase {
+export interface ZodInvalidLiteralValueError extends ZodSuberrorBase {
-interface InvalidEnumValueError extends ZodSuberrorBase {
+export interface ZodInvalidEnumValueError extends ZodSuberrorBase {
-  options: string[];
+  options: (string | number)[];
-interface InvalidArgumentsError extends ZodSuberrorBase {
+export interface ZodInvalidArgumentsError extends ZodSuberrorBase {
-interface InvalidReturnTypeError extends ZodSuberrorBase {
+export interface ZodInvalidReturnTypeError extends ZodSuberrorBase {
-interface InvalidDateError extends ZodSuberrorBase {
+export interface ZodInvalidDateError extends ZodSuberrorBase {
-interface InvalidStringError extends ZodSuberrorBase {
+export type StringValidation = 'email' | 'url' | 'uuid' | 'regex';
+
+export interface ZodInvalidStringError extends ZodSuberrorBase {
-  validation: 'email' | 'url' | 'uuid';
+  validation: StringValidation;
-interface TooSmallError extends ZodSuberrorBase {
+export interface ZodTooSmallError extends ZodSuberrorBase {
-interface TooBigError extends ZodSuberrorBase {
+export interface ZodTooBigError extends ZodSuberrorBase {
-export interface CustomError extends ZodSuberrorBase {
+export interface ZodCustomError extends ZodSuberrorBase {
-  | InvalidTypeError
-  | NonEmptyArrayIsEmptyError
-  | UnrecognizedKeysError
-  | InvalidUnionError
-  | InvalidLiteralValueError
-  | InvalidEnumValueError
-  | InvalidArgumentsError
-  | InvalidReturnTypeError
-  | InvalidDateError
-  | InvalidStringError
-  | TooSmallError
-  | TooBigError
-  | CustomError;
+  | ZodInvalidTypeError
+  | ZodNonEmptyArrayIsEmptyError
+  | ZodUnrecognizedKeysError
+  | ZodInvalidUnionError
+  | ZodInvalidLiteralValueError
+  | ZodInvalidEnumValueError
+  | ZodInvalidArgumentsError
+  | ZodInvalidReturnTypeError
+  | ZodInvalidDateError
+  | ZodInvalidStringError
+  | ZodTooSmallError
+  | ZodTooBigError
+  | ZodCustomError;
+    // return JSON.stringify(this.errors, null, 2);
-      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('.')}`);
+      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('./index')}`);
-    //   return path.length ? `${path.join('.')}: ${message}` : `${message}`;
+    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-  get formErrors(): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } {
+  flatten = (): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  };
+
+  get formErrors() {
+    return this.flatten();","+  'invalid_intersection_types',
-  code: ZodErrorCode;
+  // code: ZodErrorCode;
-interface InvalidTypeError extends ZodSuberrorBase {
+export interface ZodInvalidTypeError extends ZodSuberrorBase {
-interface NonEmptyArrayIsEmptyError extends ZodSuberrorBase {
+export interface ZodNonEmptyArrayIsEmptyError extends ZodSuberrorBase {
-interface UnrecognizedKeysError extends ZodSuberrorBase {
+export interface ZodUnrecognizedKeysError extends ZodSuberrorBase {
-interface InvalidUnionError extends ZodSuberrorBase {
+export interface ZodInvalidUnionError extends ZodSuberrorBase {
-interface InvalidLiteralValueError extends ZodSuberrorBase {
+export interface ZodInvalidLiteralValueError extends ZodSuberrorBase {
-interface InvalidEnumValueError extends ZodSuberrorBase {
+export interface ZodInvalidEnumValueError extends ZodSuberrorBase {
-  options: string[];
+  options: (string | number)[];
-interface InvalidArgumentsError extends ZodSuberrorBase {
+export interface ZodInvalidArgumentsError extends ZodSuberrorBase {
-interface InvalidReturnTypeError extends ZodSuberrorBase {
+export interface ZodInvalidReturnTypeError extends ZodSuberrorBase {
-interface InvalidDateError extends ZodSuberrorBase {
+export interface ZodInvalidDateError extends ZodSuberrorBase {
-interface InvalidStringError extends ZodSuberrorBase {
+export type StringValidation = 'email' | 'url' | 'uuid' | 'regex';
+
+export interface ZodInvalidStringError extends ZodSuberrorBase {
-  validation: 'email' | 'url' | 'uuid';
+  validation: StringValidation;
-interface TooSmallError extends ZodSuberrorBase {
+export interface ZodTooSmallError extends ZodSuberrorBase {
-interface TooBigError extends ZodSuberrorBase {
+export interface ZodTooBigError extends ZodSuberrorBase {
-export interface CustomError extends ZodSuberrorBase {
+export interface ZodInvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+}
+
+export interface ZodCustomError extends ZodSuberrorBase {
-  | InvalidTypeError
-  | NonEmptyArrayIsEmptyError
-  | UnrecognizedKeysError
-  | InvalidUnionError
-  | InvalidLiteralValueError
-  | InvalidEnumValueError
-  | InvalidArgumentsError
-  | InvalidReturnTypeError
-  | InvalidDateError
-  | InvalidStringError
-  | TooSmallError
-  | TooBigError
-  | CustomError;
+  | ZodInvalidTypeError
+  | ZodNonEmptyArrayIsEmptyError
+  | ZodUnrecognizedKeysError
+  | ZodInvalidUnionError
+  | ZodInvalidLiteralValueError
+  | ZodInvalidEnumValueError
+  | ZodInvalidArgumentsError
+  | ZodInvalidReturnTypeError
+  | ZodInvalidDateError
+  | ZodInvalidStringError
+  | ZodTooSmallError
+  | ZodTooBigError
+  | ZodInvalidIntersectionTypesError
+  | ZodCustomError;
-    const errorMessage: string[] = [`${this.errors.length} validation issue(s)`, ''];
+    // return JSON.stringify(this.errors, null, 2);
+    const errorMessage: string[] = [
+      `${this.errors.length} validation issue(s)`,
+      '',
+    ];
-      errorMessage.push(`  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join('.')}`);
+      errorMessage.push(
+        `  Issue #${this.errors.indexOf(err)}: ${err.code} at ${err.path.join(
+          './index',
+        )}`,
+      );
-    //   return path.length ? `${path.join('.')}: ${message}` : `${message}`;
+    //   return path.length ? `${path.join('./index')}: ${message}` : `${message}`;
-  get formErrors(): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } {
+  flatten = (): {
+    formErrors: string[];
+    fieldErrors: { [k: string]: string[] };
+  } => {
+  };
+
+  get formErrors() {
+    return this.flatten();"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/codegen.test.ts,"-import { crazySchema } from './complex.test';
-  gen.generate(crazySchema);
-  console.log(gen.dump());
+  gen.generate(z.string());
+  gen.dump();","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
-import { crazySchema } from './complex.test';
+import * as z from '../index';
+import { crazySchema } from '../crazySchema';
-  console.log(gen.dump());
+  gen.dump();"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/error.test.ts,"-test('union smart errors', () => {
+test('union smart errors', async () => {
-  z.union([z.string(), z.number().int()])
+  await z
+    .union([z.string(), z.number().int()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type));
-  z.union([z.string(), z.number()])
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type);
+    });
+  await z
+    .union([z.string(), z.number()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union);
+    });","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
+import * as z from '../index';
-test('union smart errors', () => {
+test('union smart errors', async () => {
-  z.union([z.string(), z.number().int()])
+  await z
+    .union([z.string(), z.number().int()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type));
-  z.union([z.string(), z.number()])
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_type);
+    });
+  await z
+    .union([z.string(), z.number()])
-    .catch(err => expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union));
+    .catch(err => {
+      expect(err.errors[0].code).toEqual(ZodErrorCode.invalid_union);
+    });"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/instanceof.test.ts,"-test('instanceof', () => {
+test('instanceof', async () => {
-  TestSchema.parseAsync(12).catch(err => {
+
+  await TestSchema.parseAsync(12).catch(err => {
-  SubtestSchema.parseAsync(12).catch(err => {
+  await SubtestSchema.parseAsync(12).catch(err => {","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
+import * as z from '../index';
-test('instanceof', () => {
+test('instanceof', async () => {
-  TestSchema.parseAsync(12).catch(err => {
+
+  await TestSchema.parseAsync(12).catch(err => {
-  SubtestSchema.parseAsync(12).catch(err => {
+  await SubtestSchema.parseAsync(12).catch(err => {"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/promise.test.ts,"-import { ZodError } from '../ZodError';
-  const t1: util.AssertEqual<promSchemaType, Promise<{ name: string; age: number }>> = true;
+  const t1: util.AssertEqual<
+    promSchemaType,
+    Promise<{ name: string; age: number }>
+  > = true;
-test('promise parsing success', () => {
-  promSchema.parse(Promise.resolve({ name: 'Bobby', age: 10 }));
+test('promise parsing success', async () => {
+  return await promSchema.parse(Promise.resolve({ name: 'Bobby', age: 10 }));
-test('promise parsing fail', () => {
+test('promise parsing fail', async () => {
-  expect(bad).rejects;
+  return await expect(bad).rejects;
-test('promise parsing fail 2', () => {
-  const failPromise = promSchema.parse(Promise.resolve({ name: 'Bobby', age: '10' }));
-  failPromise.catch(err => {
-    expect(err instanceof ZodError).toEqual(true);
-  });
+test('promise parsing fail 2', async () => {
+  const failPromise = promSchema.parse(
+    Promise.resolve({ name: 'Bobby', age: '10' }),
+  );
+  return await expect(failPromise).rejects;
+// test('sync promise parsing', () => {
+//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();
+// });
+
-test('async function pass', () => {
+test('async function pass', async () => {
-  expect(validatedFunction()).resolves;
+  return await expect(validatedFunction()).resolves;
+
+test('async promise parsing', () => {
+  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
+  expect(res).toBeInstanceOf(Promise);
+});","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
+import * as z from '../index';
-import { ZodError } from '../ZodError';
-  const t1: util.AssertEqual<promSchemaType, Promise<{ name: string; age: number }>> = true;
+  const t1: util.AssertEqual<
+    promSchemaType,
+    Promise<{ name: string; age: number }>
+  > = true;
-test('promise parsing success', () => {
-  promSchema.parse(Promise.resolve({ name: 'Bobby', age: 10 }));
+test('promise parsing success', async () => {
+  return await promSchema.parse(Promise.resolve({ name: 'Bobby', age: 10 }));
-test('promise parsing fail', () => {
+test('promise parsing fail', async () => {
-  expect(bad).rejects;
+  return await expect(bad).rejects;
-test('promise parsing fail 2', () => {
-  const failPromise = promSchema.parse(Promise.resolve({ name: 'Bobby', age: '10' }));
-  failPromise.catch(err => {
-    expect(err instanceof ZodError).toEqual(true);
-  });
+test('promise parsing fail 2', async () => {
+  const failPromise = promSchema.parse(
+    Promise.resolve({ name: 'Bobby', age: '10' }),
+  );
+  return await expect(failPromise).rejects;
+// test('sync promise parsing', () => {
+//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();
+// });
+
-test('async function pass', () => {
+test('async function pass', async () => {
-  expect(validatedFunction()).resolves;
+  return await expect(validatedFunction()).resolves;
+
+test('async promise parsing', () => {
+  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
+  expect(res).toBeInstanceOf(Promise);
+});"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/recursive.test.ts,"-import * as z from '../index';
+// import * as z from '../index';
-interface A {
-  val: number;
-  b: B;
-}
+test('recursion', () => {});
-interface B {
-  val: number;
-  a: A;
-}
+// interface A {
+//   val: number;
+//   b: B;
+// }
-const A: z.ZodType<A> = z.late.object(() => ({
-  val: z.number(),
-  b: B,
-}));
+// interface B {
+//   val: number;
+//   a: A;
+// }
-const B: z.ZodType<B> = z.late.object(() => ({
-  val: z.number(),
-  a: A,
-}));
+// const A: z.ZodType<A> = z.late.object(() => ({
+//   val: z.number(),
+//   b: B,
+// }));
-const a: any = { val: 1 };
-const b: any = { val: 2 };
-a.b = b;
-b.a = a;
+// const B: z.ZodType<B> = z.late.object(() => ({
+//   val: z.number(),
+//   a: A,
+// }));
-test('valid check', () => {
-  A.parse(a);
-  B.parse(b);
-});
+// const a: any = { val: 1 };
+// const b: any = { val: 2 };
+// a.b = b;
+// b.a = a;
-test('masking check', () => {
-  const FragmentOnA = z
-    .object({
-      val: z.number(),
-      b: z
-        .object({
-          val: z.number(),
-          a: z
-            .object({
-              val: z.number(),
-            })
-            .nonstrict(),
-        })
-        .nonstrict(),
-    })
-    .nonstrict();
+// test('valid check', () => {
+//   A.parse(a);
+//   B.parse(b);
+// });
-  const fragment = FragmentOnA.parse(a);
-  fragment;
-});
+// test('masking check', () => {
+//   const FragmentOnA = z
+//     .object({
+//       val: z.number(),
+//       b: z
+//         .object({
+//           val: z.number(),
+//           a: z
+//             .object({
+//               val: z.number(),
+//             })
+//             .nonstrict(),
+//         })
+//         .nonstrict(),
+//     })
+//     .nonstrict();
-test('invalid check', () => {
-  expect(() => A.parse({} as any)).toThrow();
-});
+//   const fragment = FragmentOnA.parse(a);
+//   fragment;
+// });
-test('toJSON throws', () => {
-  const checker = () => A.toJSON();
-  expect(checker).toThrow();
-});
+// test('invalid check', () => {
+//   expect(() => A.parse({} as any)).toThrow();
+// });
-test('schema getter', () => {
-  (A as z.ZodLazy<any>).schema;
-});
+// test('toJSON throws', () => {
+//   const checker = () => A.toJSON();
+//   expect(checker).toThrow();
+// });
-test('self recursion', () => {
-  interface Category {
-    name: string;
-    subcategories: Category[];
-  }
+// test('schema getter', () => {
+//   (A as z.ZodLazy<any>).schema;
+// });
-  const Category: z.Schema<Category> = z.late.object(() => ({
-    name: z.string(),
-    subcategories: z.array(Category),
-  }));
+// test('self recursion', () => {
+//   interface Category {
+//     name: string;
+//     subcategories: Category[];
+//   }
-  const untypedCategory: any = {
-    name: 'Category A',
-  };
-  // creating a cycle
-  untypedCategory.subcategories = [untypedCategory];
-  Category.parse(untypedCategory);
-});
+//   const Category: z.Schema<Category> = z.late.object(() => ({
+//     name: z.string(),
+//     subcategories: z.array(Category),
+//   }));
-test('self recursion with base type', () => {
-  const BaseCategory = z.object({
-    name: z.string(),
-  });
-  type BaseCategory = z.infer<typeof BaseCategory>;
+//   const untypedCategory: any = {
+//     name: 'Category A',
+//   };
+//   // creating a cycle
+//   untypedCategory.subcategories = [untypedCategory];
+//   Category.parse(untypedCategory);
+// });
-  type Category = BaseCategory & { subcategories: Category[] };
+// test('self recursion with base type', () => {
+//   const BaseCategory = z.object({
+//     name: z.string(),
+//   });
+//   type BaseCategory = z.infer<typeof BaseCategory>;
-  const Category: z.Schema<Category> = z.late
-    .object(() => ({
-      subcategories: z.array(Category),
-    }))
-    .extend({
-      name: z.string(),
-    });
+//   type Category = BaseCategory & { subcategories: Category[] };
-  const untypedCategory: any = {
-    name: 'Category A',
-  };
-  // creating a cycle
-  untypedCategory.subcategories = [untypedCategory];
-  Category.parse(untypedCategory); // parses successfully
-});
+//   const Category: z.Schema<Category> = z.late
+//     .object(() => ({
+//       subcategories: z.array(Category),
+//     }))
+//     .extend({
+//       name: z.string(),
+//     });
+
+//   const untypedCategory: any = {
+//     name: 'Category A',
+//   };
+//   // creating a cycle
+//   untypedCategory.subcategories = [untypedCategory];
+//   Category.parse(untypedCategory); // parses successfully
+// });","+
+test('repeated parsing', () => {
+  const extensions = z.object({
+    name: z.string(),
+  });
+
+  const dog = z.object({
+    extensions,
+  });
+
+  const cat = z.object({
+    extensions,
+  });
+
+  const animal = z.union([dog, cat]);
+
+  // it should output type error because name is ought to be type of string
+  expect(() => animal.parse({ extensions: { name: 123 } })).toThrow;
+});
+
+test('repeated errors', () => {
+  const Shape = z.array(
+    z.object({
+      name: z.string().nonempty(),
+      value: z.string().nonempty(),
+    }),
+  );
+
+  const data = [
+    {
+      name: 'Name 1',
+      value: 'Value',
+    },
+    {
+      name: '',
+      value: 'Value',
+    },
+    {
+      name: '',
+      value: '',
+    },
+  ];
+
+  try {
+    Shape.parse(data);
+  } catch (e) {
+    if (e instanceof z.ZodError) {
+      expect(e.errors.length).toEqual(3);
+    }
+  }
+});
+
+test('unions of object', () => {
+  const base = z.object({
+    id: z.string(),
+  });
+
+  const type1 = base.merge(
+    z.object({
+      type: z.literal('type1'),
+    }),
+  );
+
+  const type2 = base.merge(
+    z.object({
+      type: z.literal('type2'),
+    }),
+  );
+
+  const union1 = z.union([type1, type2]);
+  const union2 = z.union([type2, type1]);
+
+  const value1 = {
+    type: 'type1',
+  };
+
+  const value2 = {
+    type: 'type2',
+  };
+
+  expect(type1.check(value1)).toEqual(false);
+  expect(union1.check(value1)).toEqual(false);
+  expect(union2.check(value1)).toEqual(false);
+  expect(type2.check(value2)).toEqual(false);
+  expect(union1.check(value2)).toEqual(false);
+  expect(union2.check(value2)).toEqual(false);
+});","-import * as z from '../index';
+test('', () => {});
+// import * as z from '../index';
-interface A {
-  val: number;
-  b: B;
-}
+// interface A {
+//   val: number;
+//   b: B;
+// }
-interface B {
-  val: number;
-  a: A;
-}
+// interface B {
+//   val: number;
+//   a: A;
+// }
-const A: z.ZodType<A> = z.late.object(() => ({
-  val: z.number(),
-  b: B,
-}));
+// const A: z.ZodType<A> = z.late.object(() => ({
+//   val: z.number(),
+//   b: B,
+// }));
-const B: z.ZodType<B> = z.late.object(() => ({
-  val: z.number(),
-  a: A,
-}));
+// const B: z.ZodType<B> = z.late.object(() => ({
+//   val: z.number(),
+//   a: A,
+// }));
-const a: any = { val: 1 };
-const b: any = { val: 2 };
-a.b = b;
-b.a = a;
+// const a: any = { val: 1 };
+// const b: any = { val: 2 };
+// a.b = b;
+// b.a = a;
-test('valid check', () => {
-  A.parse(a);
-  B.parse(b);
-});
+// test('valid check', () => {
+//   A.parse(a);
+//   B.parse(b);
+// });
-test('masking check', () => {
-  const FragmentOnA = z
-    .object({
-      val: z.number(),
-      b: z
-        .object({
-          val: z.number(),
-          a: z
-            .object({
-              val: z.number(),
-            })
-            .nonstrict(),
-        })
-        .nonstrict(),
-    })
-    .nonstrict();
+// test('masking check', () => {
+//   const FragmentOnA = z
+//     .object({
+//       val: z.number(),
+//       b: z
+//         .object({
+//           val: z.number(),
+//           a: z
+//             .object({
+//               val: z.number(),
+//             })
+//             .nonstrict(),
+//         })
+//         .nonstrict(),
+//     })
+//     .nonstrict();
-  const fragment = FragmentOnA.parse(a);
-  fragment;
-});
+//   const fragment = FragmentOnA.parse(a);
+//   fragment;
+// });
-test('invalid check', () => {
-  expect(() => A.parse({} as any)).toThrow();
-});
+// test('invalid check', () => {
+//   expect(() => A.parse({} as any)).toThrow();
+// });
-test('toJSON throws', () => {
-  const checker = () => A.toJSON();
-  expect(checker).toThrow();
-});
+// test('toJSON throws', () => {
+//   const checker = () => A.toJSON();
+//   expect(checker).toThrow();
+// });
-test('schema getter', () => {
-  (A as z.ZodLazy<any>).schema;
-});
+// test('schema getter', () => {
+//   (A as z.ZodLazy<any>).schema;
+// });
-test('self recursion', () => {
-  interface Category {
-    name: string;
-    subcategories: Category[];
-  }
+// test('self recursion', () => {
+//   interface Category {
+//     name: string;
+//     subcategories: Category[];
+//   }
-  const Category: z.Schema<Category> = z.late.object(() => ({
-    name: z.string(),
-    subcategories: z.array(Category),
-  }));
+//   const Category: z.Schema<Category> = z.late.object(() => ({
+//     name: z.string(),
+//     subcategories: z.array(Category),
+//   }));
-  const untypedCategory: any = {
-    name: 'Category A',
-  };
-  // creating a cycle
-  untypedCategory.subcategories = [untypedCategory];
-  Category.parse(untypedCategory);
-});
+//   const untypedCategory: any = {
+//     name: 'Category A',
+//   };
+//   // creating a cycle
+//   untypedCategory.subcategories = [untypedCategory];
+//   Category.parse(untypedCategory);
+// });
-test('self recursion with base type', () => {
-  const BaseCategory = z.object({
-    name: z.string(),
-  });
-  type BaseCategory = z.infer<typeof BaseCategory>;
+// test('self recursion with base type', () => {
+//   const BaseCategory = z.object({
+//     name: z.string(),
+//   });
+//   type BaseCategory = z.infer<typeof BaseCategory>;
-  type Category = BaseCategory & { subcategories: Category[] };
+//   type Category = BaseCategory & { subcategories: Category[] };
-  const Category: z.Schema<Category> = z.late
-    .object(() => ({
-      subcategories: z.array(Category),
-    }))
-    .extend({
-      name: z.string(),
-    });
+//   const Category: z.Schema<Category> = z.late
+//     .object(() => ({
+//       subcategories: z.array(Category),
+//     }))
+//     .extend({
+//       name: z.string(),
+//     });
-  const untypedCategory: any = {
-    name: 'Category A',
-  };
-  // creating a cycle
-  untypedCategory.subcategories = [untypedCategory];
-  Category.parse(untypedCategory); // parses successfully
-});
+//   const untypedCategory: any = {
+//     name: 'Category A',
+//   };
+//   // creating a cycle
+//   untypedCategory.subcategories = [untypedCategory];
+//   Category.parse(untypedCategory); // parses successfully
+// });
+
+// test('repeated parsing', () => {
+//   const extensions = z.object({
+//     name: z.string(),
+//   });
+
+//   const dog = z.object({
+//     extensions,
+//   });
+
+//   const cat = z.object({
+//     extensions,
+//   });
+
+//   const animal = z.union([dog, cat]);
+
+//   // it should output type error because name is ought to be type of string
+//   expect(() => animal.parse({ extensions: { name: 123 } })).toThrow;
+// });
+
+// test('repeated errors', () => {
+//   const Shape = z.array(
+//     z.object({
+//       name: z.string().nonempty(),
+//       value: z.string().nonempty(),
+//     }),
+//   );
+
+//   const data = [
+//     {
+//       name: 'Name 1',
+//       value: 'Value',
+//     },
+//     {
+//       name: '',
+//       value: 'Value',
+//     },
+//     {
+//       name: '',
+//       value: '',
+//     },
+//   ];
+
+//   try {
+//     Shape.parse(data);
+//   } catch (e) {
+//     if (e instanceof z.ZodError) {
+//       expect(e.errors.length).toEqual(3);
+//     }
+//   }
+// });
+
+// test('unions of object', () => {
+//   const base = z.object({
+//     id: z.string(),
+//   });
+
+//   const type1 = base.merge(
+//     z.object({
+//       type: z.literal('type1'),
+//     }),
+//   );
+
+//   const type2 = base.merge(
+//     z.object({
+//       type: z.literal('type2'),
+//     }),
+//   );
+
+//   const union1 = z.union([type1, type2]);
+//   const union2 = z.union([type2, type1]);
+
+//   const value1 = {
+//     type: 'type1',
+//   };
+
+//   const value2 = {
+//     type: 'type2',
+//   };
+
+//   expect(type1.check(value1)).toEqual(false);
+//   expect(union1.check(value1)).toEqual(false);
+//   expect(union2.check(value1)).toEqual(false);
+//   expect(type2.check(value2)).toEqual(false);
+//   expect(union1.check(value2)).toEqual(false);
+//   expect(union2.check(value2)).toEqual(false);
+// });"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/refine.test.ts,"-  const obj3 = obj2.refine(data => data.first || data.second, 'Either first or second should be filled in.');
+  const obj3 = obj2.refine(
+    data => data.first || data.second,
+    'Either first or second should be filled in.',
+  );
-    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+    .refine(
+      data => data.password === data.confirmPassword,
+      'Both password and confirmation must match',
+    );
-test('custom path', () => {
-  z.object({
-    password: z.string(),
-    confirm: z.string(),
-  })
+test('custom path', async () => {
+  expect.assertions(1);
+  await z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
-      console.log(JSON.stringify(err, null, 2));","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
+import * as z from '../index';
-  const obj3 = obj2.refine(data => data.first || data.second, 'Either first or second should be filled in.');
+  const obj3 = obj2.refine(
+    data => data.first || data.second,
+    'Either first or second should be filled in.',
+  );
-    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+    .refine(
+      data => data.password === data.confirmPassword,
+      'Both password and confirmation must match',
+    );
-test('custom path', () => {
-  z.object({
-    password: z.string(),
-    confirm: z.string(),
-  })
+test('custom path', async () => {
+  expect.assertions(1);
+  await z
+    .object({
+      password: z.string(),
+      confirm: z.string(),
+    })
-      console.log(JSON.stringify(err, null, 2));"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/__tests__/validations.test.ts,"-test('array min', () => {
-  z.array(z.string())
+test('array min', async () => {
+  expect.assertions(1);
+  await z
+    .array(z.string())
-test('array max', () => {
-  z.array(z.string())
+test('array max', async () => {
+  expect.assertions(1);
+  await z
+    .array(z.string())
-test('string min', () => {
-  z.string()
+test('string min', async () => {
+  expect.assertions(1);
+  await z
+    .string()
-test('string max', () => {
-  z.string()
+test('string max', async () => {
+  expect.assertions(1);
+  await z
+    .string()
-test('number min', () => {
-  z.number()
+test('number min', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number max', () => {
-  z.number()
+test('number max', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number nonnegative', () => {
-  z.number()
+test('number nonnegative', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number nonpositive', () => {
-  z.number()
+test('number nonpositive', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number negative', () => {
-  z.number()
+test('number negative', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number positive', () => {
-  z.number()
+test('number positive', async () => {
+  expect.assertions(1);
+  await z
+    .number()","-import * as z from '..';
+import * as z from '../index';","-import * as z from '..';
+import * as z from '../index';
-test('array min', () => {
-  z.array(z.string())
+test('array min', async () => {
+  expect.assertions(1);
+  await z
+    .array(z.string())
-test('array max', () => {
-  z.array(z.string())
+test('array max', async () => {
+  expect.assertions(1);
+  await z
+    .array(z.string())
-test('string min', () => {
-  z.string()
+test('string min', async () => {
+  expect.assertions(1);
+  await z
+    .string()
-test('string max', () => {
-  z.string()
+test('string max', async () => {
+  expect.assertions(1);
+  await z
+    .string()
-test('number min', () => {
-  z.number()
+test('number min', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number max', () => {
-  z.number()
+test('number max', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number nonnegative', () => {
-  z.number()
+test('number nonnegative', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number nonpositive', () => {
-  z.number()
+test('number nonpositive', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number negative', () => {
-  z.number()
+test('number negative', async () => {
+  expect.assertions(1);
+  await z
+    .number()
-test('number positive', () => {
-  z.number()
+test('number positive', async () => {
+  expect.assertions(1);
+  await z
+    .number()"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/codegen.ts,"+      case z.ZodTypes.transformer:
+        return this.setType(id, `{[k:string]: ${this.generate(def.output).id}}`);","-import * as z from '.';
+import * as z from './index';
+      case z.ZodTypes.nativeEnum:
+        // const lazyType = def.getter();
+        return this.setType(id, 'asdf');","-import * as z from '.';
+import * as z from './index';
+      case z.ZodTypes.transformer:
+        return this.setType(id, `{[k:string]: ${this.generate(def.output).id}}`);
+      case z.ZodTypes.nativeEnum:
+        // const lazyType = def.getter();
+        return this.setType(id, 'asdf');"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/defaultErrorMap.ts,"+    case ZodErrorCode.invalid_intersection_types:
+      message = `Intersections only support objects`;
+      break;","-      message = `Invalid ${error.validation}`;
+      if (error.validation !== 'regex') message = `Invalid ${error.validation}`;
+      else message = 'Invalid';","-      message = `Invalid ${error.validation}`;
+      if (error.validation !== 'regex') message = `Invalid ${error.validation}`;
+      else message = 'Invalid';
+    case ZodErrorCode.invalid_intersection_types:
+      message = `Intersections only support objects`;
+      break;"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/helpers/objectUtil.ts,"+  type ObjectIntersectionInput<T extends ZodRawShape> = AddQuestionMarks<
+    {
+      [k in keyof T]: T[k]['_input'];
+    }
+  >;
+  type ObjectIntersectionOutput<T extends ZodRawShape> = AddQuestionMarks<
+    {
+      [k in keyof T]: T[k]['_input'];
+    }
+  >;
+  export type ObjectTypeInput<T extends ZodRawShape> = FlattenObject<ObjectIntersectionInput<NoNever<T>>>;
+  export type ObjectTypeOutput<T extends ZodRawShape> = FlattenObject<ObjectIntersectionOutput<NoNever<T>>>;","-  export type NoNeverKeys<T extends object> = {
-    [k in keyof T]: T[k] extends never ? never : k;
+  export type NoNeverKeys<T extends ZodRawShape> = {
+    [k in keyof T]: [T[k]] extends [never] ? never : k;
-  export type NoNever<T extends object> = {
-    [k in NoNeverKeys<T>]: T[k];
-  };
+  export type NoNever<T extends ZodRawShape> = Identity<
+    {
+      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
+    }
+  >;
-  export type ObjectType<T extends ZodRawShape> = FlattenObject<ObjectIntersection<NoNever<T>>>;
+  export type ObjectType<T extends ZodRawShape> = FlattenObject<ObjectIntersection<T>>;","-  export type MergeObjectParams<First extends ZodObjectParams, Second extends ZodObjectParams> = {
-    strict: First['strict'] extends false ? false : Second['strict'] extends false ? false : true;
+  export type MergeObjectParams<
+    First extends ZodObjectParams,
+    Second extends ZodObjectParams
+  > = {
+    strict: First['strict'] extends false
+      ? false
+      : Second['strict'] extends false
+      ? false
+      : true;
+  type ObjectIntersectionInput<T extends ZodRawShape> = AddQuestionMarks<
+    {
+      [k in keyof T]: T[k]['_input'];
+    }
+  >;
+  type ObjectIntersectionOutput<T extends ZodRawShape> = AddQuestionMarks<
+    {
+      [k in keyof T]: T[k]['_input'];
+    }
+  >;
-  type FlattenObject<T extends ZodRawShape> = Identity<{ [k in keyof T]: T[k] }>;
+  type FlattenObject<T extends ZodRawShape> = Identity<
+    { [k in keyof T]: T[k] }
+  >;
-  export type NoNeverKeys<T extends object> = {
-    [k in keyof T]: T[k] extends never ? never : k;
+  export type NoNeverKeys<T extends ZodRawShape> = {
+    [k in keyof T]: [T[k]] extends [never] ? never : k;
-  export type NoNever<T extends object> = {
-    [k in NoNeverKeys<T>]: T[k];
-  };
+  export type NoNever<T extends ZodRawShape> = Identity<
+    {
+      [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;
+    }
+  >;
-  export type ObjectType<T extends ZodRawShape> = FlattenObject<ObjectIntersection<NoNever<T>>>;
+  export type ObjectType<T extends ZodRawShape> = FlattenObject<
+    ObjectIntersection<T>
+  >;
+  export type ObjectTypeInput<T extends ZodRawShape> = FlattenObject<
+    ObjectIntersectionInput<T>
+  >;
+  export type ObjectTypeOutput<T extends ZodRawShape> = FlattenObject<
+    ObjectIntersectionOutput<T>
+  >;
-  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(first: U, second: T): T & U => {
+  // export type ObjectType<T extends ZodRawShape> = FlattenObject<ObjectIntersection<T>>;
+
+  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
+    first: U,
+    second: T,
+  ): T & U => {
-  export const mergeObjects = <First extends ZodObject<any, any, any>>(first: First) => <
-    Second extends ZodObject<any, any, any>
-  >(
+  export const mergeObjects = <First extends ZodObject<any, any, any>>(
+    first: First,
+  ) => <Second extends ZodObject<any, any, any>>("
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/index.ts,"-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+import { ZodTransformer, ZodTransformerDef } from './types/transformer';
+import { TypeOf, input, output, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
-  | ZodPromiseDef;
+  | ZodPromiseDef
+  | ZodTransformerDef;
+const transformerType = ZodTransformer.create;
+  transformerType as transformer,
+  ZodTransformer,
-export { TypeOf, TypeOf as infer };
+export { TypeOf, TypeOf as infer, input, output };","+import { ZodNativeEnum, ZodNativeEnumDef } from './types/nativeEnum';
-import { ZodError, ZodErrorCode } from './ZodError';
+// import { ZodError, ZodErrorCode, ZodInvalidTypeError,
+// ZodNonEmptyArrayIsEmptyError,
+// ZodUnrecognizedKeysError,
+// ZodInvalidUnionError,
+// ZodInvalidLiteralValueError,
+// ZodInvalidEnumValueError,
+// ZodInvalidArgumentsError,
+// ZodInvalidReturnTypeError,
+// ZodInvalidDateError,
+// ZodInvalidStringError,
+// ZodTooSmallError,
+// ZodTooBigError,
+// ZodCustomError } from './ZodError';
+  | ZodNativeEnumDef
+const nativeEnumType = ZodNativeEnum.create;
-const custom = <T>(check: (data: unknown) => any, params?: Parameters<ZodAny['refine']>[1]): ZodType<T> =>
+export const custom = <T>(check: (data: unknown) => any, params?: Parameters<ZodAny['refine']>[1]): ZodType<T> =>
+  nativeEnumType as nativeEnum,
+  ZodNativeEnum,
-  ZodError,
-  ZodErrorCode,
+export * from './ZodError';
+","+import { ZodNativeEnum, ZodNativeEnumDef } from './types/nativeEnum';
-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
-import { ZodError, ZodErrorCode } from './ZodError';
+import { ZodTransformer, ZodTransformerDef } from './types/transformer';
+import {
+  TypeOf,
+  input,
+  output,
+  ZodType,
+  ZodTypeAny,
+  ZodTypeDef,
+  ZodTypes,
+} from './types/base';
+// import { ZodError, ZodErrorCode } from './ZodError';
-  | ZodPromiseDef;
+  | ZodPromiseDef
+  | ZodTransformerDef
+  | ZodNativeEnumDef;
+const nativeEnumType = ZodNativeEnum.create;
+const transformerType = ZodTransformer.create;
-const custom = <T>(check: (data: unknown) => any, params?: Parameters<ZodAny['refine']>[1]): ZodType<T> =>
-  anyType().refine(check, params);
+export const custom = <T>(
+  check: (data: unknown) => any,
+  params?: Parameters<ZodAny['refine']>[1],
+): ZodType<T> => anyType().refine(check, params);
-  params: Parameters<ZodAny['refine']>[1] = { message: `Input not instance of ${cls.name}` },
+  params: Parameters<ZodAny['refine']>[1] = {
+    message: `Input not instance of ${cls.name}`,
+  },
+  nativeEnumType as nativeEnum,
+  transformerType as transformer,
+  ZodNativeEnum,
+  ZodTransformer,
-  ZodError,
-  ZodErrorCode,
-export { TypeOf, TypeOf as infer };
+export { TypeOf, TypeOf as infer, input, output };
+export * from './ZodError';"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/parser.ts,"-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: any[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const INVALID = Symbol('invalid_data');
-  obj: any,
+  data: any,
+    async: baseParams.async || false,
-    const ctxArg = { data: obj };
+    const ctxArg = { data: data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  if (schemaSeen) {
-    if (schemaSeen.objects.indexOf(obj) !== -1) {
-      return obj;
-    } else {
-      schemaSeen.objects.push(obj);
-    }
+  const defaultPromise = new PseudoPromise();
+  (defaultPromise as any)._default = true;
+  const RESULT: { data: any; promise: PseudoPromise<any> } = {
+    data,
+    promise: defaultPromise,
+  }; // = defaultReturnValue;
+  params.seen = params.seen || [];
+  params.seen.push({ schema: schemaDef, objects: [] });
+  const schemaSeen = params.seen.find(x => x.schema === schemaDef)!;
+
+  const objectSeen = schemaSeen.objects.find(x => x.data === data);
+
+  if (objectSeen && def.t !== z.ZodTypes.transformer) {
+    // return objectSeen.promise._cached.value; //.getValue();
+    // return data;
-    params.seen.push({ schema: schemaDef, objects: [obj] });
+    schemaSeen.objects.push(RESULT);
+
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
-  let returnValue: any = obj;
-  const parsedType = getParsedType(obj);
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  const parsedType = getParsedType(data);
+  console.log(`\nPARSING ${def.t}`);
+  console.log(data);
+  console.log(parsedType);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return PseudoPromise.resolve(INVALID);
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
+        } else {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      for (const key of shapeKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.shape()[key].parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return INVALID;
+          }
+        });
+        // try {
+        //   parsedobject[key] = PseudoPromise.resolve(
+        //     def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] }),
+        //   );
+        // } catch (err) {
+        //   const zerr: ZodError = err;
+        //   error.addErrors(zerr.errors);
+        // }
+      }
+
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            unionErrors.push(err);
+            return PseudoPromise.resolve(INVALID);
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return unionResults.find((val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              error.addErrors(err.errors);
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
-        console.log('NAN');
+      if (isNaN(data.getTime())) {
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      console.log(`${parsedType} vs ${ZodParsedType.promise}`);
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        })
+        // .then(() => {
+        //   try {
+        //     return def.input.parse(data, params);
+        //   } catch (err) {
+        //     error.addErrors(err.errors);
+        //   }
+        // })
+        .then(inputParseResult => {
+          try {
+            return def.transformer(inputParseResult);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+
+  if (params.async === true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  } else {
+    const SYNC_ERROR =
+      ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    const resolvedValue = RESULT.promise.getValueSync();
+    console.log(`sync parse resolved value:`);
+    console.log(resolvedValue);
+    if (resolvedValue instanceof Promise) {
+      console.log(`found promise in sync parse.`);
+      console.log(def.t);
+
+      if (def.t === z.ZodTypes.transformer) {
+        console.log(def.output._def.t);
+        if (def.output._def.t !== z.ZodTypes.promise) {
+          throw new Error(SYNC_ERROR);
+        }
+      } else if (def.t !== z.ZodTypes.promise) {
+        throw new Error(SYNC_ERROR);
+      } else {
+        //
+      }
+      //  console.log(def.t);
+      // throw new Error(
+      //   ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."",
+      // );
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    if (resolvedValue === INVALID) {
+      throw new ZodError([]).addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          message: 'Invalid',
+        }),
+      );
+    }
+    return resolvedValue as any;
-
-  if (!error.isEmpty) {
-    throw error;
-  }
-
-  return returnValue as any;","-import { ZodDef } from '.';
+import { ZodDef } from './index';
-  seen?: { schema: any; objects: any[] }[];
+  seen?: { schema: any; objects: { data: any; error?: any; times: number }[] }[];
-  if (data === null) return 'null';
+    if (!data) return 'null';
+  const parsedType = getParsedType(obj);
+
+  const isPrimitive = typeof obj !== 'object' || obj === null;
+
-    if (schemaSeen.objects.indexOf(obj) !== -1) {
-      return obj;
+    const found = schemaSeen.objects.find(x => x.data === obj);
+
+    if (found) {
+      if (found.error) {
+        throw found.error;
+      }
+
+      found.times = found.times + 1;
+
+      if (found.times > 2 && !isPrimitive) {
+        return Symbol('recursion depth exceeded.');
+      } else if (found.times > 2) {
+      }
+      //
-    params.seen.push({ schema: schemaDef, objects: [obj] });
-  }
-  // }
+    params.seen.push({ schema: schemaDef, objects: [{ data: obj, error: undefined, times: 1 }] });
+  }
+
+  // const setError = (error: Error) => {
+  //   const schemaSeen = params.seen.find(x => x.schema === schemaDef);
+  //   if (schemaSeen) {
+  //     const found = schemaSeen.objects.find(x => x.data === obj);
+  //     if (found) {
+  //       found.error = error;
+  //     }
+  //   }
+  // };
-  const parsedType = getParsedType(obj);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+        // setError(error);
+    case z.ZodTypes.nativeEnum:
+      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: Object.values(def.values),
+          }),
+        );
+      }
+      break;
+        // setError(error);
+        // setError(error);
+        // setError(error);
-        console.log('NAN');
+        // setError(error);
+        // setError(error);
+    // setError(error);","-import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import {
+  ZodError,
+  ZodErrorCode,
+  ZodSuberror,
+  ZodSuberrorOptionalMessage,
+} from './ZodError';
+import { PseudoPromise } from './PseudoPromise';
-  seen?: { schema: any; objects: any[] }[];
+  seen?: {
+    schema: any;
+    objects: { data: any; promise: PseudoPromise<any> }[];
+  }[];
+  async?: boolean;
-  if (data === null) return 'null';
-    if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
+    if (!data) return 'null';
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+    ) {
-type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+type stripPath<T extends object> = T extends any
+  ? util.OmitKeys<T, 'path'>
+  : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & {
+  path?: (string | number)[];
+};
+
+const INVALID = Symbol('invalid_data');
-  obj: any,
+  data: any,
+    async: baseParams.async || false,
-    const ctxArg = { data: obj };
+    const ctxArg = { data: data };
-        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+        : defaultErrorMap(errorArg, {
+            ...ctxArg,
+            defaultError: `Invalid value.`,
+          });
-        errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError: defaultError.message }).message,
+        errorData.message ||
+        params.errorMap(errorArg, {
+          ...ctxArg,
+          defaultError: defaultError.message,
+        }).message,
-  const schemaSeen = params.seen.find(x => x.schema === schemaDef);
-  if (schemaSeen) {
-    if (schemaSeen.objects.indexOf(obj) !== -1) {
-      return obj;
-    } else {
-      schemaSeen.objects.push(obj);
-    }
+  const defaultPromise = new PseudoPromise();
+  (defaultPromise as any)._default = true;
+  const RESULT: { data: any; promise: PseudoPromise<any> } = {
+    data,
+    promise: defaultPromise,
+  }; // = defaultReturnValue;
+  params.seen = params.seen || [];
+  params.seen.push({ schema: schemaDef, objects: [] });
+  const schemaSeen = params.seen.find(x => x.schema === schemaDef)!;
+
+  const objectSeen = schemaSeen.objects.find(x => x.data === data);
+
+  if (objectSeen && def.t !== z.ZodTypes.transformer) {
+    // return objectSeen.promise._cached.value; //.getValue();
+    // return data;
-    params.seen.push({ schema: schemaDef, objects: [obj] });
+    schemaSeen.objects.push(RESULT);
+
+  //  else {
+  //  params.seen.push({ schema: schemaDef, objects: [{ data, promise: PROM }] });
+  // }
-  let returnValue: any = obj;
-  const parsedType = getParsedType(obj);
+  // const defaultRESULT.promise = Symbol('return_value');
+  //  let returnValue: PseudoPromise<any>; // = defaultReturnValue;
+  const parsedType = getParsedType(data);
+  console.log(`\nPARSING ${def.t}`);
+  console.log(data);
+  console.log(parsedType);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.string, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.string,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        throw error;
-      }
-      if (Number.isNaN(obj)) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: ZodParsedType.nan }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (Number.isNaN(data)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: ZodParsedType.nan,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.number, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.number,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.boolean, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.boolean,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.undefined, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.undefined,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.null, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.null,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.undefined && parsedType !== ZodParsedType.null) {
-        error.addError(
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.void, received: parsedType }),
-        );
-        throw error;
-      }
+      if (
+        parsedType !== ZodParsedType.undefined &&
+        parsedType !== ZodParsedType.null
+      ) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.void,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        throw error;
-      }
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
-        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
-        throw error;
-      }
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      });
-      if (!error.isEmpty) {
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
+        error.addError(
+          makeError({ code: ZodErrorCode.nonempty_array_is_empty }),
+        );
+        throw error;
+      }
+      // RESULT.promise = (data as any[]).map((item, i) => {
+      //   try {
+      //     return def.type.parse(item, { ...params, path: [...params.path, i] });
+      //   } catch (err) {
+      //     const zerr: ZodError = err;
+      //     error.addErrors(zerr.errors);
+      //   }
+      // });
+      RESULT.promise = PseudoPromise.all(
+        (data as any[]).map((item, i) => {
+          try {
+            return PseudoPromise.resolve(
+              def.type.parse(item, {
+                ...params,
+                path: [...params.path, i],
+              }),
+            );
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return PseudoPromise.resolve(INVALID);
+          }
+        }),
+      );
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.object, received: parsedType }),
-        );
-        throw error;
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.object,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+
+      const objectPromises: { [k: string]: PseudoPromise<any> } = {};
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
-          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.unrecognized_keys,
+              keys: extraKeys,
+            }),
+          );
+        } else {
+          for (const key of extraKeys) {
+            objectPromises[key] = PseudoPromise.resolve(data[key]);
+          }
-      for (const key in shape) {
-        try {
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          const zerr: ZodError = err;
-          error.addErrors(zerr.errors);
-        }
-      }
+      for (const key of shapeKeys) {
+        objectPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.shape()[key].parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            const zerr: ZodError = err;
+            error.addErrors(zerr.errors);
+            return INVALID;
+          }
+        });
+        // try {
+        //   parsedobject[key] = PseudoPromise.resolve(
+        //     def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] }),
+        //   );
+        // } catch (err) {
+        //   const zerr: ZodError = err;
+        //   error.addErrors(zerr.errors);
+        // }
+      }
+
+      RESULT.promise = PseudoPromise.object(objectPromises);
+      // let parsedUnion: any;
-      for (const option of def.options) {
-        try {
-          option.parse(obj, params);
-          isValid = true;
-        } catch (err) {
-          unionErrors.push(err);
-        }
-      }
-
-      if (!isValid) {
-        const filteredErrors = unionErrors.filter(err => {
-          return err.errors[0].code !== 'invalid_type';
+      // const INVALID = Symbol('invalid_data');
+      RESULT.promise = PseudoPromise.all(
+        def.options.map(opt => {
+          try {
+            const unionValueProm = PseudoPromise.resolve(
+              opt.parse(data, params),
+            );
+            isValid = true;
+            return unionValueProm;
+            // return parsed;
+          } catch (err) {
+            unionErrors.push(err);
+            return PseudoPromise.resolve(INVALID);
+          }
+          // }
+        }),
+      )
+        .then((unionResults: any[]) => {
+          return unionResults.find((val: any) => val !== INVALID);
+        })
+        .then((unionResult: any) => {
+          // const unionResults: any[] = _unionResults;
+          if (!isValid) {
+            const filteredErrors = unionErrors.filter(err => {
+              return err.errors[0].code !== 'invalid_type';
+            });
+            if (filteredErrors.length === 1) {
+              error.addErrors(filteredErrors[0].errors);
+            } else {
+              error.addError(
+                makeError({
+                  code: ZodErrorCode.invalid_union,
+                  unionErrors: unionErrors,
+                }),
+              );
+            }
+            return INVALID;
+          }
+
+          return unionResult;
-        if (filteredErrors.length === 1) {
-          error.addErrors(filteredErrors[0].errors);
+      // .then(unionResults => (unionResults as any).find((res: any) => res !== INVALID));
+      // for (const option of def.options) {
+      //   try {
+      //     parsedUnion = option.parse(data, params);
+      //     isValid = true;
+      //     break;
+      //   } catch (err) {
+      //     unionErrors.push(err);
+      //   }
+      // }
+
+      // if (!isValid) {
+      //   const filteredErrors = unionErrors.filter(err => {
+      //     return err.errors[0].code !== 'invalid_type';
+      //   });
+      //   if (filteredErrors.length === 1) {
+      //     error.addErrors(filteredErrors[0].errors);
+      //   } else {
+      //     error.addError(
+      //       makeError({
+      //         code: ZodErrorCode.invalid_union,
+      //         unionErrors: unionErrors,
+      //       }),
+      //     );
+      //   }
+      // }
+      // RESULT.promise = parsedUnion;
+      break;
+    case z.ZodTypes.intersection:
+      // let parsedIntersection:any;
+      // let parsedLeft: any;
+      // let parsedRight: any;
+      // RESULT.promise = PseudoPromise.resolve(data);
+      RESULT.promise = PseudoPromise.all([
+        new PseudoPromise().then(() => {
+          try {
+            return def.left.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+        new PseudoPromise().then(() => {
+          try {
+            return def.right.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+            return INVALID;
+          }
+        }),
+      ]).then(([parsedLeft, parsedRight]: any) => {
+        if (parsedLeft === INVALID || parsedRight === INVALID) return INVALID;
+
+        const parsedLeftType = getParsedType(parsedLeft);
+        const parsedRightType = getParsedType(parsedRight);
+
+        if (parsedLeft === parsedRight) {
+          return parsedLeft;
+        } else if (
+          parsedLeftType === ZodParsedType.object &&
+          parsedRightType === ZodParsedType.object
+        ) {
+          return { ...parsedLeft, ...parsedRight };
-              code: ZodErrorCode.invalid_union,
-              unionErrors: unionErrors,
+              code: ZodErrorCode.invalid_intersection_types,
-      }
-      break;
-    case z.ZodTypes.intersection:
-      try {
-        def.left.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
-
-      try {
-        def.right.parse(obj, params);
-      } catch (err) {
-        error.addErrors(err.errors);
-      }
+      });
-          makeError({ code: ZodErrorCode.invalid_type, expected: ZodParsedType.array, received: parsedType }),
-        );
-        throw error;
-      }
-      if (obj.length > def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_big, maximum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      } else if (obj.length < def.items.length) {
-        error.addError(
-          makeError({ code: ZodErrorCode.too_small, minimum: def.items.length, inclusive: true, type: 'array' }),
-        );
-      }
-
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
-      for (const index in tupleData) {
-        const item = tupleData[index];
-        const itemParser = def.items[index];
-        try {
-          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ZodParsedType.array,
+            received: parsedType,
+          }),
+        );
+        // setError(error);
+        throw error;
+      }
+      if (data.length > def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_big,
+            maximum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      } else if (data.length < def.items.length) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.too_small,
+            minimum: def.items.length,
+            inclusive: true,
+            type: 'array',
+          }),
+        );
+      }
+
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      // const parsedTuple: any = [];
+      // const tuplePromises: PseudoPromise[] = [];
+
+      RESULT.promise = PseudoPromise.all(
+        tupleData.map((item, index) => {
+          const itemParser = def.items[index];
+          return new PseudoPromise().then(() => {
+            try {
+              return itemParser.parse(item, {
+                ...params,
+                path: [...params.path, index],
+              });
+            } catch (err) {
+              error.addErrors(err.errors);
+            }
+          });
+        }),
+      );
+      // for (const index in tupleData) {
+      //   const item = tupleData[index];
+      //   const itemParser = def.items[index];
+      //   tuplePromises.push(
+      //     new PseudoPromise().then(() => {
+      //       try {
+      //         return itemParser.parse(item, { ...params, path: [...params.path, index] });
+      //       } catch (err) {
+      //         error.addErrors(err.errors);
+      //       }
+      //     }),
+      //   );
+      //   // parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+      // }
+      // RESULT.promise = parsedTuple;
-      lazySchema.parse(obj, params);
+      RESULT.promise = PseudoPromise.resolve(lazySchema.parse(data, params));
-      if (obj !== def.value) {
-        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
-      }
-      break;
-
+      if (data !== def.value) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_literal_value,
+            expected: def.value,
+          }),
+        );
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      RESULT.promise = PseudoPromise.resolve(data);
+      break;
+    case z.ZodTypes.nativeEnum:
+      if (util.getValidEnumValues(def.values).indexOf(data) === -1) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: Object.values(def.values),
+          }),
+        );
+      }
+        // setError(error);
-          def.args.parse(args as any);
+          def.args.parse(args as any, params);
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-          return def.returns.parse(result);
+          return def.returns.parse(result, params);
-      return validatedFunc;
+      RESULT.promise = PseudoPromise.resolve(validatedFunc);
+      // return validatedFunc;
+      break;
-        throw error;
-      }
-
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
-        } catch (err) {
-          error.addErrors(err.errors);
-        }
-      }
+        // setError(error);
+        throw error;
+      }
+
+      const parsedRecordPromises: { [k: string]: PseudoPromise<any> } = {};
+      for (const key in data) {
+        parsedRecordPromises[key] = new PseudoPromise().then(() => {
+          try {
+            return def.valueType.parse(data[key], {
+              ...params,
+              path: [...params.path, key],
+            });
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      }
+      RESULT.promise = PseudoPromise.object(parsedRecordPromises);
+      // RESULT.promise = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-        throw error;
-      }
-      if (isNaN(obj.getTime())) {
-        console.log('NAN');
+        // setError(error);
+        throw error;
+      }
+      if (isNaN(data.getTime())) {
-        throw error;
-      }
+        // setError(error);
+        throw error;
+      }
+      RESULT.promise = PseudoPromise.resolve(data);
-      if (parsedType !== ZodParsedType.promise) {
+      console.log(`${parsedType} vs ${ZodParsedType.promise}`);
+      if (parsedType !== ZodParsedType.promise && params.async !== true) {
-        throw error;
-      }
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
-          res(parsed);
-        } catch (err) {
-          rej(err);
-        }
-      });
-
+        // setError(error);
+        throw error;
+      }
+
+      const promisified =
+        parsedType === ZodParsedType.promise ? data : Promise.resolve(data);
+
+      RESULT.promise = PseudoPromise.resolve(
+        promisified.then((resolvedData: any) => {
+          try {
+            const parsed = def.type.parse(resolvedData, params);
+            return parsed;
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        }),
+      );
+
+      //   new Promise(async (res, rej) => {
+      //     const dataValue = await data;
+      //     try {
+      //       const parsed = def.type.parse(dataValue, params);
+      //       res(parsed);
+      //     } catch (err) {
+      //       rej(err);
+      //     }
+      //   }),
+      // );
+      break;
+    case z.ZodTypes.transformer:
+      RESULT.promise = new PseudoPromise()
+        .then(() => {
+          try {
+            return def.input.parse(data, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        })
+        // .then(() => {
+        //   try {
+        //     return def.input.parse(data, params);
+        //   } catch (err) {
+        //     error.addErrors(err.errors);
+        //   }
+        // })
+        .then(inputParseResult => {
+          try {
+            return def.transformer(inputParseResult);
+          } catch (err) {
+            if (err instanceof ZodError) {
+              error.addErrors(err.errors);
+            }
+            throw err;
+          }
+        })
+        .then(transformedResult => {
+          try {
+            return def.output.parse(transformedResult, params);
+          } catch (err) {
+            error.addErrors(err.errors);
+          }
+        });
+      break;
+      RESULT.promise = PseudoPromise.resolve('adsf' as never);
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+
+  if (params.async === true) {
+    const checker = async () => {
+      const resolvedValue = await RESULT.promise.getValueAsync();
+
+      await Promise.all(
+        customChecks.map(async check => {
+          const checkResult = await check.check(resolvedValue);
+          if (!checkResult) {
+            const { check: checkMethod, ...noMethodCheck } = check;
+            error.addError(makeError(noMethodCheck));
+          } else {
+          }
+        }),
+      );
+
+      if (resolvedValue === INVALID && error.isEmpty) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.custom_error,
+            message: 'Invalid',
+          }),
+        );
+      }
+
+      if (!error.isEmpty) {
+        throw error;
+      }
+
+      return resolvedValue;
+    };
+
+    return checker();
+  } else {
+    const SYNC_ERROR =
+      ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."";
+    const resolvedValue = RESULT.promise.getValueSync();
+    console.log(`sync parse resolved value:`);
+    console.log(resolvedValue);
+    if (resolvedValue instanceof Promise) {
+      console.log(`found promise in sync parse.`);
+      console.log(def.t);
+
+      if (def.t === z.ZodTypes.transformer) {
+        console.log(def.output._def.t);
+        if (def.output._def.t !== z.ZodTypes.promise) {
+          throw new Error(SYNC_ERROR);
+        }
+      } else if (def.t !== z.ZodTypes.promise) {
+        throw new Error(SYNC_ERROR);
+      } else {
+        //
+      }
+      //  console.log(def.t);
+      // throw new Error(
+      //   ""You can't use .parse on a schema containing async refinements or transformations. Use .parseAsync instead."",
+      // );
+
+    for (const check of customChecks) {
+      const checkResult = check.check(resolvedValue);
+      if (checkResult instanceof Promise)
+        throw new Error(
+          ""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."",
+        );
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    }
+    if (!error.isEmpty) {
+      throw error;
+    }
+    if (resolvedValue === INVALID) {
+      throw new ZodError([]).addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          message: 'Invalid',
+        }),
+      );
+    }
+    return resolvedValue as any;
-
-  if (!error.isEmpty) {
-    throw error;
-  }
-
-  return returnValue as any;"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/types/base.ts,"-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
+import {
+  ZodErrorCode,
+  ZodArray,
+  ZodUnion,
+  ZodNull,
+  ZodUndefined,
+  ZodTransformer,
+} from '..';
+  transformer = 'transformer',
-export type Infer<T extends { _type: any }> = T['_type'];
+export type input<T extends { _input: any }> = T['_input'];
+export type output<T extends { _output: any }> = T['_output'];
+export type infer<T extends { _type: any }> = T['_type'];
+  readonly _input!: Type;
+  readonly _output!: Type;
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = value => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
-      }
-    });
+  parseAsync: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => Promise<Type> = async (value, params) => {
+    return await this.parse(value, { ...params, async: true });
-  protected _refinement: (refinement: InternalCheck<Type>) => this = refinement => {
+  protected _refinement: (
+    refinement: InternalCheck<Type>,
+  ) => this = refinement => {
-  optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
+  optional: () => ZodUnion<[this, ZodUndefined]> = () =>
+    ZodUnion.create([this, ZodUndefined.create()]);
+  nullable: () => ZodUnion<[this, ZodNull]> = () =>
+    ZodUnion.create([this, ZodNull.create()]);
+  // pre: <T extends string>(
+  //   input: T,
+  //   transformer: (arg: T) => Type,
+  // ) => any = (input, transformer) => 'adsf';
+
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+  // };
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+  transform: <
+    This extends this,
+    U extends ZodType<any>,
+    Tx extends (arg: This['_type']) => U['_type'] | Promise<U['_type']>
+  >(
+    x: U,
+    transformer: Tx,
+  ) => ZodTransformer<This, U> = (input, transformer) => {
+    return ZodTransformer.create(this as any, input, transformer) as any;
+  };
+
+  default: <
+    T extends Type = Type,
+    Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>
+  >(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };
+
+  //  codec = (): ZodCodec<this, this> => {
+  //    return ZodCodec.create(this, this, x => x);
+  //  };
+
+  //  transform: <U extends ZodType<any>, Tx extends (arg: Type) => U['_type']>(
+  //    x: U,s
+  //    transformer: Tx,
+  //  ) => ZodCodec<this, U> = (input, transformer) => {
+  //    return ZodCodec.create(input, this, transformer);
+  //  };
+","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
-import { CustomError } from '../ZodError';
+import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '../index';
+  nativeEnum = 'nativeEnum',
+// type Check<T> = {
+//   check: (arg: T) => any;
+//   path?: (string | number)[];
+//   // message?: string;
+//   // params?: {[k:string]:any}
+// } & util.Omit<CustomError, 'code' | 'path'>;
+
-} & util.Omit<CustomError, 'code' | 'path'>;
+  message?: string;
+  params?: { [k: string]: any };
+};
+
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = value => {
+  safeParse: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => { success: true; data: Type } | { success: false; error: ZodError } = (data, params) => {
+    try {
+      const parsed = this.parse(data, params);
+      return {
+        success: true,
+        data: parsed,
+      };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return {
+          success: false,
+          error: err,
+        };
+      }
+      throw err;
+    }
+  };
+
+  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = (value, params) => {
-        const parsed = this.parse(value);
+        const parsed = this.parse(value, params);
-  refine = <Val extends (arg: Type) => any>(
-    check: Val,
+  refine = <Func extends (arg: Type) => any>(
+    check: Func,
+    this._def = def;
-    this._def = def;","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
-import { CustomError } from '../ZodError';
+import {
+  ZodErrorCode,
+  ZodArray,
+  ZodUnion,
+  ZodNull,
+  ZodUndefined,
+  ZodTransformer,
+} from '..';
+import { ZodError } from '../ZodError';
+  nativeEnum = 'nativeEnum',
+  transformer = 'transformer',
+// type Check<T> = {
+//   check: (arg: T) => any;
+//   path?: (string | number)[];
+//   // message?: string;
+//   // params?: {[k:string]:any}
+// } & util.Omit<CustomError, 'code' | 'path'>;
+
-} & util.Omit<CustomError, 'code' | 'path'>;
+  message?: string;
+  params?: { [k: string]: any };
+};
+
-export type Infer<T extends { _type: any }> = T['_type'];
+export type input<T extends { _input: any }> = T['_input'];
+export type output<T extends { _output: any }> = T['_output'];
+export type infer<T extends { _type: any }> = T['_type'];
+  readonly _input!: Type;
+  readonly _output!: Type;
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = value => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
+  safeParse: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => { success: true; data: Type } | { success: false; error: ZodError } = (
+    data,
+    params,
+  ) => {
+    try {
+      const parsed = this.parse(data, params);
+      return {
+        success: true,
+        data: parsed,
+      };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return {
+          success: false,
+          error: err,
+        };
-    });
+      throw err;
+    }
+  };
+
+  parseAsync: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => Promise<Type> = async (value, params) => {
+    return await this.parse(value, { ...params, async: true });
-  refine = <Val extends (arg: Type) => any>(
-    check: Val,
+  refine = <Func extends (arg: Type) => any>(
+    check: Func,
-    return this._refinement({ code: ZodErrorCode.custom_error, ...refinement });
-  };
-
-  protected _refinement: (refinement: InternalCheck<Type>) => this = refinement => {
+    return this._refinement({
+      code: ZodErrorCode.custom_error,
+      ...refinement,
+    });
+  };
+
+  protected _refinement: (
+    refinement: InternalCheck<Type>,
+  ) => this = refinement => {
+    this._def = def;
-    this._def = def;
-  optional: () => ZodUnion<[this, ZodUndefined]> = () => ZodUnion.create([this, ZodUndefined.create()]);
-  nullable: () => ZodUnion<[this, ZodNull]> = () => ZodUnion.create([this, ZodNull.create()]);
+  optional: () => ZodUnion<[this, ZodUndefined]> = () =>
+    ZodUnion.create([this, ZodUndefined.create()]);
+  nullable: () => ZodUnion<[this, ZodNull]> = () =>
+    ZodUnion.create([this, ZodNull.create()]);
+  // pre: <T extends string>(
+  //   input: T,
+  //   transformer: (arg: T) => Type,
+  // ) => any = (input, transformer) => 'adsf';
+
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+  // };
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+  transform: <
+    This extends this,
+    U extends ZodType<any>,
+    Tx extends (arg: This['_type']) => U['_type'] | Promise<U['_type']>
+  >(
+    x: U,
+    transformer: Tx,
+  ) => ZodTransformer<This, U> = (input, transformer) => {
+    return ZodTransformer.create(this as any, input, transformer) as any;
+  };
+
+  default: <
+    T extends Type = Type,
+    Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>
+  >(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };
+
+  //  codec = (): ZodCodec<this, this> => {
+  //    return ZodCodec.create(this, this, x => x);
+  //  };
+
+  //  transform: <U extends ZodType<any>, Tx extends (arg: Type) => U['_type']>(
+  //    x: U,s
+  //    transformer: Tx,
+  //  ) => ZodCodec<this, U> = (input, transformer) => {
+  //    return ZodCodec.create(input, this, transformer);
+  //  };
+"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,src/types/object.ts,"+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<infer U, infer P>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+  }
+
+  get t() {
+    return this;
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+","+import { isScalar } from '../isScalar';
+export type Scalars =
+  | string
+  | string[]
+  | number
+  | number[]
+  | boolean
+  | boolean[]
+  | bigint
+  | bigint[]
+  | undefined
+  | null;
+
-  ): ZodObject<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
-  ): ZodObject<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  primitives = (): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key];
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  nonprimitives = (): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (!isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key];
+      }","-
-const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <Augmentation extends z.ZodRawShape>(
+import { isScalar } from '../isScalar';
+
+const AugmentFactory = <Def extends ZodObjectDef>(def: Def) => <
+  Augmentation extends z.ZodRawShape
+>(
-  { [k in Exclude<keyof ReturnType<Def['shape']>, keyof Augmentation>]: ReturnType<Def['shape']>[k] } &
+  {
+    [k in Exclude<
+      keyof ReturnType<Def['shape']>,
+      keyof Augmentation
+    >]: ReturnType<Def['shape']>[k];
+  } &
-type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<
+export type Scalars =
+  | string
+  | string[]
+  | number
+  | number[]
+  | boolean
+  | boolean[]
+  | bigint
+  | bigint[]
+  | undefined
+  | null;
+
+type SetKey<
+  Target extends object,
+  Key extends string,
+  Value extends any
+> = objectUtil.Flatten<
-type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true
+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<
+  infer U,
+  infer P
+>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+type ZodObjectType<
+  T extends z.ZodRawShape,
+  Params extends ZodObjectParams
+> = Params['strict'] extends true
+  get t() {
+    return this;
+  }
+
-  merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(
+  merge: <
+    MergeShape extends z.ZodRawShape,
+    MergeParams extends ZodObjectParams
+  >(
-  ) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>> = objectUtil.mergeObjects(
-    this as any,
-  );
+  ) => ZodObject<
+    T & MergeShape,
+    objectUtil.MergeObjectParams<Params, MergeParams>
+  > = objectUtil.mergeObjects(this as any);
-  ): ZodObject<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
+    Params
+  > => {
-  ): ZodObject<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }, Params> => {
+  ): ZodObject<
+    objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
+    Params
+  > => {
-  partial = (): ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> }, Params> => {
+  partial = (): ZodObject<
+    { [k in keyof T]: ZodUnion<[T[k], ZodUndefined]> },
+    Params
+  > => {
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  primitives = (): ZodObject<
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }
+    >,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key];
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  nonprimitives = (): ZodObject<
+    objectUtil.NoNever<
+      { [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }
+    >,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (!isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key];
+      }
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+
-  static lazycreate = <T extends z.ZodRawShape>(shape: () => T): ZodObject<T> => {
+  static lazycreate = <T extends z.ZodRawShape>(
+    shape: () => T,
+  ): ZodObject<T> => {"
colinhacks_zod,b0cf5d12d0838639df9f3f62a3c60ee3e70a0dc4,Fixed merge conflicts,tsconfig.json,"+    ""lib"",","+    ""skipLibCheck"": true,
+    // ""tsconfig.json"",","+    ""skipLibCheck"": true,
+    // ""tsconfig.json"",
+    ""lib"","
colinhacks_zod,f0c44ef3d92e5045481b13fa5015d5e4af02ec01,Fixed merge conflicts,package.json,"-  ""version"": ""1.10.2"",
+  ""version"": ""1.10.3"",","-  ""version"": ""1.10.2"",
+  ""version"": ""1.10.4"",
+    ""buildall"": ""yarn add typescript@3.4 && yarn build && yarn add typescript@3.5 && yarn build && yarn add typescript@3.6 && yarn build && yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4 && yarn build && yarn add typescript@3.3 && yarn build"",","-  ""version"": ""1.10.2"",
+  ""version"": ""1.10.4"",
+    ""buildall"": ""yarn add typescript@3.4 && yarn build && yarn add typescript@3.5 && yarn build && yarn add typescript@3.6 && yarn build && yarn add typescript@3.7 && yarn build && yarn add typescript@3.8 && yarn build && yarn add typescript@3.9 && yarn build && yarn add typescript@4 && yarn build && yarn add typescript@3.3 && yarn build"","
colinhacks_zod,d660f38f278cce3fced8a93911a71ec3870f8281,regexp -> regex,src/__tests__/string.test.ts,"+
+test('regexp', () => {
+  z.string()
+    .regex(/^moo+$/)
+    .parse('mooooo');
+  expect(() =>
+    z
+      .string()
+      .uuid()
+      .parse('purr'),
+  ).toThrow();
+});
+
+test('regexp error message', () => {
+  const result = z
+    .string()
+    .regex(/^moo+$/)
+    .safeParse('boooo');
+  if (!result.success) {
+    expect(result.error.errors[0].message).toEqual('Invalid');
+  } else {
+    throw new Error('validation should have failed');
+  }
+
+  expect(() =>
+    z
+      .string()
+      .uuid()
+      .parse('purr'),
+  ).toThrow();
+});","+
+test('regex', () => {
+  z.string()
+    .regex(/^moo+$/)
+    .parse('mooooo');
+  expect(() =>
+    z
+      .string()
+      .uuid()
+      .parse('purr'),
+  ).toThrow();
+});","+
+test('regex', () => {
+  z.string()
+    .regex(/^moo+$/)
+    .parse('mooooo');
+  expect(() =>
+    z
+      .string()
+      .uuid()
+      .parse('purr'),
+  ).toThrow();
+});
+
+test('regexp error message', () => {
+  const result = z
+    .string()
+    .regex(/^moo+$/)
+    .safeParse('boooo');
+  if (!result.success) {
+    expect(result.error.errors[0].message).toEqual('Invalid');
+  } else {
+    throw new Error('validation should have failed');
+  }
+
+  expect(() =>
+    z
+      .string()
+      .uuid()
+      .parse('purr'),
+  ).toThrow();
+});"
colinhacks_zod,d660f38f278cce3fced8a93911a71ec3870f8281,regexp -> regex,src/types/string.ts,"-import { ZodErrorCode } from '../ZodError';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-const urlRegex = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regexp: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regexp.test(data),
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
+
-      check: data => urlRegex.test(data),
+      check: data => {
+        try {
+          new URL(data);
+          return true;
+        } catch {
+          return false;
+        }
+      },
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) => this._regex(regexp, 'regex', message);","-import { ZodErrorCode } from '../ZodError';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regex.test(data),
-  url = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => urlRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'url',
-      ...errorUtil.errToObj(message),
-    });
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) => this._regex(regex, 'regex', message);","-import { ZodErrorCode } from '../ZodError';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-const urlRegex = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regex.test(data),
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
+
-      check: data => urlRegex.test(data),
+      check: data => {
+        try {
+          new URL(data);
+          return true;
+        } catch {
+          return false;
+        }
+      },
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) => this._regex(regexp, 'regex', message);"
colinhacks_zod,30920f4629cdec0b341c613b09e47ace681cfcc2,removed URL import,src/types/string.ts,"-import { ZodErrorCode } from '..';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regexp: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regexp.test(data),
-  url = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => urlRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'url',
-      ...errorUtil.errToObj(message),
-    });
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) => this._regex(regexp, 'regex', message);","-import { ZodErrorCode } from '..';
+import { ZodErrorCode } from '../ZodError';
+import { URL } from 'url';
-const urlRegex = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
-      check: data => urlRegex.test(data),
+      check: data => {
+        try {
+          new URL(data)
+          return true
+        } catch {
+          return false
+        }
+      },","-import { ZodErrorCode } from '..';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-const urlRegex = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regexp: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regexp.test(data),
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
+
-      check: data => urlRegex.test(data),
+      check: data => {
+        try {
+          new URL(data);
+          return true;
+        } catch {
+          return false;
+        }
+      },
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  // url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regexp: RegExp, message?: errorUtil.ErrMessage) => this._regex(regexp, 'regex', message);"
colinhacks_zod,78e3f21b1d57ab65981aa678ab9803d49081e556,regexp -> regex,src/types/string.ts,"-import { ZodErrorCode } from '..';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regexp = (regexp: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regexp.test(data),
-  url = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => urlRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'url',
-      ...errorUtil.errToObj(message),
-    });
+  email = (message?: errorUtil.ErrMessage) => this._regexp(emailRegex, 'email', message);
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  url = (message?: errorUtil.ErrMessage) => this._regexp(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regexp(uuidRegex, 'uuid', message);
+
+  regexp = (regexp: RegExp, message?: errorUtil.ErrMessage) => this._regexp(regexp, 'regexp', message);","-import { ZodErrorCode } from '..';
+import { ZodErrorCode } from '../ZodError';","-import { ZodErrorCode } from '..';
+import { StringValidation, ZodErrorCode } from '../ZodError';
-  email = (message?: errorUtil.ErrMessage) =>
+  protected _regex = (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) =>
-      check: data => emailRegex.test(data),
+      validation,
-      validation: 'email',
+      check: data => regex.test(data),
-  url = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => urlRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'url',
-      ...errorUtil.errToObj(message),
-    });
+  email = (message?: errorUtil.ErrMessage) => this._regex(emailRegex, 'email', message);
-  uuid = (message?: errorUtil.ErrMessage) =>
-    this._refinement({
-      check: data => uuidRegex.test(data),
-      code: ZodErrorCode.invalid_string,
-      validation: 'uuid',
-      ...errorUtil.errToObj(message),
-    });
+  url = (message?: errorUtil.ErrMessage) => this._regex(urlRegex, 'url', message);
+
+  uuid = (message?: errorUtil.ErrMessage) => this._regex(uuidRegex, 'uuid', message);
+
+  regex = (regex: RegExp, message?: errorUtil.ErrMessage) => this._regex(regex, 'regex', message);"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,package.json,"-  ""version"": ""1.11.0-alpha.3"",
+  ""version"": ""1.10.1"",","-  ""version"": ""1.11.0-alpha.3"",
+  ""version"": ""1.11.0-alpha.6"",","-  ""version"": ""1.11.0-alpha.3"",
+  ""version"": ""1.11.0-alpha.6"","
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/ZodError.ts,"+
+const flatten = (err: ZodError): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  const fieldErrors: any = {};
+  const formErrors: string[] = [];
+  for (const sub of err.errors) {
+    if (sub.path.length > 0) {
+      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
+      fieldErrors[sub.path[0]].push(sub.message);
+    } else {
+      formErrors.push(sub.message);
+    }
+  }
+  return {
+    formErrors,
+    fieldErrors,
+  };
+};
-  get formErrors(): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } {
-    const fieldErrors: any = {};
-    const formErrors: string[] = [];
-    for (const sub of this.errors) {
-      if (sub.path.length > 0) {
-        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
-        fieldErrors[sub.path[0]].push(sub.message);
-      } else {
-        formErrors.push(sub.message);
-      }
-    }
-    return { formErrors, fieldErrors };
+  get formErrors() {
+    return flatten(this);
+
+  flatten = () => flatten(this);","+  'invalid_intersection_types',
+interface InvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+}
+
+  | InvalidIntersectionTypesError","+  'invalid_intersection_types',
+
+const flatten = (err: ZodError): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } => {
+  const fieldErrors: any = {};
+  const formErrors: string[] = [];
+  for (const sub of err.errors) {
+    if (sub.path.length > 0) {
+      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
+      fieldErrors[sub.path[0]].push(sub.message);
+    } else {
+      formErrors.push(sub.message);
+    }
+  }
+  return {
+    formErrors,
+    fieldErrors,
+  };
+};
+interface InvalidIntersectionTypesError extends ZodSuberrorBase {
+  code: typeof ZodErrorCode.invalid_intersection_types;
+}
+
+  | InvalidIntersectionTypesError
-  get formErrors(): { formErrors: string[]; fieldErrors: { [k: string]: string[] } } {
-    const fieldErrors: any = {};
-    const formErrors: string[] = [];
-    for (const sub of this.errors) {
-      if (sub.path.length > 0) {
-        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
-        fieldErrors[sub.path[0]].push(sub.message);
-      } else {
-        formErrors.push(sub.message);
-      }
-    }
-    return { formErrors, fieldErrors };
+  get formErrors() {
+    return flatten(this);
+
+  flatten = () => flatten(this);"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/index.ts,"-import { ZodTransformer, ZodTransformerDef } from './types/transformer';
-  | ZodPromiseDef
-  | ZodTransformerDef;
+  | ZodPromiseDef;
-const transformerType = ZodTransformer.create;
-  transformerType as transformer,
-  ZodTransformer,","-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+import { TypeOf, input, output, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
-export { TypeOf, TypeOf as infer };
+export { TypeOf, TypeOf as infer, input, output };","-import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+import { TypeOf, input, output, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+  instanceOfType as instanceof,
-  instanceOfType as instanceof,
-export { TypeOf, TypeOf as infer };
+export { TypeOf, TypeOf as infer, input, output };"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/parser.ts,"+  async?: boolean;
+    async: baseParams.async || false,
-      const data: any[] = obj;
+      // const arrayValue: any[] = obj;
-      data.map((item, i) => {
+      returnValue = (obj as any[]).map((item, i) => {
-      if (!error.isEmpty) {
-        throw error;
-      }
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
+      returnValue = { ...obj };
+
+      returnValue = parsedTuple;
-
+      const recordData: any = {};
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+          recordData[key] = def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+      returnValue = recordData;
-        console.log('NAN');
-    case z.ZodTypes.transformer:
-      // console.log(`input: ""${obj}""`);
-      const inputParseResult = def.input.parse(obj);
-      // console.log(`inputParseResult: ""${inputParseResult}""`);
-      const transformedResult = def.transformer(inputParseResult);
-      // console.log(`transformedResult: ""${transformedResult}""`);
-      returnValue = def.output.parse(transformedResult);
-      break;
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+  console.log(`async: ${params.async}`);
+  if (params.async === true) {
+    const asyncChecks = customChecks.map(check => {
+      return new Promise(async res => {
+        const checkResult = await check.check(returnValue);
+        if (!checkResult) {
+          const { check: checkMethod, ...noMethodCheck } = check;
+          error.addError(makeError(noMethodCheck));
+        }
+        res();
+      });
+    });
+    return new Promise((res, rej) => {
+      return Promise.all(asyncChecks).then(() => {
+        if (!error.isEmpty) {
+          return rej(error);
+        }
+
+        return res(returnValue);
+      });
+    });
+  } else {
+    for (const check of customChecks) {
+      const checkResult = check.check(returnValue);
+      if (getParsedType(checkResult) === ZodParsedType.promise) {
+        throw new Error(""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."");
+      }
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    if (!error.isEmpty) {
+      throw error;
+    }
+
+    return returnValue as any;
-
-  if (!error.isEmpty) {
-    throw error;
-  }
-
-  return returnValue as any;","-  obj: any,
+  data: any,
-    const ctxArg = { data: obj };
+    const ctxArg = { data: data };
-    if (schemaSeen.objects.indexOf(obj) !== -1) {
-      return obj;
+    if (schemaSeen.objects.indexOf(data) !== -1) {
+      return data;
-      schemaSeen.objects.push(obj);
+      schemaSeen.objects.push(data);
-    params.seen.push({ schema: schemaDef, objects: [obj] });
+    params.seen.push({ schema: schemaDef, objects: [data] });
-  let returnValue: any = obj;
-  const parsedType = getParsedType(obj);
+  let returnValue: any = data;
+  const parsedType = getParsedType(data);
-      if (Number.isNaN(obj)) {
+      if (Number.isNaN(data)) {
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
+      returnValue = (data as any[]).map((item, i) => {
+        try {
+          return def.type.parse(item, { ...params, path: [...params.path, i] });
+      const parsedobject: any = {};
+
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+        } else {
+          for (const key of extraKeys) {
+            parsedobject[key] = data[key];
+          }
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          parsedobject[key] = def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] });
+      returnValue = parsedobject;
+      let parsedUnion: any;
-          option.parse(obj, params);
+          parsedUnion = option.parse(data, params);
+          break;
+      returnValue = parsedUnion;
+      // let parsedIntersection:any;
+      let parsedLeft: any;
+      let parsedRight: any;
-        def.left.parse(obj, params);
+        parsedLeft = def.left.parse(data, params);
-        def.right.parse(obj, params);
+        parsedRight = def.right.parse(data, params);
+      const parsedLeftType = getParsedType(parsedLeft);
+      const parsedRightType = getParsedType(parsedRight);
+
+      if (parsedLeft === parsedRight) {
+        returnValue = parsedLeft;
+      } else if (parsedLeftType === ZodParsedType.object && parsedRightType === ZodParsedType.object) {
+        returnValue = { ...parsedLeft, ...parsedRight };
+      } else {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_intersection_types,
+          }),
+        );
+      }
-      if (obj.length > def.items.length) {
+      if (data.length > def.items.length) {
-      } else if (obj.length < def.items.length) {
+      } else if (data.length < def.items.length) {
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      const parsedTuple: any = [];
+      returnValue = parsedTuple;
-      lazySchema.parse(obj, params);
+      returnValue = lazySchema.parse(data, params);
-      if (obj !== def.value) {
+      if (data !== def.value) {
+      returnValue = data;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      returnValue = data;
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-      return validatedFunc;
+      returnValue = validatedFunc;
+      // return validatedFunc;
+      break;
-
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+      const parsedRecord: any = {};
+      for (const key in data) {
+        try {
+          parsedRecord[key] = def.valueType.parse(data[key], { ...params, path: [...params.path, key] });
+      returnValue = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      returnValue = data;
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
+      returnValue = new Promise(async (res, rej) => {
+        const dataValue = await data;
+        try {
+          const parsed = def.type.parse(dataValue, params);
-
+      break;
-      // console.log(`input: ""${obj}""`);
-      const inputParseResult = def.input.parse(obj);
+      // console.log(`input: ""${data}""`);
+
+      const inputParseResult = def.input.parse(data);","+  async?: boolean;
-  obj: any,
+  data: any,
+    async: baseParams.async || false,
-    const ctxArg = { data: obj };
+    const ctxArg = { data: data };
-    if (schemaSeen.objects.indexOf(obj) !== -1) {
-      return obj;
+    if (schemaSeen.objects.indexOf(data) !== -1) {
+      return data;
-      schemaSeen.objects.push(obj);
+      schemaSeen.objects.push(data);
-    params.seen.push({ schema: schemaDef, objects: [obj] });
+    params.seen.push({ schema: schemaDef, objects: [data] });
-  let returnValue: any = obj;
-  const parsedType = getParsedType(obj);
+  let returnValue: any = data;
+  const parsedType = getParsedType(data);
-      if (Number.isNaN(obj)) {
+      if (Number.isNaN(data)) {
-      const data: any[] = obj;
-      if (def.nonempty === true && obj.length === 0) {
+      // const data: any[] = data;
+      if (def.nonempty === true && data.length === 0) {
-      data.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          return parsedItem;
+      returnValue = (data as any[]).map((item, i) => {
+        try {
+          return def.type.parse(item, { ...params, path: [...params.path, i] });
-      if (!error.isEmpty) {
-        throw error;
-      }
+      // if (!error.isEmpty) {
+      //   throw error;
+      // }
+      const parsedobject: any = {};
+
-      if (def.params.strict) {
-        const shapeKeys = Object.keys(shape);
-        const objKeys = Object.keys(obj);
-        const extraKeys = objKeys.filter(k => shapeKeys.indexOf(k) === -1);
-
-        if (extraKeys.length) {
+      const shapeKeys = Object.keys(shape);
+      const dataKeys = Object.keys(data);
+      const extraKeys = dataKeys.filter(k => shapeKeys.indexOf(k) === -1);
+
+      if (extraKeys.length) {
+        if (def.params.strict) {
+        } else {
+          for (const key of extraKeys) {
+            parsedobject[key] = data[key];
+          }
-          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          parsedobject[key] = def.shape()[key].parse(data[key], { ...params, path: [...params.path, key] });
+      returnValue = parsedobject;
+      let parsedUnion: any;
-          option.parse(obj, params);
+          parsedUnion = option.parse(data, params);
+          break;
+      returnValue = parsedUnion;
+      // let parsedIntersection:any;
+      let parsedLeft: any;
+      let parsedRight: any;
-        def.left.parse(obj, params);
+        parsedLeft = def.left.parse(data, params);
-        def.right.parse(obj, params);
+        parsedRight = def.right.parse(data, params);
+      const parsedLeftType = getParsedType(parsedLeft);
+      const parsedRightType = getParsedType(parsedRight);
+
+      if (parsedLeft === parsedRight) {
+        returnValue = parsedLeft;
+      } else if (parsedLeftType === ZodParsedType.object && parsedRightType === ZodParsedType.object) {
+        returnValue = { ...parsedLeft, ...parsedRight };
+      } else {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_intersection_types,
+          }),
+        );
+      }
-      if (obj.length > def.items.length) {
+      if (data.length > def.items.length) {
-      } else if (obj.length < def.items.length) {
+      } else if (data.length < def.items.length) {
-      const parsedTuple: any[] = [];
-      const tupleData: any[] = obj;
+      // const parsedTuple: any[] = [];
+      const tupleData: any[] = data;
+      const parsedTuple: any = [];
+      returnValue = parsedTuple;
-      lazySchema.parse(obj, params);
+      returnValue = lazySchema.parse(data, params);
-      if (obj !== def.value) {
+      if (data !== def.value) {
-      break;
-
+      returnValue = data;
+      break;
-      if (def.values.indexOf(obj) === -1) {
+      if (def.values.indexOf(data) === -1) {
+      returnValue = data;
-        const result = obj(...(args as any));
+        const result = data(...(args as any));
-      return validatedFunc;
+      returnValue = validatedFunc;
+      // return validatedFunc;
+      break;
-
-      for (const key in obj) {
-        try {
-          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+      const parsedRecord: any = {};
+      for (const key in data) {
+        try {
+          parsedRecord[key] = def.valueType.parse(data[key], { ...params, path: [...params.path, key] });
+      returnValue = parsedRecord;
-      if (!(obj instanceof Date)) {
+      if (!(data instanceof Date)) {
-      if (isNaN(obj.getTime())) {
+      if (isNaN(data.getTime())) {
+      returnValue = data;
-      return new Promise(async (res, rej) => {
-        const objValue = await obj;
-        try {
-          const parsed = def.type.parse(objValue, params);
+      returnValue = new Promise(async (res, rej) => {
+        const dataValue = await data;
+        try {
+          const parsed = def.type.parse(dataValue, params);
-
+      break;
-      // console.log(`input: ""${obj}""`);
-      const inputParseResult = def.input.parse(obj);
+      // console.log(`input: ""${data}""`);
+
+      const inputParseResult = def.input.parse(data);
-  for (const check of customChecks) {
-    if (!check.check(returnValue)) {
-      const { check: checkMethod, ...noMethodCheck } = check;
-      error.addError(makeError(noMethodCheck));
+  console.log(`async: ${params.async}`);
+  if (params.async === true) {
+    const asyncChecks = customChecks.map(check => {
+      return new Promise(async res => {
+        const checkResult = await check.check(returnValue);
+        if (!checkResult) {
+          const { check: checkMethod, ...noMethodCheck } = check;
+          error.addError(makeError(noMethodCheck));
+        }
+        res();
+      });
+    });
+    return new Promise((res, rej) => {
+      return Promise.all(asyncChecks).then(() => {
+        if (!error.isEmpty) {
+          return rej(error);
+        }
+
+        return res(returnValue);
+      });
+    });
+  } else {
+    for (const check of customChecks) {
+      const checkResult = check.check(returnValue);
+      if (getParsedType(checkResult) === ZodParsedType.promise) {
+        throw new Error(""You can't use .parse on a schema containing async refinements. Use .parseAsync instead."");
+      }
+      if (!checkResult) {
+        const { check: checkMethod, ...noMethodCheck } = check;
+        error.addError(makeError(noMethodCheck));
+      }
+    if (!error.isEmpty) {
+      throw error;
+    }
+
+    return returnValue as any;
-
-  if (!error.isEmpty) {
-    throw error;
-  }
-
-  return returnValue as any;"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/playground.ts,"-const trimAndMultiply = z
-  .transformer(z.string(), z.string(), x => {
-    return x.trim();
-  })
-  .transform(z.number(), x => {
-    return parseFloat(x);
-  })
-  .transform(z.number(), num => {
-    return num * 5;
-  })
-  .refine(x => {
-    return x > 20;
-  }, 'Number is too small');
+const run = async () => {
+  await z
+    .union([z.string(), z.number().int()])
+    .parseAsync(3.2)
+    .then(console.log)
+    .catch(_err => {
+      console.log('error! oh no!');
+    });
+};
-console.log(trimAndMultiply.parse(' 5 '));
-type trimAndMultiply = z.infer<typeof trimAndMultiply>;
+run();","-const trimAndMultiply = z
-  .transformer(z.string(), z.string(), x => {
-    return x.trim();
-  })
-  .transform(z.number(), x => {
-    return parseFloat(x);
-  })
-  .transform(z.number(), num => {
-    return num * 5;
-  })
-  .refine(x => {
-    return x > 20;
-  }, 'Number is too small');
+const ID = z.transformer(z.number(), z.string(), n => String(n));
-console.log(trimAndMultiply.parse(' 5 '));
-type trimAndMultiply = z.infer<typeof trimAndMultiply>;
+z.object({
+  id: ID,
+}).parse({ id: 5 }); // => { id: '5' }
+
+z.string()
+  .default('asdf')
+  .parse(undefined); // => ""asdf""","-import * as z from '.';
+// import * as z from '.';
+import { PseudoPromise } from './PseudoPromise';
-const trimAndMultiply = z
-  .transformer(z.string(), z.string(), x => {
-    return x.trim();
-  })
-  .transform(z.number(), x => {
-    return parseFloat(x);
-  })
-  .transform(z.number(), num => {
-    return num * 5;
-  })
-  .refine(x => {
-    return x > 20;
-  }, 'Number is too small');
+PseudoPromise.object({
+  asdf: PseudoPromise.resolve(15),
+  qwer: new PseudoPromise().then(() => 'asdfadsf'),
+})
+  .resolveAsync()
+  .then(console.log);
-console.log(trimAndMultiply.parse(' 5 '));
-type trimAndMultiply = z.infer<typeof trimAndMultiply>;
+// expect.assertions(1);
+
+// PseudoPromise.allAsync([new PseudoPromise().then(async () => 'asdf')]).then(val => expect(val).toEqual('asdf'));
+
+// const myProm = new PseudoPromise()
+//   .then(async () => 15)
+//   .then(arg => arg.toString())
+//   .then(arg => arg.length);
+
+// console.log(myProm.resolveSync());
+
+// const run = async () => {
+//   await z
+//     .union([z.string(), z.number().int()])
+//     .parseAsync(3.2)
+//     .then(console.log)
+//     .catch(_err => {
+//       console.log('error! oh no!');
+//     });
+// };
+
+// run();
+
+// PseudoPromise.awaitObj({
+//   asdf: PseudoPromise.resolve(15),
+//   qwer: new PseudoPromise().then(async () => {
+//     if (Math.random() > 0) throw new Error('asdfjasf');
+//     return 'asdfadsf';
+//   }),
+// });
+
+// PseudoPromise.all([new PseudoPromise().then(async () => 'asdf')]);"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/types/base.ts,"-  transformer = 'transformer',
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = value => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
-      }
-    });
+  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = async (value, params) => {
+    const parsed = await this.parse(value, { ...params, async: true });
+    return parsed;
-  // pre: <T extends string>(
-  //   input: T,
-  //   transformer: (arg: T) => Type,
-  // ) => any = (input, transformer) => 'adsf';
-
-  // accepts: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
-  //   x: U,
-  //   transformer: Tx,
-  // ) => ZodCodec<U, this> = (input, transformer) => {
-  //   return ZodCodec.create(input, this, transformer);
-  // };
-
-  //  codec = (): ZodCodec<this, this> => {
-  //    return ZodCodec.create(this, this, x => x);
-  //  };
-
-  //  transform: <U extends ZodType<any>, Tx extends (arg: Type) => U['_type']>(
-  //    x: U,s
-  //    transformer: Tx,
-  //  ) => ZodCodec<this, U> = (input, transformer) => {
-  //    return ZodCodec.create(input, this, transformer);
-  //  };
-","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
+import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodTransformer } from '..';
-export type Infer<T extends { _type: any }> = T['_type'];
+export type input<T extends { _input: any }> = T['_input'];
+export type output<T extends { _output: any }> = T['_output'];
+export type infer<T extends { _type: any }> = T['_type'];
+  readonly _input!: Type;
+  readonly _output!: Type;
-  // accepts: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
-  // ) => ZodCodec<U, this> = (input, transformer) => {
-  //   return ZodCodec.create(input, this, transformer);
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+  transform: <This extends this, U extends ZodType<any>, Tx extends (arg: This['_type']) => U['_type']>(
+    x: U,
+    transformer: Tx,
+  ) => ZodTransformer<This, U> = (input, transformer) => {
+    return ZodTransformer.create(this as any, input, transformer) as any;
+  };
+
+
+  default: <T extends Type = Type, Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>>(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
+import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodTransformer } from '..';
-  transformer = 'transformer',
+  transformer = 'transformer'
-export type Infer<T extends { _type: any }> = T['_type'];
+export type input<T extends { _input: any }> = T['_input'];
+export type output<T extends { _output: any }> = T['_output'];
+export type infer<T extends { _type: any }> = T['_type'];
+  readonly _input!: Type;
+  readonly _output!: Type;
-  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = value => {
-    return new Promise((res, rej) => {
-      try {
-        const parsed = this.parse(value);
-        return res(parsed);
-      } catch (err) {
-        return rej(err);
-      }
-    });
+  parseAsync: (x: Type | unknown, params?: ParseParams) => Promise<Type> = async (value, params) => {
+    const parsed = await this.parse(value, { ...params, async: true });
+    return parsed;
-  // accepts: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  // transformFrom: <U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
-  // ) => ZodCodec<U, this> = (input, transformer) => {
-  //   return ZodCodec.create(input, this, transformer);
+  // ) => ZodTransformer<U, this> = (input, transformer) => {
+  //   return ZodTransformer.create(input, this, transformer);
+
+  // transformFrom: <This extends this, U extends ZodType<any>, Tx extends (arg: U['_type']) => this['_type']>(
+  //   x: U,
+  //   transformer: Tx,
+  // ) => ZodTransformer<This, U> = (input, transformer) => {
+  //   return ZodTransformer.create(this as any, input, transformer) as any;
+  // };
+  transform: <This extends this, U extends ZodType<any>, Tx extends (arg: This['_type']) => U['_type']>(
+    x: U,
+    transformer: Tx,
+  ) => ZodTransformer<This, U> = (input, transformer) => {
+    return ZodTransformer.create(this as any, input, transformer) as any;
+  };
+
+
+  default: <T extends Type = Type, Opt extends ZodUnion<[this, ZodUndefined]> = ZodUnion<[this, ZodUndefined]>>(
+    def: T,
+  ) => ZodTransformer<Opt, this> = def => {
+    return ZodTransformer.create(this.optional(), this, (x: any) => {
+      return (x || def) as any;
+    }) as any;
+  };
+
+  //  default: (val: Type) => ZodTransformer<ZodType<Type | undefined>, this> = val => {
+  //    return ZodTransformer.create(this.optional(), this, x => {
+  //      return (x || val) as any;
+  //    }) as any;
+  //  };"
colinhacks_zod,9aa17d95d590ed047ec72c8e027bd99ebf58a26b,Merged async parsing and transformations,src/types/object.ts,"+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+","+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<infer U, infer P>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+  }
+
+  get t() {
+    return this;
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+","+type makeKeysRequired<T extends ZodObject<any, any>> = T extends ZodObject<infer U, infer P>
+  ? ZodObject<objectUtil.NoNever<{ [k in keyof U]: makeRequired<U[k]> }>, P>
+  : never;
+type makeRequired<T extends z.ZodType<any>> = T extends ZodUnion<infer U>
+  ? U extends [infer Y, ZodUndefined]
+    ? Y
+    : U extends [ZodUndefined, infer Z]
+    ? Z
+    : T
+  : T;
+
+  }
+
+  get t() {
+    return this;
+  require: () => makeKeysRequired<this> = () => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      const val = this.shape[key];
+      if (val instanceof ZodUnion && val.options.length === 2) {
+        if (val.options[0] instanceof ZodUndefined) {
+          newShape[key] = val.options[1];
+        } else if (val.options[1] instanceof ZodUndefined) {
+          newShape[key] = val.options[0];
+        }
+      } else {
+        newShape[key] = val;
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    }) as any;
+  };
+
+  // keyof: ()=>ZodEnum<{[k in T]: k}>
+"
colinhacks_zod,b94f182d1de727e6cbd6afc61f048739569dbd89,Fixed discriminated union bug,src/ZodError.ts,"-  options: string[];
+  options: (string | number)[];","-  code: ZodErrorCode;
+  // code: ZodErrorCode;
+export type StringValidation = 'email' | 'url' | 'uuid' | 'regex';
+
-  validation: 'email' | 'url' | 'uuid';
+  validation: StringValidation;","-  code: ZodErrorCode;
+  // code: ZodErrorCode;
-  options: string[];
+  options: (string | number)[];
+export type StringValidation = 'email' | 'url' | 'uuid' | 'regex';
+
-  validation: 'email' | 'url' | 'uuid';
+  validation: StringValidation;"
colinhacks_zod,b94f182d1de727e6cbd6afc61f048739569dbd89,Fixed discriminated union bug,src/parser.ts,"+    case z.ZodTypes.nativeEnum:
+      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: Object.values(def.values),
+          }),
+        );
+      }
+      break;","-  if (data === null) return 'null';
+    if (!data) return 'null';
+  const parsedType = getParsedType(obj);
-  if (schemaSeen) {
+  const isPrimitive = typeof obj !== 'object' || obj === null;
+  if (isPrimitive) {
+  } else if (schemaSeen) {
-  // }
-  const parsedType = getParsedType(obj);","-  if (data === null) return 'null';
+    if (!data) return 'null';
+  const parsedType = getParsedType(obj);
-  if (schemaSeen) {
+  const isPrimitive = typeof obj !== 'object' || obj === null;
+  if (isPrimitive) {
+  } else if (schemaSeen) {
-  // }
-  const parsedType = getParsedType(obj);
+    case z.ZodTypes.nativeEnum:
+      if (util.getValidEnumValues(def.values).indexOf(obj) === -1) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: Object.values(def.values),
+          }),
+        );
+      }
+      break;"
colinhacks_zod,b94f182d1de727e6cbd6afc61f048739569dbd89,Fixed discriminated union bug,src/types/base.ts,"+  nativeEnum = 'nativeEnum',","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
-import { CustomError } from '../ZodError';
+import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '..';
+// type Check<T> = {
+//   check: (arg: T) => any;
+//   path?: (string | number)[];
+//   // message?: string;
+//   // params?: {[k:string]:any}
+// } & util.Omit<CustomError, 'code' | 'path'>;
+
-} & util.Omit<CustomError, 'code' | 'path'>;
+  message?: string;
+  params?: { [k: string]: any };
+};
+
+
+  safeParse: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => { success: true; data: Type } | { success: false; error: ZodError } = data => {
+    try {
+      const parsed = this.parse(data);
+      return {
+        success: true,
+        data: parsed,
+      };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return {
+          success: false,
+          error: err,
+        };
+      }
+      throw err;
+    }
+  };
-  refine = <Val extends (arg: Type) => any>(
-    check: Val,
+  refine = <Func extends (arg: Type) => any>(
+    check: Func,
+    this._def = def;
-    this._def = def;","-import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined } from '..';
-import { CustomError } from '../ZodError';
+import { ZodErrorCode, ZodArray, ZodUnion, ZodNull, ZodUndefined, ZodError } from '..';
+  nativeEnum = 'nativeEnum',
+// type Check<T> = {
+//   check: (arg: T) => any;
+//   path?: (string | number)[];
+//   // message?: string;
+//   // params?: {[k:string]:any}
+// } & util.Omit<CustomError, 'code' | 'path'>;
+
-} & util.Omit<CustomError, 'code' | 'path'>;
+  message?: string;
+  params?: { [k: string]: any };
+};
+
+
+  safeParse: (
+    x: Type | unknown,
+    params?: ParseParams,
+  ) => { success: true; data: Type } | { success: false; error: ZodError } = data => {
+    try {
+      const parsed = this.parse(data);
+      return {
+        success: true,
+        data: parsed,
+      };
+    } catch (err) {
+      if (err instanceof ZodError) {
+        return {
+          success: false,
+          error: err,
+        };
+      }
+      throw err;
+    }
+  };
-  refine = <Val extends (arg: Type) => any>(
-    check: Val,
+  refine = <Func extends (arg: Type) => any>(
+    check: Func,
+    this._def = def;
-    this._def = def;"
colinhacks_zod,84abfa00e27ba39c454379e55771b4fa76f0fbfc,Merge branch 'dev' into scalars,src/types/object.ts,"+import { isScalar } from '../isScalar';
+export type Scalars =
+  | string
+  | string[]
+  | number
+  | number[]
+  | boolean
+  | boolean[]
+  | bigint
+  | bigint[]
+  | undefined
+  | null;
+
+  primitives = (): ZodObject<
+    objectUtil.ObjectType<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key].optional();
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  nonprimitives = (): ZodObject<
+    objectUtil.ObjectType<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (!isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key].optional();
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+","-  ): ZodObject<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
-  ): ZodObject<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {","+import { isScalar } from '../isScalar';
+export type Scalars =
+  | string
+  | string[]
+  | number
+  | number[]
+  | boolean
+  | boolean[]
+  | bigint
+  | bigint[]
+  | undefined
+  | null;
+
-  ): ZodObject<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>, Params> => {
-  ): ZodObject<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }, Params> => {
+  ): ZodObject<objectUtil.NoNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>, Params> => {
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  primitives = (): ZodObject<
+    objectUtil.ObjectType<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? T[k] : never }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key].optional();
+      }
+    }
+    return new ZodObject({
+      ...this._def,
+      shape: () => newShape,
+    });
+  };
+
+  nonprimitives = (): ZodObject<
+    objectUtil.ObjectType<{ [k in keyof T]: [T[k]['_type']] extends [Scalars] ? never : T[k] }>,
+    Params
+  > => {
+    const newShape: any = {};
+    for (const key in this.shape) {
+      if (!isScalar(this.shape[key])) {
+        newShape[key] = this.shape[key].optional();
+      }"
colinhacks_zod,89528da72a2ff0da28894fd69945932c83094c4e,Synced with master,package.json,"-  ""version"": ""1.9.0"",
+  ""version"": ""1.10.0-alpha.2"",","-  ""version"": ""1.9.0"",
+  ""version"": ""1.10.0"",
-    ""typescript"": ""3.2""
+    ""typescript"": ""3.3""","-  ""version"": ""1.9.0"",
+  ""version"": ""1.11.0-alpha.1"",
-    ""typescript"": ""3.2""
+    ""typescript"": ""3.3"""
colinhacks_zod,89528da72a2ff0da28894fd69945932c83094c4e,Synced with master,src/parser.ts,"+    case z.ZodTypes.codec:
+      def.input.parse(obj);
+      const transformed = def.transformer(obj);
+      return def.output.parse(transformed);
+","-type StripErrorKeys<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = StripErrorKeys<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+// conditional required to distribute union
+type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
-      const noMethodCheck = { ...check };
-      delete noMethodCheck.check;
+      const { check: checkMethod, ...noMethodCheck } = check;","-type StripErrorKeys<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
-export type MakeErrorData = StripErrorKeys<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+// conditional required to distribute union
+type stripPath<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
+export type MakeErrorData = stripPath<ZodSuberrorOptionalMessage> & { path?: (string | number)[] };
+    case z.ZodTypes.codec:
+      def.input.parse(obj);
+      const transformed = def.transformer(obj);
+      return def.output.parse(transformed);
+
-      const noMethodCheck = { ...check };
-      delete noMethodCheck.check;
+      const { check: checkMethod, ...noMethodCheck } = check;"
colinhacks_zod,89528da72a2ff0da28894fd69945932c83094c4e,Synced with master,src/playground.ts,"+// import { ZodCodec } from './types/codec';
-const FormData = z
-  .object({
-    email: z.string().email(),
-    password: z.string().min(10),
-    confirm: z.string().min(10),
-  })
-  .refine(obj => obj.password === obj.confirm, {
-    message: 'Passwords do not match',
-    path: ['confirm'], // sets the path of the error thrown by this refinement
-  });
+const test = z.codec(z.string(), z.string(), x => x.trim().toUpperCase());
+const adsf = test.parse(' asdf ');
+console.log(adsf); // => 'ASDF'
-try {
-  FormData.parse({
-    email: 'not an email',
-    password: 'tooshort',
-    confirm: 'nomatch',
-  });
-} catch (err) {
-  if (!(err instanceof z.ZodError)) throw err;
+const stringToNumber = z.number().accepts(z.string().or(z.number()), data => parseFloat(`${data}`));
+console.log(stringToNumber.parse('5') * 5); // 25
-  console.log(err.errors);
-  /*
-  [
-    { code: 'invalid_string', validation: 'email', path: ['email'], message: 'Invalid email' },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['password'],
-      message: 'Should be at least 10 characters',
-    },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['confirm'],
-      message: 'Should be at least 10 characters',
-    },
-    { code: 'custom_error', message: 'Passwords do not match', path: ['confirm'] },
-  ]; 
-  */
+export const parseAndCatch = <T extends z.ZodType<any, any>>(schema: T, data: unknown): T['_type'] => {
+  try {
+    return schema.parse(data);
+  } catch (err) {
+    if (err instanceof z.ZodError) {
+      throw new Error();
+      // transform err.errors and throw custom error class
+    } else {
+      throw new Error();
+    }
+  }
+};
-  console.log(err.formErrors);
-  /*
-    {
-    formErrors: [],
-    fieldErrors: {
-      email: ['Invalid email'],
-      password: ['Should be at least 10 characters'],
-      confirm: ['Should be at least 10 characters', 'Passwords do not match'],
-    },
+export const parseFactory = <T extends z.ZodType<any, any>>(schema: T) => (data: unknown): T['_type'] => {
+  try {
+    return schema.parse(data);
+  } catch (err) {
+    if (err instanceof z.ZodError) {
+      throw new Error();
+      // transform err.errors and throw custom error class
+    } else {
+      throw new Error();
+    }
-  */
-}
+};
+
+const user = z.object({ name: z.string() });
+const userParse = parseFactory(user);
+const myUser = userParse({ name: 'asdf' });
+console.log(JSON.stringify(myUser, null, 2));
+
+// class MyZodString extends z.ZodString {
+//   _length: number;
+
+//   length(...args: Parameters<z.ZodString['length']>): this {
+//     const [len, err] = args;
+//     this._length = len;
+//     return super.length(len, err);
+//   }
+// }
+
+// const u = z.string().uuid();
+const uuid = '9491d710-3185-4e06-bea0-6a2f275345e0';
+const uuidRegex = /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}){1}/i;
+
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+console.log(uuidRegex.test(uuid));
+// console.log(u.parse(uuid));
+// console.log(u.parse(uuid));","-import * as z from '.';
+// import * as z from '.';
-const FormData = z
-  .object({
-    email: z.string().email(),
-    password: z.string().min(10),
-    confirm: z.string().min(10),
-  })
-  .refine(obj => obj.password === obj.confirm, {
-    message: 'Passwords do not match',
-    path: ['confirm'], // sets the path of the error thrown by this refinement
-  });
+// const ZodRHF = <T extends z.ZodType<any,any>>(schema:T)=>(values:any)=>{
+//   try{
+//     schema.parse(values)
+//     return {}
+//   }catch(err){
+//     return (err as z.ZodError).formErrors.fieldErrors;
+//   }
+// }
-try {
-  FormData.parse({
-    email: 'not an email',
-    password: 'tooshort',
-    confirm: 'nomatch',
-  });
-} catch (err) {
-  if (!(err instanceof z.ZodError)) throw err;
+// z.string()
+//   .parseAsync(undefined)
+//   .catch(err => console.log(JSON.stringify(err.errors, null, 2)));
-  console.log(err.errors);
-  /*
-  [
-    { code: 'invalid_string', validation: 'email', path: ['email'], message: 'Invalid email' },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['password'],
-      message: 'Should be at least 10 characters',
-    },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['confirm'],
-      message: 'Should be at least 10 characters',
-    },
-    { code: 'custom_error', message: 'Passwords do not match', path: ['confirm'] },
-  ]; 
-  */
-
-  console.log(err.formErrors);
-  /*
-    {
-    formErrors: [],
-    fieldErrors: {
-      email: ['Invalid email'],
-      password: ['Should be at least 10 characters'],
-      confirm: ['Should be at least 10 characters', 'Passwords do not match'],
-    },
-  }
-  */
-}
+// export const errorMap: z.ZodErrorMap = (err, ctx) => {
+//   if (err.code === z.ZodErrorCode.invalid_type) {
+//     if (err.received === 'undefined') {
+//       return { message: 'Required.' };
+//     }
+//   }
+//   return { message: ctx.defaultError };
+// };","-import * as z from '.';
-
-const FormData = z
-  .object({
-    email: z.string().email(),
-    password: z.string().min(10),
-    confirm: z.string().min(10),
-  })
-  .refine(obj => obj.password === obj.confirm, {
-    message: 'Passwords do not match',
-    path: ['confirm'], // sets the path of the error thrown by this refinement
-  });
-
-try {
-  FormData.parse({
-    email: 'not an email',
-    password: 'tooshort',
-    confirm: 'nomatch',
-  });
-} catch (err) {
-  if (!(err instanceof z.ZodError)) throw err;
-
-  console.log(err.errors);
-  /*
-  [
-    { code: 'invalid_string', validation: 'email', path: ['email'], message: 'Invalid email' },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['password'],
-      message: 'Should be at least 10 characters',
-    },
-    {
-      code: 'too_small',
-      minimum: 10,
-      type: 'string',
-      inclusive: true,
-      path: ['confirm'],
-      message: 'Should be at least 10 characters',
-    },
-    { code: 'custom_error', message: 'Passwords do not match', path: ['confirm'] },
-  ]; 
-  */
-
-  console.log(err.formErrors);
-  /*
-    {
-    formErrors: [],
-    fieldErrors: {
-      email: ['Invalid email'],
-      password: ['Should be at least 10 characters'],
-      confirm: ['Should be at least 10 characters', 'Passwords do not match'],
-    },
-  }
-  */
-}"
colinhacks_zod,4d9d1155bc7583c1efe0da7eaa2eb214dc24bab6,Fixed some merge conflicts,src/errorMap.ts,"-  return `Invalid input.`;
+  // return `Invalid input.`;","-export type ErrorMap = typeof defaultErrorMap;
+export type ZodErrorMap = typeof defaultErrorMap;
+  let message: string;
-      return `Invalid input: expected ${error.expected}, received ${error.received}`;
+      message = `Invalid input: expected ${error.expected}, received ${error.received}`;
+      break;
-      return `List must contain at least one item`;
+      message = `List must contain at least one item`;
+      break;
-      return `Unrecognized key(s) in object: ${error.keys.map(k => `'${k}'`).join(', ')}`;
+      message = `Unrecognized key(s) in object: ${error.keys.map(k => `'${k}'`).join(', ')}`;
+      break;
-      return `Invalid input`;
+      message = `Invalid input`;
+      break;
-      return `Expected list of ${error.expected} items, received ${error.received} items`;
+      message = `Expected list of ${error.expected} items, received ${error.received} items`;
+      break;
-      return `Input must be ""${error.expected}""`;
+      message = `Input must be ""${error.expected}""`;
+      break;
-      return `Input must be one of these values: ${error.options.join(', ')}`;
+      message = `Input must be one of these values: ${error.options.join(', ')}`;
+      break;
-      return `Invalid function arguments`;
+      message = `Invalid function arguments`;
+      break;
-      return `Invalid function return type`;
+      message = `Invalid function return type`;
+      break;
-      return `Invalid date`;
+      message = `Invalid date`;
+      break;
-      return `Invalid input.`;
+      message = `Invalid input.`;
+      break;
+      message = `Invalid input.`;
-  return `Invalid input.`;
+  return message;
+  // return `Invalid input.`;","-export type ErrorMap = typeof defaultErrorMap;
+export type ZodErrorMap = typeof defaultErrorMap;
+  let message: string;
-      return `Invalid input: expected ${error.expected}, received ${error.received}`;
+      message = `Invalid input: expected ${error.expected}, received ${error.received}`;
+      break;
-      return `List must contain at least one item`;
+      message = `List must contain at least one item`;
+      break;
-      return `Unrecognized key(s) in object: ${error.keys.map(k => `'${k}'`).join(', ')}`;
+      message = `Unrecognized key(s) in object: ${error.keys.map(k => `'${k}'`).join(', ')}`;
+      break;
-      return `Invalid input`;
+      message = `Invalid input`;
+      break;
-      return `Expected list of ${error.expected} items, received ${error.received} items`;
+      message = `Expected list of ${error.expected} items, received ${error.received} items`;
+      break;
-      return `Input must be ""${error.expected}""`;
+      message = `Input must be ""${error.expected}""`;
+      break;
-      return `Input must be one of these values: ${error.options.join(', ')}`;
+      message = `Input must be one of these values: ${error.options.join(', ')}`;
+      break;
-      return `Invalid function arguments`;
+      message = `Invalid function arguments`;
+      break;
-      return `Invalid function return type`;
+      message = `Invalid function return type`;
+      break;
-      return `Invalid date`;
+      message = `Invalid date`;
+      break;
-      return `Invalid input.`;
+      message = `Invalid input.`;
+      break;
+      message = `Invalid input.`;
-  return `Invalid input.`;
+<<<<<<< HEAD
+=======
+  return message;
+>>>>>>> zod2
+  // return `Invalid input.`;"
colinhacks_zod,4d9d1155bc7583c1efe0da7eaa2eb214dc24bab6,Fixed some merge conflicts,src/helpers/util.ts,"-
+  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;","+  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;","+  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
+<<<<<<< HEAD
+=======
+>>>>>>> zod2"
colinhacks_zod,4d9d1155bc7583c1efe0da7eaa2eb214dc24bab6,Fixed some merge conflicts,src/index.ts,"-export type toZod<T> = toZod<T>;
+export { toZod };","+import { ZodVoid, ZodVoidDef } from './types/void';
-import { TypeOf, ZodType, ZodTypeAny } from './types/base';
-import { ZodError } from './ZodError';
+import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+import { ZodError, ZodErrorCode } from './ZodError';
+import { ZodErrorMap } from './errorMap';
+import { toZod } from './toZod';
+import { ZodCodeGenerator } from './codegen';
-import { toZod } from './toZod';
-
+export { ZodTypeDef, ZodTypes };
+  | ZodVoidDef
+const voidType = ZodVoid.create;
+
+const codegen = ZodCodeGenerator.create;
+  voidType as void,
+  codegen,
-export type toZod<T> = toZod<T>;
+export { toZod };
+  ZodVoid,
+  ZodErrorMap,
+  ZodErrorCode,
+  ZodCodeGenerator,","+import { ZodVoid, ZodVoidDef } from './types/void';
-import { TypeOf, ZodType, ZodTypeAny } from './types/base';
-import { ZodError } from './ZodError';
+import { TypeOf, ZodType, ZodTypeAny, ZodTypeDef, ZodTypes } from './types/base';
+import { ZodError, ZodErrorCode } from './ZodError';
+import { ZodErrorMap } from './errorMap';
+import { toZod } from './toZod';
+import { ZodCodeGenerator } from './codegen';
-import { toZod } from './toZod';
-
+export { ZodTypeDef, ZodTypes };
+  | ZodVoidDef
+const voidType = ZodVoid.create;
+
+const codegen = ZodCodeGenerator.create;
+  voidType as void,
+  codegen,
-export type toZod<T> = toZod<T>;
+export { toZod };
+  ZodVoid,
+  ZodErrorMap,
+  ZodErrorCode,
+  ZodCodeGenerator,"
colinhacks_zod,4d9d1155bc7583c1efe0da7eaa2eb214dc24bab6,Fixed some merge conflicts,src/parser.ts,"-type StripErrorKeys<T> = T extends any ? util.Omit<T, 'path'> : never;
+type StripErrorKeys<T> = T extends any ? util.OmitKeys<T, 'path'> : never;","-import { ErrorMap, defaultErrorMap } from './errorMap';
+import { ZodErrorMap, defaultErrorMap } from './errorMap';
-  errorMap?: ErrorMap;
+  errorMap?: ZodErrorMap;
+  'void',
-type StripErrorKeys<T> = T extends any ? util.Omit<T, 'path'> : never;
+type StripErrorKeys<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
+    case z.ZodTypes.void:
+      if (parsedType !== ParsedType.undefined && parsedType !== ParsedType.null) {
+        error.addError(makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.void, received: parsedType }));
+        throw error;
+      }
+      break;","-import { ErrorMap, defaultErrorMap } from './errorMap';
+import { ZodErrorMap, defaultErrorMap } from './errorMap';
-  errorMap?: ErrorMap;
+  errorMap?: ZodErrorMap;
+  'void',
-type StripErrorKeys<T> = T extends any ? util.Omit<T, 'path'> : never;
+<<<<<<< HEAD
+type StripErrorKeys<T> = T extends any ? util.OmitKeys<T, 'path'> : never;
+=======
+type StripErrorKeys<T extends object> = T extends any ? util.OmitKeys<T, 'path'> : never;
+>>>>>>> zod2
+    case z.ZodTypes.void:
+      if (parsedType !== ParsedType.undefined && parsedType !== ParsedType.null) {
+        error.addError(makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.void, received: parsedType }));
+        throw error;
+      }
+      break;"
colinhacks_zod,4d9d1155bc7583c1efe0da7eaa2eb214dc24bab6,Fixed some merge conflicts,src/playground.ts,"-import * as z from '.';
-import { ZodErrorCode } from './ZodError';
-import { ErrorMap } from './errorMap';
-
-interface Category {
-  name: string;
-  subcategories: Category[];
-}
-
-const Category: z.toZod<Category> = z.lazy.object(() => ({
-  name: z.string(),
-  subcategories: z.array(Category),
-}));
-
-const errorMap: ErrorMap = (error, ctx) => {
-  if (error.code === ZodErrorCode.invalid_type) {
-    if (error.expected === 'string') {
-      return ""This ain't no string!"";
-    }
-  }
-  if (error.code === ZodErrorCode.custom_error) {
-    return JSON.stringify(error.params, null, 2);
-  }
-  return ctx.defaultError;
-};
-errorMap;
-try {
-  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
-    return arg.length as any;
-  });
-  checker('12' as any);
-
-  // z.string()
-  //   .refinement({
-  //     check: val => val.length > 12,
-  //     // params: { test: 15 },
-  //     message: 'Override!',
-  //   })
-  //   .parse('asdf', { errorMap });
-} catch (err) {
-  console.log(JSON.stringify(err.errors, null, 2));
-}
-
-try {
-  const validationSchema = z
-    .object({
-      firstName: z.string().optional(),
-      lastName: z.string().optional(),
-      email: z.string().email(),
-      password: z.string(),
-      confirmPassword: z.string(),
-    })
-    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
-
-  validationSchema.parse({
-    firstName: 'zod',
-    lastName: '',
-    email: 'theba@zod.c',
-    password: 'thetetathea',
-    confirmPassword: 'thethtbet',
-  });
-} catch (err) {
-  console.log(JSON.stringify(err.errors, null, 2));
-}
-
-// z.number().parse('12', { errorMap });
+// import * as z from '.';
+// import { ZodErrorCode } from './ZodError';
+// import { ErrorMap } from './errorMap';
-// const y = z.lazy(()=>z.string());
-
-// const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+// const Category: z.toZod<Category> = z.lazy.object(() => ({
-// const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'] as const;
-// const literals = STATUSES.map(z.literal);
-// // const StatusSchema = z.union(STATUSES.map(z.literal));
-// const StatusSchema2 = z.enum(STATUSES);
-// const StatusSchema3 = z.enum(['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed']);
-// const asdf = StatusSchema3.OptionsArray;
-// const asdf = Object.values(StatusSchema3.Values);
-// StatusSchema3._def.values;
-// StatusSchema3.Values;
-// type StatusSchema2 = z.infer<typeof StatusSchema2>
+// const errorMap: ErrorMap = (error, ctx) => {
+//   if (error.code === ZodErrorCode.invalid_type) {
+//     if (error.expected === 'string') {
+//       return ""This ain't no string!"";
+//     }
+//   }
+//   if (error.code === ZodErrorCode.custom_error) {
+//     return JSON.stringify(error.params, null, 2);
+//   }
+//   return ctx.defaultError;
+// };
+// errorMap;
+// try {
+//   const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
+//     return arg.length as any;
+//   });
+//   checker('12' as any);
-// const fishTypes = ['Salmon', 'Tuna', 'Trout'] as const;
-// const FishEnum = z.enum(fishTypes);
+//   // z.string()
+//   //   .refinement({
+//   //     check: val => val.length > 12,
+//   //     // params: { test: 15 },
+//   //     message: 'Override!',
+//   //   })
+//   //   .parse('asdf', { errorMap });
+// } catch (err) {
+//   console.log(JSON.stringify(err.errors, null, 2));
+// }
+
+// try {
+//   const validationSchema = z
+//     .object({
+//       firstName: z.string().optional(),
+//       lastName: z.string().optional(),
+//       email: z.string().email(),
+//       password: z.string(),
+//       confirmPassword: z.string(),
+//     })
+//     .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+
+//   validationSchema.parse({
+//     firstName: 'zod',
+//     lastName: '',
+//     email: 'theba@zod.c',
+//     password: 'thetetathea',
+//     confirmPassword: 'thethtbet',
+//   });
+// } catch (err) {
+//   console.log(JSON.stringify(err.errors, null, 2));
+// }
+
+// // z.number().parse('12', { errorMap });
+
+// // interface Category {
+// //   name: string;
+// //   subcategories: Category[];
+// // }
+
+// // const y = z.lazy(()=>z.string());
+
+// // const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+// //   name: z.string(),
+// //   subcategories: z.array(Category),
+// // }));
+
+// // const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'] as const;
+// // const literals = STATUSES.map(z.literal);
+// // // const StatusSchema = z.union(STATUSES.map(z.literal));
+// // const StatusSchema2 = z.enum(STATUSES);
+// // const StatusSchema3 = z.enum(['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed']);
+// // const asdf = StatusSchema3.OptionsArray;
+// // const asdf = Object.values(StatusSchema3.Values);
+// // StatusSchema3._def.values;
+// // StatusSchema3.Values;
+// // type StatusSchema2 = z.infer<typeof StatusSchema2>
+
+// // const fishTypes = ['Salmon', 'Tuna', 'Trout'] as const;
+// // const FishEnum = z.enum(fishTypes);","-import { ZodErrorCode } from './ZodError';
-import { ErrorMap } from './errorMap';
+// import { User, Post } from './userpost';
-interface Category {
-  name: string;
-  subcategories: Category[];
-}
-
-const Category: z.toZod<Category> = z.lazy.object(() => ({
-  name: z.string(),
-  subcategories: z.array(Category),
-}));
-
-const errorMap: ErrorMap = (error, ctx) => {
-  if (error.code === ZodErrorCode.invalid_type) {
+// const gen = z.codegen();
+// gen.generate(User);
+// gen.generate(Post);
+// console.log(gen.dump());
+const errorMap: z.ZodErrorMap = (error, ctx) => {
+  if (error.code === z.ZodErrorCode.invalid_type) {
-  if (error.code === ZodErrorCode.custom_error) {
+  if (error.code === z.ZodErrorCode.custom_error) {
-errorMap;
-try {
-  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
-    return arg.length as any;
-  });
-  checker('12' as any);
-
-  // z.string()
-  //   .refinement({
-  //     check: val => val.length > 12,
-  //     // params: { test: 15 },
-  //     message: 'Override!',
-  //   })
-  //   .parse('asdf', { errorMap });
-} catch (err) {
-  console.log(JSON.stringify(err.errors, null, 2));
-}
-  const validationSchema = z
-    .object({
-      firstName: z.string().optional(),
-      lastName: z.string().optional(),
-      email: z.string().email(),
-      password: z.string(),
-      confirmPassword: z.string(),
+  z.string()
+    .refinement({
+      check: val => val.length > 12,
+      // params: { test: 15 },
+      message: 'override',
-    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
-
-  validationSchema.parse({
-    firstName: 'zod',
-    lastName: '',
-    email: 'theba@zod.c',
-    password: 'thetetathea',
-    confirmPassword: 'thethtbet',
-  });
+    .parse('asdf', { errorMap });
-  console.log(JSON.stringify(err.errors, null, 2));
+  const zerr: z.ZodError = err;
+  console.log(zerr.errors[0].message);
+  // expect(zerr.errors[0].message).toEqual('override');
-
-// z.number().parse('12', { errorMap });
-
-// interface Category {
-//   name: string;
-//   subcategories: Category[];
-// }
-
-// const y = z.lazy(()=>z.string());
-
-// const Category: z.lazyobject<Category> = z.lazy.object(() => ({
-//   name: z.string(),
-//   subcategories: z.array(Category),
-// }));
-
-// const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'] as const;
-// const literals = STATUSES.map(z.literal);
-// // const StatusSchema = z.union(STATUSES.map(z.literal));
-// const StatusSchema2 = z.enum(STATUSES);
-// const StatusSchema3 = z.enum(['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed']);
-// const asdf = StatusSchema3.OptionsArray;
-// const asdf = Object.values(StatusSchema3.Values);
-// StatusSchema3._def.values;
-// StatusSchema3.Values;
-// type StatusSchema2 = z.infer<typeof StatusSchema2>
-
-// const fishTypes = ['Salmon', 'Tuna', 'Trout'] as const;
-// const FishEnum = z.enum(fishTypes);","-import * as z from '.';
-import { ZodErrorCode } from './ZodError';
-import { ErrorMap } from './errorMap';
-
-interface Category {
-  name: string;
-  subcategories: Category[];
-}
-
-const Category: z.toZod<Category> = z.lazy.object(() => ({
-  name: z.string(),
-  subcategories: z.array(Category),
-}));
-
-const errorMap: ErrorMap = (error, ctx) => {
-  if (error.code === ZodErrorCode.invalid_type) {
-    if (error.expected === 'string') {
-      return ""This ain't no string!"";
-    }
-  }
-  if (error.code === ZodErrorCode.custom_error) {
-    return JSON.stringify(error.params, null, 2);
-  }
-  return ctx.defaultError;
-};
-errorMap;
-try {
-  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
-    return arg.length as any;
-  });
-  checker('12' as any);
-
-  // z.string()
-  //   .refinement({
-  //     check: val => val.length > 12,
-  //     // params: { test: 15 },
-  //     message: 'Override!',
-  //   })
-  //   .parse('asdf', { errorMap });
-} catch (err) {
-  console.log(JSON.stringify(err.errors, null, 2));
-}
-
-try {
-  const validationSchema = z
-    .object({
-      firstName: z.string().optional(),
-      lastName: z.string().optional(),
-      email: z.string().email(),
-      password: z.string(),
-      confirmPassword: z.string(),
-    })
-    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
-
-  validationSchema.parse({
-    firstName: 'zod',
-    lastName: '',
-    email: 'theba@zod.c',
-    password: 'thetetathea',
-    confirmPassword: 'thethtbet',
-  });
-} catch (err) {
-  console.log(JSON.stringify(err.errors, null, 2));
-}
-
-// z.number().parse('12', { errorMap });
+<<<<<<< HEAD
+// import * as z from '.';
+// import { ZodErrorCode } from './ZodError';
+// import { ErrorMap } from './errorMap';
-// const y = z.lazy(()=>z.string());
-
-// const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+// const Category: z.toZod<Category> = z.lazy.object(() => ({
-// const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'] as const;
-// const literals = STATUSES.map(z.literal);
-// // const StatusSchema = z.union(STATUSES.map(z.literal));
-// const StatusSchema2 = z.enum(STATUSES);
-// const StatusSchema3 = z.enum(['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed']);
-// const asdf = StatusSchema3.OptionsArray;
-// const asdf = Object.values(StatusSchema3.Values);
-// StatusSchema3._def.values;
-// StatusSchema3.Values;
-// type StatusSchema2 = z.infer<typeof StatusSchema2>
+// const errorMap: ErrorMap = (error, ctx) => {
+//   if (error.code === ZodErrorCode.invalid_type) {
+//     if (error.expected === 'string') {
+//       return ""This ain't no string!"";
+//     }
+//   }
+//   if (error.code === ZodErrorCode.custom_error) {
+//     return JSON.stringify(error.params, null, 2);
+//   }
+//   return ctx.defaultError;
+// };
+// errorMap;
+// try {
+//   const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
+//     return arg.length as any;
+//   });
+//   checker('12' as any);
-// const fishTypes = ['Salmon', 'Tuna', 'Trout'] as const;
-// const FishEnum = z.enum(fishTypes);
+//   // z.string()
+//   //   .refinement({
+//   //     check: val => val.length > 12,
+//   //     // params: { test: 15 },
+//   //     message: 'Override!',
+//   //   })
+//   //   .parse('asdf', { errorMap });
+// } catch (err) {
+//   console.log(JSON.stringify(err.errors, null, 2));
+// }
+
+// try {
+//   const validationSchema = z
+//     .object({
+//       firstName: z.string().optional(),
+//       lastName: z.string().optional(),
+//       email: z.string().email(),
+//       password: z.string(),
+//       confirmPassword: z.string(),
+//     })
+//     .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+
+//   validationSchema.parse({
+//     firstName: 'zod',
+//     lastName: '',
+//     email: 'theba@zod.c',
+//     password: 'thetetathea',
+//     confirmPassword: 'thethtbet',
+//   });
+// } catch (err) {
+//   console.log(JSON.stringify(err.errors, null, 2));
+// }
+
+// // z.number().parse('12', { errorMap });
+
+// // interface Category {
+// //   name: string;
+// //   subcategories: Category[];
+// // }
+
+// // const y = z.lazy(()=>z.string());
+
+// // const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+// //   name: z.string(),
+// //   subcategories: z.array(Category),
+// // }));
+
+// // const STATUSES = ['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed'] as const;
+// // const literals = STATUSES.map(z.literal);
+// // // const StatusSchema = z.union(STATUSES.map(z.literal));
+// // const StatusSchema2 = z.enum(STATUSES);
+// // const StatusSchema3 = z.enum(['Assigned', 'In Progress', 'On Location', 'Succeeded', 'Failed']);
+// // const asdf = StatusSchema3.OptionsArray;
+// // const asdf = Object.values(StatusSchema3.Values);
+// // StatusSchema3._def.values;
+// // StatusSchema3.Values;
+// // type StatusSchema2 = z.infer<typeof StatusSchema2>
+
+// // const fishTypes = ['Salmon', 'Tuna', 'Trout'] as const;
+// // const FishEnum = z.enum(fishTypes);
+=======
+import * as z from '.';
+// import { User, Post } from './userpost';
+
+// const gen = z.codegen();
+// gen.generate(User);
+// gen.generate(Post);
+// console.log(gen.dump());
+const errorMap: z.ZodErrorMap = (error, ctx) => {
+  if (error.code === z.ZodErrorCode.invalid_type) {
+    if (error.expected === 'string') {
+      return ""This ain't no string!"";
+    }
+  }
+  if (error.code === z.ZodErrorCode.custom_error) {
+    return JSON.stringify(error.params, null, 2);
+  }
+  return ctx.defaultError;
+};
+
+try {
+  z.string()
+    .refinement({
+      check: val => val.length > 12,
+      // params: { test: 15 },
+      message: 'override',
+    })
+    .parse('asdf', { errorMap });
+} catch (err) {
+  const zerr: z.ZodError = err;
+  console.log(zerr.errors[0].message);
+  // expect(zerr.errors[0].message).toEqual('override');
+}
+>>>>>>> zod2"
colinhacks_zod,4e9dd5593495d9807279463c903df61775d83cb9,"Fixed merge conflicts, got z.lazy.object working with z.toZod. holy grail achieved.",src/parser.ts,"-import { ZodError } from './ZodError';
+import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ErrorMap, defaultErrorMap } from './errorMap';
-  seen: { schema: any; objects: any[] }[];
+  seen?: { schema: any; objects: any[] }[];
+  path?: (string | number)[];
+  errorMap?: ErrorMap;
-export const ZodParser = (schemaDef: z.ZodTypeDef) => (obj: any, params: ParseParams = { seen: [] }) => {
+export const getParsedType = (data: any): ParsedType => {
+  if (typeof data === 'string') return 'string';
+  if (typeof data === 'number') {
+    if (Number.isNaN(data)) return 'nan';
+    return 'number';
+  }
+  if (typeof data === 'boolean') return 'boolean';
+  if (typeof data === 'bigint') return 'bigint';
+  if (typeof data === 'symbol') return 'symbol';
+  if (data instanceof Date) return 'date';
+  if (typeof data === 'function') return 'function';
+  if (data === undefined) return 'undefined';
+  if (data === null) return 'null';
+  if (typeof data === 'undefined') return 'undefined';
+  if (typeof data === 'object') {
+    if (Array.isArray(data)) return 'array';
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+      // && util.getObjectType(data) !== 'Promise'
+    ) {
+      return 'promise';
+    }
+    return 'object';
+  }
+  return 'unknown';
+};
+
+export const ParsedType = util.arrayToEnum([
+  'string',
+  'nan',
+  'number',
+  'boolean',
+  'date',
+  'bigint',
+  'symbol',
+  'function',
+  'undefined',
+  'null',
+  'array',
+  'object',
+  'unknown',
+  'promise',
+]);
+
+// export const ParsedType = arrayToEnum(ParsedTypeArray);
+export type ParsedType = keyof typeof ParsedType;
+
+type StripErrorKeys<T> = T extends any ? util.Omit<T, 'path'> : never;
+
+export const ZodParser = (schemaDef: z.ZodTypeDef) => (
+  obj: any,
+  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] },
+) => {
+  const params: Required<ParseParams> = {
+    seen: baseParams.seen || [],
+    path: baseParams.path || [],
+    errorMap: baseParams.errorMap || defaultErrorMap,
+    // (...args: [any, any]) => {
+    //   const customMap = baseParams.errorMap || function() {};
+    //   return customMap(...args) || defaultErrorMap(...args);
+    // if(baseParams.errorMap){
+    //   const customErrorMsg = baseParams.errorMap(...args);
+    //   if(customErrorMsg) return
+    //   if(baseParams.errorMap(..args))
+    // }
+    // return defaultErrorMap(...args);
+    // return baseParams.errorMap || defaultErrorMap,
+    // },
+  };
+
+  const makeError = (
+    errorData: StripErrorKeys<ZodSuberrorOptionalMessage>,
+    // details: object = {},
+  ): ZodSuberror => {
+    const errorArg = { ...errorData, path: params.path };
+    const ctxArg = { metadata: {}, data: obj };
+
+    const defaultError =
+      defaultErrorMap === params.errorMap
+        ? `Invalid value`
+        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+    return {
+      ...errorData,
+      path: params.path,
+      message: errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError }),
+    };
+  };
+
+
+  const error = new ZodError([]);
+
+  const parsedType = getParsedType(obj);
+
+  // runs all invalid_type checks
+  // if (Object.keys(ParsedType).includes(def.t)) {
+  //   if (parsedType !== def.t) {
+  //     console.log(`def.t: ${def.t}`);
+  //     console.log(`found: ${parsedType}`);
+  //     error.addError(
+  //       makeError({ code: ZodErrorCode.invalid_type, expected: def.t as ParsedType, received: parsedType }),
+  //     );
+  //     throw error;
+  //   }
+  // }
+
-      if (typeof obj !== 'string') throw ZodError.fromString(`Non-string type: ${typeof obj}`);
+      // error.addError()
+      if (parsedType !== ParsedType.string) {
+        //throw ZodError.fromString(`Non-string type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.string, received: parsedType }),
+        );
+        throw error;
+      }
-      if (typeof obj !== 'number') throw ZodError.fromString(`Non-number type: ${typeof obj}`);
+      if (parsedType !== ParsedType.number) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: parsedType }),
+        );
+        throw error;
+      }
-        throw ZodError.fromString(`Non-number type: NaN`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: ParsedType.nan }),
+        );
+        throw error;
-      if (typeof obj !== 'bigint') {
-        throw ZodError.fromString(`Non-bigint type: ${typeof obj}.`);
+      if (parsedType !== ParsedType.bigint) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-bigint type: ${typeof obj}.`);
-      if (typeof obj !== 'boolean') throw ZodError.fromString(`Non-boolean type: ${typeof obj}`);
+      if (parsedType !== ParsedType.boolean) {
+        // throw ZodError.fromString(`Non-boolean type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.boolean, received: parsedType }),
+        );
+        throw error;
+      }
-      if (obj !== undefined) throw ZodError.fromString(`Non-undefined type:Found: ${typeof obj}`);
+      if (parsedType !== ParsedType.undefined) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.undefined, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-undefined type:Found: ${typeof obj}`);
+      }
-      if (obj !== null) throw ZodError.fromString(`Non-null type: ${typeof obj}`);
+      if (parsedType !== ParsedType.null) {
+        // throw ZodError.fromString(`Non-null type: ${typeof obj}`);
+        error.addError(makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.null, received: parsedType }));
+        throw error;
+      }
-      if (!Array.isArray(obj)) throw ZodError.fromString(`Non-array type: ${typeof obj}`);
-      const arrayError = ZodError.create([]);
+      if (parsedType !== ParsedType.array) {
+        // throw ZodError.fromString(`Non-array type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.array, received: parsedType }),
+        );
+        throw error;
+      }
+      const data: any[] = obj;
+      // const arrayError = ZodError.create([]);
-        throw ZodError.fromString('Array cannot be empty');
-      }
-      obj.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, params);
+        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
+        throw error;
+        // throw ZodError.fromString('Array cannot be empty');
+      }
+      data.map((item, i) => {
+        try {
+          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          arrayError.mergeChild(i, err);
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);
+          // arrayError.mergeChild(i, err);
-      if (!arrayError.empty) {
+      if (!error.isEmpty) {
-        throw arrayError;
+        throw error;
-      if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
-      if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
+      if (parsedType !== ParsedType.object) {
+        // throw ZodError.fromString(`Non-object type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.object, received: parsedType }),
+        );
+        throw error;
+      }
-          throw ZodError.fromString(`Unexpected key(s) in object: ${extraKeys.map(k => `'${k}'`).join(', ')}`);
-        }
-      }
-
-      const parsedObject: any = {};
-      const objectError = ZodError.create([]);
+          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+          // throw error;
+          // throw ZodError.fromString(`Unexpected key(s) in object: ${extraKeys.map(k => `'${k}'`).join(', ')}`);
+        }
+      }
+
+      // const parsedObject: any = {};
+      // const objectError = ZodError.create([]);
-          const parsedEntry = def.shape[key].parse(obj[key], params);
-          parsedObject[key] = parsedEntry;
-        } catch (err) {
-          objectError.mergeChild(key, err);
-        }
-      }
-
-      if (!objectError.empty) {
-        throw objectError; //ZodError.fromString(objectErrors.join('\n'));
-      }
+          // const parsedEntry =
+          def.shape[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          // parsedObject[key] = parsedEntry;
+        } catch (err) {
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);
+          // objectError.mergeChild(key, err);
+        }
+      }
+
+      // if (!objectError.isEmpty) {
+      //   throw objectError; //ZodError.fromString(objectErrors.join('\n'));
+      // }
-      const unionErrors: string[] = [];
+      // const unionErrors: string[] = [];
+      const unionErrors: ZodError[] = [];
-          unionErrors.push(`\tunion option #${def.options.indexOf(option)}: ${err.message}`);
+          unionErrors.push(err);
+          // unionErrors.push(`\tunion option #${def.options.indexOf(option)}: ${err.message}`);
-      if (isValid === false) {
-        throw ZodError.fromString('\n' + unionErrors.join('\n'));
-        // throw ZodError.fromString(
-        //   `Error parsing union.\nReceived: ${JSON.stringify(obj, null, 2)}\nExpected: ${def.options
-        //     .map(x => x._def.t)
-        //     .join(' OR ')}`,
-        // );
-      }
+      // if all but one of the union types threw a type error
+      // merge in the one non-type-error ZodError the usual way
+      if (!isValid) {
+        const filteredErrors = unionErrors.filter(err => {
+          return err.errors[0].code !== 'invalid_type';
+        });
+        if (filteredErrors.length === 1) {
+          error.addErrors(filteredErrors[0].errors);
+        } else {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.invalid_union,
+              suberrors: unionErrors,
+            }),
+          );
+        }
+      }
+      // if (!isValid) {
+      // throw ZodError.fromString('\n' + unionErrors.join('\n'));
+      // throw ZodError.fromString(
+      //   `Error parsing union.\nReceived: ${JSON.stringify(obj, null, 2)}\nExpected: ${def.options
+      //     .map(x => x._def.t)
+      //     .join(' OR ')}`,
+      // );
+      // }
-      const errors: string[] = [];
+      // const errors: string[] = [];
-        errors.push(`Left side of intersection: ${err.message}`);
+        error.addErrors(err.errors);
+        // errors.push(`Left side of intersection: ${err.message}`);
-        errors.push(`Right side of intersection: ${err.message}`);
-      }
-
-      if (errors.length) {
-        throw ZodError.fromString(errors.join('\n'));
-      }
+        error.addErrors(err.errors);
+        // errors.push(`Right side of intersection: ${err.message}`);
+      }
+
+      // if (errors.length) {
+      //   throw ZodError.fromString(errors.join('\n'));
+      // }
-      if (!Array.isArray(obj)) {
+      if (parsedType !== ParsedType.array) {
-        throw ZodError.fromString('Non-array type detected; invalid tuple.');
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.array, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString('Non-array type detected; invalid tuple.');
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_array_length, expected: def.items.length, received: obj.length }),
+        );
-        throw ZodError.fromString(
-          `Incorrect number of elements in tuple: expected ${def.items.length}, got ${obj.length}`,
-        );
-      }
-
-      const tupleError = ZodError.create([]);
+        // throw ZodError.fromString(
+        //   `Incorrect number of elements in tuple: expected ${def.items.length}, got ${obj.length}`,
+        // );
+      }
+
+      // const data:any[] = obj;
+      // const tupleError = ZodError.create([]);
-      for (const index in obj) {
-        const item = obj[index];
+      const tupleData: any[] = obj;
+      for (const index in tupleData) {
+        const item = tupleData[index];
-          parsedTuple.push(itemParser.parse(item, params));
-        } catch (err) {
-          console.log(`mering child: ${index}`);
-          tupleError.mergeChild(index, err);
-        }
-      }
-      if (!tupleError.empty) {
-        throw tupleError;
-      }
+          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+        } catch (err) {
+          // console.log(`mering child: ${index}`);
+          error.addErrors(err.errors);
+          // tupleError.mergeChild(index, err);
+        }
+      }
+      // if (!tupleError.isEmpty) {
+      //   throw tupleError;
+      // }
-      if (obj !== def.value) throw ZodError.fromString(`${obj} !== ${def.value}`);
+      if (obj !== def.value) {
+        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
+        // throw ZodError.fromString(`${obj} !== ${def.value}`);
+      }
-        throw ZodError.fromString(`""${obj}"" does not match any value in enum`);
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: def.values,
+          }),
+        );
+        // throw ZodError.fromString(`""${obj}"" does not match any value in enum`);
-      if (typeof obj !== 'function') {
-        throw ZodError.fromString(`Non-function type: ""${typeof obj}""`);
+      if (parsedType !== ParsedType.function) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.function,
+            received: parsedType,
+          }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-function type: ""${typeof obj}""`);
-          const result = obj(...(args as any));
+        } catch (err) {
+          if (err instanceof ZodError) {
+            const argsError = new ZodError([]);
+            argsError.addError(
+              makeError({
+                code: ZodErrorCode.invalid_arguments,
+                suberrors: [err],
+              }),
+            );
+            throw argsError;
+          }
+          throw err;
+        }
+
+        const result = obj(...(args as any));
+
+        try {
-          return result;
-        } catch (err) {
+        } catch (err) {
+          if (err instanceof ZodError) {
+            const returnsError = new ZodError([]);
+            returnsError.addError(
+              makeError({
+                code: ZodErrorCode.invalid_return_type,
+                suberrors: [err],
+              }),
+            );
+            throw returnsError;
+          }
+
+        def.returns.parse(result);
+        return result;
-      if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
-      if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
-
-      const parsedRecord: any = {};
-      const recordError = new ZodError();
+      if (parsedType !== ParsedType.object) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.object,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      // if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
+      // if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
+
+      // const parsedRecord: any = {};
+      // const recordError = new ZodError([]);
-          parsedRecord[key] = def.valueType.parse(obj[key]);
-        } catch (err) {
-          recordError.mergeChild(key, err);
-        }
-      }
-      if (!recordError.empty) throw recordError;
+          // parsedRecord[key] =
+          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+        } catch (err) {
+          error.addErrors(err.errors);
+          // recordError.mergeChild(key, err);
+        }
+      }
+      // if (!recordError.isEmpty) throw recordError;
-      if (obj instanceof Date) {
-        if (isNaN(obj.getTime())) {
-          // return obj;
-          // } else {
-          throw ZodError.fromString(`Invalid date.`);
-        }
-      } else {
-        throw ZodError.fromString(`Non-Date type: ${typeof obj}`);
+      if (!(obj instanceof Date)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.date,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      if (isNaN(obj.getTime())) {
+        // if (isNaN(obj.getTime())) {
+        // return obj;
+        // } else {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_date,
+          }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Invalid date.`);
+        // }
-      if (!obj.then || typeof obj.then !== 'function') {
-        console.log(JSON.stringify(obj, null, 2));
-        throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
-      }
-      if (!obj.catch || typeof obj.catch !== 'function') {
-        console.log(JSON.stringify(obj, null, 2));
-        throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
-      }
+      if (parsedType !== ParsedType.promise) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.promise,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      // if (!obj.then || typeof obj.then !== 'function') {
+      //   console.log(JSON.stringify(obj, null, 2));
+      //   throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
+      // }
+      // if (!obj.catch || typeof obj.catch !== 'function') {
+      //   console.log(JSON.stringify(obj, null, 2));
+      //   throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
+      // }
-      if (def.checks) {
-        throw ZodError.fromString(""Can't apply custom validators to Promise schemas."");
-      }
+      // if (def.checks) {
+      //   throw ZodError.fromString(""Can't apply custom validators to Promise schemas."");
+      // }
-          const parsed = def.type.parse(objValue);
+          const parsed = def.type.parse(objValue, params);
-      throw ZodError.fromString(check.message || `Failed custom check.`);
+      error.addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          params: check.params,
+          message: check.message,
+        }),
+      );
+      // throw ZodError.fromString(check.message || `Failed custom check.`);
+  if (!error.isEmpty) {
+    throw error;
+  }
+","-      const shape = def.shape;
+      console.log(def.shape);
+      const shape = def.shape();
-        const shapeKeys = Object.keys(def.shape);
+        const shapeKeys = Object.keys(shape);
-          const parsedEntry = def.shape[key].parse(obj[key], params);
+          const parsedEntry = shape[key].parse(obj[key], params);","-import { ZodError } from './ZodError';
+import { ZodError, ZodErrorCode, ZodSuberror, ZodSuberrorOptionalMessage } from './ZodError';
+import { ErrorMap, defaultErrorMap } from './errorMap';
-  seen: { schema: any; objects: any[] }[];
+  seen?: { schema: any; objects: any[] }[];
+  path?: (string | number)[];
+  errorMap?: ErrorMap;
-export const ZodParser = (schemaDef: z.ZodTypeDef) => (obj: any, params: ParseParams = { seen: [] }) => {
+export const getParsedType = (data: any): ParsedType => {
+  if (typeof data === 'string') return 'string';
+  if (typeof data === 'number') {
+    if (Number.isNaN(data)) return 'nan';
+    return 'number';
+  }
+  if (typeof data === 'boolean') return 'boolean';
+  if (typeof data === 'bigint') return 'bigint';
+  if (typeof data === 'symbol') return 'symbol';
+  if (data instanceof Date) return 'date';
+  if (typeof data === 'function') return 'function';
+  if (data === undefined) return 'undefined';
+  if (data === null) return 'null';
+  if (typeof data === 'undefined') return 'undefined';
+  if (typeof data === 'object') {
+    if (Array.isArray(data)) return 'array';
+    if (
+      data.then &&
+      typeof data.then === 'function' &&
+      data.catch &&
+      typeof data.catch === 'function'
+      // && util.getObjectType(data) !== 'Promise'
+    ) {
+      return 'promise';
+    }
+    return 'object';
+  }
+  return 'unknown';
+};
+
+export const ParsedType = util.arrayToEnum([
+  'string',
+  'nan',
+  'number',
+  'boolean',
+  'date',
+  'bigint',
+  'symbol',
+  'function',
+  'undefined',
+  'null',
+  'array',
+  'object',
+  'unknown',
+  'promise',
+]);
+
+// export const ParsedType = arrayToEnum(ParsedTypeArray);
+export type ParsedType = keyof typeof ParsedType;
+
+type StripErrorKeys<T> = T extends any ? util.Omit<T, 'path'> : never;
+
+export const ZodParser = (schemaDef: z.ZodTypeDef) => (
+  obj: any,
+  baseParams: ParseParams = { seen: [], errorMap: defaultErrorMap, path: [] },
+) => {
+  const params: Required<ParseParams> = {
+    seen: baseParams.seen || [],
+    path: baseParams.path || [],
+    errorMap: baseParams.errorMap || defaultErrorMap,
+    // (...args: [any, any]) => {
+    //   const customMap = baseParams.errorMap || function() {};
+    //   return customMap(...args) || defaultErrorMap(...args);
+    // if(baseParams.errorMap){
+    //   const customErrorMsg = baseParams.errorMap(...args);
+    //   if(customErrorMsg) return
+    //   if(baseParams.errorMap(..args))
+    // }
+    // return defaultErrorMap(...args);
+    // return baseParams.errorMap || defaultErrorMap,
+    // },
+  };
+
+  const makeError = (
+    errorData: StripErrorKeys<ZodSuberrorOptionalMessage>,
+    // details: object = {},
+  ): ZodSuberror => {
+    const errorArg = { ...errorData, path: params.path };
+    const ctxArg = { metadata: {}, data: obj };
+
+    const defaultError =
+      defaultErrorMap === params.errorMap
+        ? `Invalid value`
+        : defaultErrorMap(errorArg, { ...ctxArg, defaultError: `Invalid value.` });
+    return {
+      ...errorData,
+      path: params.path,
+      message: errorData.message || params.errorMap(errorArg, { ...ctxArg, defaultError }),
+    };
+  };
+
+
+  const error = new ZodError([]);
+
+  const parsedType = getParsedType(obj);
+
+  // runs all invalid_type checks
+  // if (Object.keys(ParsedType).includes(def.t)) {
+  //   if (parsedType !== def.t) {
+  //     console.log(`def.t: ${def.t}`);
+  //     console.log(`found: ${parsedType}`);
+  //     error.addError(
+  //       makeError({ code: ZodErrorCode.invalid_type, expected: def.t as ParsedType, received: parsedType }),
+  //     );
+  //     throw error;
+  //   }
+  // }
+
-      if (typeof obj !== 'string') throw ZodError.fromString(`Non-string type: ${typeof obj}`);
+      // error.addError()
+      if (parsedType !== ParsedType.string) {
+        //throw ZodError.fromString(`Non-string type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.string, received: parsedType }),
+        );
+        throw error;
+      }
-      if (typeof obj !== 'number') throw ZodError.fromString(`Non-number type: ${typeof obj}`);
+      if (parsedType !== ParsedType.number) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: parsedType }),
+        );
+        throw error;
+      }
-        throw ZodError.fromString(`Non-number type: NaN`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: ParsedType.nan }),
+        );
+        throw error;
-      if (typeof obj !== 'bigint') {
-        throw ZodError.fromString(`Non-bigint type: ${typeof obj}.`);
+      if (parsedType !== ParsedType.bigint) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.number, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-bigint type: ${typeof obj}.`);
-      if (typeof obj !== 'boolean') throw ZodError.fromString(`Non-boolean type: ${typeof obj}`);
+      if (parsedType !== ParsedType.boolean) {
+        // throw ZodError.fromString(`Non-boolean type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.boolean, received: parsedType }),
+        );
+        throw error;
+      }
-      if (obj !== undefined) throw ZodError.fromString(`Non-undefined type:Found: ${typeof obj}`);
+      if (parsedType !== ParsedType.undefined) {
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.undefined, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-undefined type:Found: ${typeof obj}`);
+      }
-      if (obj !== null) throw ZodError.fromString(`Non-null type: ${typeof obj}`);
+      if (parsedType !== ParsedType.null) {
+        // throw ZodError.fromString(`Non-null type: ${typeof obj}`);
+        error.addError(makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.null, received: parsedType }));
+        throw error;
+      }
-      if (!Array.isArray(obj)) throw ZodError.fromString(`Non-array type: ${typeof obj}`);
-      const arrayError = ZodError.create([]);
+      if (parsedType !== ParsedType.array) {
+        // throw ZodError.fromString(`Non-array type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.array, received: parsedType }),
+        );
+        throw error;
+      }
+      const data: any[] = obj;
+      // const arrayError = ZodError.create([]);
-        throw ZodError.fromString('Array cannot be empty');
-      }
-      obj.map((item, i) => {
-        try {
-          const parsedItem = def.type.parse(item, params);
+        error.addError(makeError({ code: ZodErrorCode.nonempty_array_is_empty }));
+        throw error;
+        // throw ZodError.fromString('Array cannot be empty');
+      }
+      data.map((item, i) => {
+        try {
+          const parsedItem = def.type.parse(item, { ...params, path: [...params.path, i] });
-          arrayError.mergeChild(i, err);
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);
+          // arrayError.mergeChild(i, err);
-      if (!arrayError.empty) {
+      if (!error.isEmpty) {
-        throw arrayError;
+        throw error;
-      if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
-      if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
-
-      const shape = def.shape;
+      if (parsedType !== ParsedType.object) {
+        // throw ZodError.fromString(`Non-object type: ${typeof obj}`);
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.object, received: parsedType }),
+        );
+        throw error;
+      }
+
+      console.log(def.shape);
+      const shape = def.shape();
-        const shapeKeys = Object.keys(def.shape);
+        const shapeKeys = Object.keys(shape);
-          throw ZodError.fromString(`Unexpected key(s) in object: ${extraKeys.map(k => `'${k}'`).join(', ')}`);
-        }
-      }
-
-      const parsedObject: any = {};
-      const objectError = ZodError.create([]);
+          error.addError(makeError({ code: ZodErrorCode.unrecognized_keys, keys: extraKeys }));
+          // throw error;
+          // throw ZodError.fromString(`Unexpected key(s) in object: ${extraKeys.map(k => `'${k}'`).join(', ')}`);
+        }
+      }
+
+      // const parsedObject: any = {};
+      // const objectError = ZodError.create([]);
-          const parsedEntry = def.shape[key].parse(obj[key], params);
-          parsedObject[key] = parsedEntry;
-        } catch (err) {
-          objectError.mergeChild(key, err);
-        }
-      }
-
-      if (!objectError.empty) {
-        throw objectError; //ZodError.fromString(objectErrors.join('\n'));
-      }
+          // const parsedEntry =
+          def.shape()[key].parse(obj[key], { ...params, path: [...params.path, key] });
+          // parsedObject[key] = parsedEntry;
+        } catch (err) {
+          const zerr: ZodError = err;
+          error.addErrors(zerr.errors);
+          // objectError.mergeChild(key, err);
+        }
+      }
+
+      // if (!objectError.isEmpty) {
+      //   throw objectError; //ZodError.fromString(objectErrors.join('\n'));
+      // }
-      const unionErrors: string[] = [];
+      // const unionErrors: string[] = [];
+      const unionErrors: ZodError[] = [];
-          unionErrors.push(`\tunion option #${def.options.indexOf(option)}: ${err.message}`);
+          unionErrors.push(err);
+          // unionErrors.push(`\tunion option #${def.options.indexOf(option)}: ${err.message}`);
-      if (isValid === false) {
-        throw ZodError.fromString('\n' + unionErrors.join('\n'));
-        // throw ZodError.fromString(
-        //   `Error parsing union.\nReceived: ${JSON.stringify(obj, null, 2)}\nExpected: ${def.options
-        //     .map(x => x._def.t)
-        //     .join(' OR ')}`,
-        // );
-      }
+      // if all but one of the union types threw a type error
+      // merge in the one non-type-error ZodError the usual way
+      if (!isValid) {
+        const filteredErrors = unionErrors.filter(err => {
+          return err.errors[0].code !== 'invalid_type';
+        });
+        if (filteredErrors.length === 1) {
+          error.addErrors(filteredErrors[0].errors);
+        } else {
+          error.addError(
+            makeError({
+              code: ZodErrorCode.invalid_union,
+              suberrors: unionErrors,
+            }),
+          );
+        }
+      }
+      // if (!isValid) {
+      // throw ZodError.fromString('\n' + unionErrors.join('\n'));
+      // throw ZodError.fromString(
+      //   `Error parsing union.\nReceived: ${JSON.stringify(obj, null, 2)}\nExpected: ${def.options
+      //     .map(x => x._def.t)
+      //     .join(' OR ')}`,
+      // );
+      // }
-      const errors: string[] = [];
+      // const errors: string[] = [];
-        errors.push(`Left side of intersection: ${err.message}`);
+        error.addErrors(err.errors);
+        // errors.push(`Left side of intersection: ${err.message}`);
-        errors.push(`Right side of intersection: ${err.message}`);
-      }
-
-      if (errors.length) {
-        throw ZodError.fromString(errors.join('\n'));
-      }
+        error.addErrors(err.errors);
+        // errors.push(`Right side of intersection: ${err.message}`);
+      }
+
+      // if (errors.length) {
+      //   throw ZodError.fromString(errors.join('\n'));
+      // }
-      if (!Array.isArray(obj)) {
+      if (parsedType !== ParsedType.array) {
-        throw ZodError.fromString('Non-array type detected; invalid tuple.');
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_type, expected: ParsedType.array, received: parsedType }),
+        );
+        throw error;
+        // throw ZodError.fromString('Non-array type detected; invalid tuple.');
+        error.addError(
+          makeError({ code: ZodErrorCode.invalid_array_length, expected: def.items.length, received: obj.length }),
+        );
-        throw ZodError.fromString(
-          `Incorrect number of elements in tuple: expected ${def.items.length}, got ${obj.length}`,
-        );
-      }
-
-      const tupleError = ZodError.create([]);
+        // throw ZodError.fromString(
+        //   `Incorrect number of elements in tuple: expected ${def.items.length}, got ${obj.length}`,
+        // );
+      }
+
+      // const data:any[] = obj;
+      // const tupleError = ZodError.create([]);
-      for (const index in obj) {
-        const item = obj[index];
+      const tupleData: any[] = obj;
+      for (const index in tupleData) {
+        const item = tupleData[index];
-          parsedTuple.push(itemParser.parse(item, params));
-        } catch (err) {
-          console.log(`mering child: ${index}`);
-          tupleError.mergeChild(index, err);
-        }
-      }
-      if (!tupleError.empty) {
-        throw tupleError;
-      }
+          parsedTuple.push(itemParser.parse(item, { ...params, path: [...params.path, index] }));
+        } catch (err) {
+          // console.log(`mering child: ${index}`);
+          error.addErrors(err.errors);
+          // tupleError.mergeChild(index, err);
+        }
+      }
+      // if (!tupleError.isEmpty) {
+      //   throw tupleError;
+      // }
-      if (obj !== def.value) throw ZodError.fromString(`${obj} !== ${def.value}`);
+      if (obj !== def.value) {
+        error.addError(makeError({ code: ZodErrorCode.invalid_literal_value, expected: def.value }));
+        // throw ZodError.fromString(`${obj} !== ${def.value}`);
+      }
-        throw ZodError.fromString(`""${obj}"" does not match any value in enum`);
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_enum_value,
+            options: def.values,
+          }),
+        );
+        // throw ZodError.fromString(`""${obj}"" does not match any value in enum`);
-      if (typeof obj !== 'function') {
-        throw ZodError.fromString(`Non-function type: ""${typeof obj}""`);
+      if (parsedType !== ParsedType.function) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.function,
+            received: parsedType,
+          }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Non-function type: ""${typeof obj}""`);
-          const result = obj(...(args as any));
+        } catch (err) {
+          if (err instanceof ZodError) {
+            const argsError = new ZodError([]);
+            argsError.addError(
+              makeError({
+                code: ZodErrorCode.invalid_arguments,
+                suberrors: [err],
+              }),
+            );
+            throw argsError;
+          }
+          throw err;
+        }
+
+        const result = obj(...(args as any));
+
+        try {
-          return result;
-        } catch (err) {
+        } catch (err) {
+          if (err instanceof ZodError) {
+            const returnsError = new ZodError([]);
+            returnsError.addError(
+              makeError({
+                code: ZodErrorCode.invalid_return_type,
+                suberrors: [err],
+              }),
+            );
+            throw returnsError;
+          }
+
+        def.returns.parse(result);
+        return result;
-      if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
-      if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
-
-      const parsedRecord: any = {};
-      const recordError = new ZodError();
+      if (parsedType !== ParsedType.object) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.object,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      // if (typeof obj !== 'object') throw ZodError.fromString(`Non-object type: ${typeof obj}`);
+      // if (Array.isArray(obj)) throw ZodError.fromString(`Non-object type: array`);
+
+      // const parsedRecord: any = {};
+      // const recordError = new ZodError([]);
-          parsedRecord[key] = def.valueType.parse(obj[key]);
-        } catch (err) {
-          recordError.mergeChild(key, err);
-        }
-      }
-      if (!recordError.empty) throw recordError;
+          // parsedRecord[key] =
+          def.valueType.parse(obj[key], { ...params, path: [...params.path, key] });
+        } catch (err) {
+          error.addErrors(err.errors);
+          // recordError.mergeChild(key, err);
+        }
+      }
+      // if (!recordError.isEmpty) throw recordError;
-      if (obj instanceof Date) {
-        if (isNaN(obj.getTime())) {
-          // return obj;
-          // } else {
-          throw ZodError.fromString(`Invalid date.`);
-        }
-      } else {
-        throw ZodError.fromString(`Non-Date type: ${typeof obj}`);
+      if (!(obj instanceof Date)) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.date,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      if (isNaN(obj.getTime())) {
+        // if (isNaN(obj.getTime())) {
+        // return obj;
+        // } else {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_date,
+          }),
+        );
+        throw error;
+        // throw ZodError.fromString(`Invalid date.`);
+        // }
-      if (!obj.then || typeof obj.then !== 'function') {
-        console.log(JSON.stringify(obj, null, 2));
-        throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
-      }
-      if (!obj.catch || typeof obj.catch !== 'function') {
-        console.log(JSON.stringify(obj, null, 2));
-        throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
-      }
+      if (parsedType !== ParsedType.promise) {
+        error.addError(
+          makeError({
+            code: ZodErrorCode.invalid_type,
+            expected: ParsedType.promise,
+            received: parsedType,
+          }),
+        );
+        throw error;
+      }
+      // if (!obj.then || typeof obj.then !== 'function') {
+      //   console.log(JSON.stringify(obj, null, 2));
+      //   throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
+      // }
+      // if (!obj.catch || typeof obj.catch !== 'function') {
+      //   console.log(JSON.stringify(obj, null, 2));
+      //   throw ZodError.fromString(`Non-Promise type: ${typeof obj}`);
+      // }
-      if (def.checks) {
-        throw ZodError.fromString(""Can't apply custom validators to Promise schemas."");
-      }
+      // if (def.checks) {
+      //   throw ZodError.fromString(""Can't apply custom validators to Promise schemas."");
+      // }
-          const parsed = def.type.parse(objValue);
+          const parsed = def.type.parse(objValue, params);
-      throw ZodError.fromString(check.message || `Failed custom check.`);
+      error.addError(
+        makeError({
+          code: ZodErrorCode.custom_error,
+          params: check.params,
+          message: check.message,
+        }),
+      );
+      // throw ZodError.fromString(check.message || `Failed custom check.`);
+  if (!error.isEmpty) {
+    throw error;
+  }
+"
colinhacks_zod,4e9dd5593495d9807279463c903df61775d83cb9,"Fixed merge conflicts, got z.lazy.object working with z.toZod. holy grail achieved.",src/playground.ts,"-// import * as z from '.';
+import * as z from '.';
+import { ZodErrorCode } from './ZodError';
+import { ErrorMap } from './errorMap';
+
+const errorMap: ErrorMap = (error, ctx) => {
+  if (error.code === ZodErrorCode.invalid_type) {
+    if (error.expected === 'string') {
+      return ""This ain't no string!"";
+    }
+  }
+  if (error.code === ZodErrorCode.custom_error) {
+    return JSON.stringify(error.params, null, 2);
+  }
+  return ctx.defaultError;
+};
+errorMap;
+try {
+  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
+    return arg.length as any;
+  });
+  checker('12' as any);
+
+  // z.string()
+  //   .refinement({
+  //     check: val => val.length > 12,
+  //     // params: { test: 15 },
+  //     message: 'Override!',
+  //   })
+  //   .parse('asdf', { errorMap });
+} catch (err) {
+  console.log(JSON.stringify(err.errors, null, 2));
+}
+
+try {
+  const validationSchema = z
+    .object({
+      firstName: z.string().optional(),
+      lastName: z.string().optional(),
+      email: z.string().email(),
+      password: z.string(),
+      confirmPassword: z.string(),
+    })
+    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+
+  validationSchema.parse({
+    firstName: 'zod',
+    lastName: '',
+    email: 'theba@zod.c',
+    password: 'thetetathea',
+    confirmPassword: 'thethtbet',
+  });
+} catch (err) {
+  console.log(JSON.stringify(err.errors, null, 2));
+}
+
+// z.number().parse('12', { errorMap });","+
+// interface Category {
+//   name: string;
+//   subcategories: Category[];
+// }
+
+// const y = z.lazy(()=>z.string());
+
+// const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+//   name: z.string(),
+//   subcategories: z.array(Category),
+// }));","-// import * as z from '.';
+import * as z from '.';
+import { ZodErrorCode } from './ZodError';
+import { ErrorMap } from './errorMap';
+
+interface Category {
+  name: string;
+  subcategories: Category[];
+}
+
+const Category: z.toZod<Category> = z.lazy.object(() => ({
+  name: z.string(),
+  subcategories: z.array(Category),
+}));
+
+const errorMap: ErrorMap = (error, ctx) => {
+  if (error.code === ZodErrorCode.invalid_type) {
+    if (error.expected === 'string') {
+      return ""This ain't no string!"";
+    }
+  }
+  if (error.code === ZodErrorCode.custom_error) {
+    return JSON.stringify(error.params, null, 2);
+  }
+  return ctx.defaultError;
+};
+errorMap;
+try {
+  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement(arg => {
+    return arg.length as any;
+  });
+  checker('12' as any);
+
+  // z.string()
+  //   .refinement({
+  //     check: val => val.length > 12,
+  //     // params: { test: 15 },
+  //     message: 'Override!',
+  //   })
+  //   .parse('asdf', { errorMap });
+} catch (err) {
+  console.log(JSON.stringify(err.errors, null, 2));
+}
+
+try {
+  const validationSchema = z
+    .object({
+      firstName: z.string().optional(),
+      lastName: z.string().optional(),
+      email: z.string().email(),
+      password: z.string(),
+      confirmPassword: z.string(),
+    })
+    .refine(data => data.password === data.confirmPassword, 'Both password and confirmation must match');
+
+  validationSchema.parse({
+    firstName: 'zod',
+    lastName: '',
+    email: 'theba@zod.c',
+    password: 'thetetathea',
+    confirmPassword: 'thethtbet',
+  });
+} catch (err) {
+  console.log(JSON.stringify(err.errors, null, 2));
+}
+
+// z.number().parse('12', { errorMap });
+
+// interface Category {
+//   name: string;
+//   subcategories: Category[];
+// }
+
+// const y = z.lazy(()=>z.string());
+
+// const Category: z.lazyobject<Category> = z.lazy.object(() => ({
+//   name: z.string(),
+//   subcategories: z.array(Category),
+// }));"
